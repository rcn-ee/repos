From 23168b50c1033b31d186d1ff0080928b68dce17a Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Tue, 19 Jan 2016 16:03:59 -0600
Subject: [PATCH] boost-1.58-endian

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 boost/endian/arithmetic.hpp                        | 413 +++++++++++
 boost/endian/buffers.hpp                           | 515 +++++++++++++
 boost/endian/conversion.hpp                        | 487 ++++++++++++
 boost/endian/detail/config.hpp                     |  62 ++
 boost/endian/detail/cover_operators.hpp            | 142 ++++
 boost/endian/detail/disable_warnings.hpp           |  33 +
 boost/endian/detail/disable_warnings_pop.hpp       |  12 +
 boost/endian/detail/intrinsic.hpp                  |  64 ++
 boost/endian/detail/lightweight_test.hpp           | 223 ++++++
 boost/endian/endian.hpp                            |  19 +
 boost/endian/std_pair.hpp                          |  38 +
 libs/endian/README                                 |  29 +
 libs/endian/benchmark/Jamfile.v2                   |  25 +
 libs/endian/benchmark/test.bat                     |  12 +
 libs/endian/doc/arithmetic.html                    | 643 ++++++++++++++++
 libs/endian/doc/bikeshed.txt                       |  79 ++
 libs/endian/doc/buffers.html                       | 614 ++++++++++++++++
 libs/endian/doc/choosing_approach.html             | 412 +++++++++++
 libs/endian/doc/conversion.html                    | 371 ++++++++++
 libs/endian/doc/fp_concerns.html                   |  97 +++
 libs/endian/doc/index.html                         | 616 ++++++++++++++++
 libs/endian/doc/mini_review_topics.html            | 150 ++++
 libs/endian/doc/msvc_readme.txt                    |  31 +
 libs/endian/doc/publish.bat                        |   8 +
 libs/endian/doc/styles.css                         |  20 +
 libs/endian/doc/todo_list.html                     | 106 +++
 libs/endian/example/conversion_use_case.cpp        |  51 ++
 libs/endian/example/endian_example.cpp             |  75 ++
 libs/endian/example/third_party_format.hpp         |  19 +
 libs/endian/example/udt_conversion_example.cpp     |  79 ++
 libs/endian/example/use_cases.cpp                  | 152 ++++
 libs/endian/index.html                             |  14 +
 libs/endian/meta/libraries.json                    |  16 +
 libs/endian/test/Jamfile.v2                        |  28 +
 libs/endian/test/benchmark.cpp                     | 233 ++++++
 libs/endian/test/buffer_test.cpp                   | 183 +++++
 libs/endian/test/conversion_test.cpp               | 371 ++++++++++
 libs/endian/test/deprecated_test.cpp               | 183 +++++
 libs/endian/test/endian_in_union_test.cpp          |  86 +++
 libs/endian/test/endian_operations_test.cpp        | 504 +++++++++++++
 libs/endian/test/endian_test.cpp                   | 812 +++++++++++++++++++++
 libs/endian/test/intrinsic_test.cpp                |  27 +
 libs/endian/test/loop_time_test.cpp                | 316 ++++++++
 .../msvc/associated-files/associated-files.vcxproj | 137 ++++
 .../associated-files.vcxproj.filters               |  63 ++
 libs/endian/test/msvc/benchmark/benchmark.vcxproj  | 177 +++++
 libs/endian/test/msvc/boost-no-inspect             |   0
 .../test/msvc/buffer_test/buffer_test.vcxproj      | 160 ++++
 libs/endian/test/msvc/common.props                 |  23 +
 .../conversion_use_case.vcxproj                    | 157 ++++
 .../msvc/converter_test/converter_test.vcxproj     | 169 +++++
 .../msvc/deprecated_test/deprecated_test.vcxproj   |  88 +++
 libs/endian/test/msvc/endian.sln                   | 160 ++++
 .../msvc/endian_example/endian_example.vcxproj     | 165 +++++
 .../endian_in_union_test.vcxproj                   | 169 +++++
 .../endian_operations_test.vcxproj                 | 179 +++++
 .../test/msvc/endian_test/endian_test.vcxproj      | 171 +++++
 .../msvc/loop_time_test/loop_time_test.vcxproj     | 167 +++++
 .../scoped_enum_emulation_test.vcxproj             | 165 +++++
 .../endian/test/msvc/speed_test/speed_test.vcxproj | 166 +++++
 .../udt_conversion_example.vcxproj                 | 153 ++++
 .../endian/test/msvc/uses_cases/uses_cases.vcxproj | 157 ++++
 libs/endian/test/scoped_enum_emulation_test.cpp    |  48 ++
 libs/endian/test/speed_test.cpp                    | 195 +++++
 libs/endian/test/speed_test_functions.cpp          |  96 +++
 libs/endian/test/speed_test_functions.hpp          |  56 ++
 66 files changed, 11391 insertions(+)
 create mode 100644 boost/endian/arithmetic.hpp
 create mode 100644 boost/endian/buffers.hpp
 create mode 100644 boost/endian/conversion.hpp
 create mode 100644 boost/endian/detail/config.hpp
 create mode 100644 boost/endian/detail/cover_operators.hpp
 create mode 100644 boost/endian/detail/disable_warnings.hpp
 create mode 100644 boost/endian/detail/disable_warnings_pop.hpp
 create mode 100644 boost/endian/detail/intrinsic.hpp
 create mode 100644 boost/endian/detail/lightweight_test.hpp
 create mode 100644 boost/endian/endian.hpp
 create mode 100644 boost/endian/std_pair.hpp
 create mode 100644 libs/endian/README
 create mode 100644 libs/endian/benchmark/Jamfile.v2
 create mode 100644 libs/endian/benchmark/test.bat
 create mode 100644 libs/endian/doc/arithmetic.html
 create mode 100644 libs/endian/doc/bikeshed.txt
 create mode 100644 libs/endian/doc/buffers.html
 create mode 100644 libs/endian/doc/choosing_approach.html
 create mode 100644 libs/endian/doc/conversion.html
 create mode 100644 libs/endian/doc/fp_concerns.html
 create mode 100644 libs/endian/doc/index.html
 create mode 100644 libs/endian/doc/mini_review_topics.html
 create mode 100644 libs/endian/doc/msvc_readme.txt
 create mode 100644 libs/endian/doc/publish.bat
 create mode 100644 libs/endian/doc/styles.css
 create mode 100644 libs/endian/doc/todo_list.html
 create mode 100644 libs/endian/example/conversion_use_case.cpp
 create mode 100644 libs/endian/example/endian_example.cpp
 create mode 100644 libs/endian/example/third_party_format.hpp
 create mode 100644 libs/endian/example/udt_conversion_example.cpp
 create mode 100644 libs/endian/example/use_cases.cpp
 create mode 100644 libs/endian/index.html
 create mode 100644 libs/endian/meta/libraries.json
 create mode 100644 libs/endian/test/Jamfile.v2
 create mode 100644 libs/endian/test/benchmark.cpp
 create mode 100644 libs/endian/test/buffer_test.cpp
 create mode 100644 libs/endian/test/conversion_test.cpp
 create mode 100644 libs/endian/test/deprecated_test.cpp
 create mode 100644 libs/endian/test/endian_in_union_test.cpp
 create mode 100644 libs/endian/test/endian_operations_test.cpp
 create mode 100644 libs/endian/test/endian_test.cpp
 create mode 100644 libs/endian/test/intrinsic_test.cpp
 create mode 100644 libs/endian/test/loop_time_test.cpp
 create mode 100644 libs/endian/test/msvc/associated-files/associated-files.vcxproj
 create mode 100644 libs/endian/test/msvc/associated-files/associated-files.vcxproj.filters
 create mode 100644 libs/endian/test/msvc/benchmark/benchmark.vcxproj
 create mode 100644 libs/endian/test/msvc/boost-no-inspect
 create mode 100644 libs/endian/test/msvc/buffer_test/buffer_test.vcxproj
 create mode 100644 libs/endian/test/msvc/common.props
 create mode 100644 libs/endian/test/msvc/conversion_use_case/conversion_use_case.vcxproj
 create mode 100644 libs/endian/test/msvc/converter_test/converter_test.vcxproj
 create mode 100644 libs/endian/test/msvc/deprecated_test/deprecated_test.vcxproj
 create mode 100644 libs/endian/test/msvc/endian.sln
 create mode 100644 libs/endian/test/msvc/endian_example/endian_example.vcxproj
 create mode 100644 libs/endian/test/msvc/endian_in_union_test/endian_in_union_test.vcxproj
 create mode 100644 libs/endian/test/msvc/endian_operations_test/endian_operations_test.vcxproj
 create mode 100644 libs/endian/test/msvc/endian_test/endian_test.vcxproj
 create mode 100644 libs/endian/test/msvc/loop_time_test/loop_time_test.vcxproj
 create mode 100644 libs/endian/test/msvc/scoped_enum_emulation_test/scoped_enum_emulation_test.vcxproj
 create mode 100644 libs/endian/test/msvc/speed_test/speed_test.vcxproj
 create mode 100644 libs/endian/test/msvc/udt_conversion_example/udt_conversion_example.vcxproj
 create mode 100644 libs/endian/test/msvc/uses_cases/uses_cases.vcxproj
 create mode 100644 libs/endian/test/scoped_enum_emulation_test.cpp
 create mode 100644 libs/endian/test/speed_test.cpp
 create mode 100644 libs/endian/test/speed_test_functions.cpp
 create mode 100644 libs/endian/test/speed_test_functions.hpp

diff --git a/boost/endian/arithmetic.hpp b/boost/endian/arithmetic.hpp
new file mode 100644
index 0000000..d8bcbe6
--- /dev/null
+++ b/boost/endian/arithmetic.hpp
@@ -0,0 +1,413 @@
+//  boost/endian/arithmetic.hpp  -------------------------------------------------------//
+
+//  (C) Copyright Darin Adler 2000
+//  (C) Copyright Beman Dawes 2006, 2009, 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//--------------------------------------------------------------------------------------//
+
+//  Original design developed by Darin Adler based on classes developed by Mark
+//  Borgerding. Four original class templates were combined into a single endian
+//  class template by Beman Dawes, who also added the unrolled_byte_loops sign
+//  partial specialization to correctly extend the sign when cover integer size
+//  differs from endian representation size.
+
+// TODO: When a compiler supporting constexpr becomes available, try possible uses.
+
+#ifndef BOOST_ENDIAN_ARITHMETIC_HPP
+#define BOOST_ENDIAN_ARITHMETIC_HPP
+
+#if defined(_MSC_VER)  
+# pragma warning(push)  
+# pragma warning(disable:4365)  // conversion ... signed/unsigned mismatch
+#endif
+
+#ifdef BOOST_ENDIAN_LOG
+# include <iostream>
+#endif
+
+#if defined(__BORLANDC__) || defined( __CODEGEARC__)
+# pragma pack(push, 1)
+#endif
+
+#include <boost/config.hpp>
+#include <boost/predef/detail/endian_compat.h>
+#include <boost/endian/conversion.hpp>
+#include <boost/endian/buffers.hpp>
+#define  BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+#include <boost/endian/detail/cover_operators.hpp>
+#undef   BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+#include <boost/type_traits/is_signed.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/static_assert.hpp>
+#include <boost/core/scoped_enum.hpp>
+#include <iosfwd>
+#include <climits>
+
+# if CHAR_BIT != 8
+#   error Platforms with CHAR_BIT != 8 are not supported
+# endif
+
+# ifdef BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
+#   define BOOST_ENDIAN_DEFAULT_CONSTRUCT {}          // C++03
+# else
+#   define BOOST_ENDIAN_DEFAULT_CONSTRUCT = default;  // C++0x
+# endif
+
+# if defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && defined(BOOST_ENDIAN_FORCE_PODNESS)
+#   define BOOST_ENDIAN_NO_CTORS
+# endif
+
+# ifndef BOOST_ENDIAN_EXPLICIT_CTORS
+#   define BOOST_ENDIAN_EXPLICIT_OPT
+# else
+#   define BOOST_ENDIAN_EXPLICIT_OPT explicit
+# endif
+
+//----------------------------------  synopsis  ----------------------------------------//
+
+namespace boost
+{
+namespace endian
+{
+
+  template <BOOST_SCOPED_ENUM(order) Order, class T, std::size_t n_bits,
+    BOOST_SCOPED_ENUM(align) A = align::no>
+      class endian_arithmetic;
+
+  // big endian signed integer aligned types
+  typedef endian_arithmetic<order::big, int8_t, 8, align::yes>        big_int8_at;
+  typedef endian_arithmetic<order::big, int16_t, 16, align::yes>      big_int16_at;
+  typedef endian_arithmetic<order::big, int32_t, 32, align::yes>      big_int32_at;
+  typedef endian_arithmetic<order::big, int64_t, 64, align::yes>      big_int64_at;
+
+  // big endian unsigned integer aligned types
+  typedef endian_arithmetic<order::big, uint8_t, 8, align::yes>       big_uint8_at;
+  typedef endian_arithmetic<order::big, uint16_t, 16, align::yes>     big_uint16_at;
+  typedef endian_arithmetic<order::big, uint32_t, 32, align::yes>     big_uint32_at;
+  typedef endian_arithmetic<order::big, uint64_t, 64, align::yes>     big_uint64_at;
+
+  // little endian signed integer aligned types
+  typedef endian_arithmetic<order::little, int8_t, 8, align::yes>     little_int8_at;
+  typedef endian_arithmetic<order::little, int16_t, 16, align::yes>   little_int16_at;
+  typedef endian_arithmetic<order::little, int32_t, 32, align::yes>   little_int32_at;
+  typedef endian_arithmetic<order::little, int64_t, 64, align::yes>   little_int64_at;
+
+  // little endian unsigned integer aligned types
+  typedef endian_arithmetic<order::little, uint8_t, 8, align::yes>    little_uint8_at;
+  typedef endian_arithmetic<order::little, uint16_t, 16, align::yes>  little_uint16_at;
+  typedef endian_arithmetic<order::little, uint32_t, 32, align::yes>  little_uint32_at;
+  typedef endian_arithmetic<order::little, uint64_t, 64, align::yes>  little_uint64_at;
+
+  // aligned native endian typedefs are not provided because
+  // <cstdint> types are superior for this use case
+
+  // big endian signed integer unaligned types
+  typedef endian_arithmetic<order::big, int_least8_t, 8>        big_int8_t;
+  typedef endian_arithmetic<order::big, int_least16_t, 16>      big_int16_t;
+  typedef endian_arithmetic<order::big, int_least32_t, 24>      big_int24_t;
+  typedef endian_arithmetic<order::big, int_least32_t, 32>      big_int32_t;
+  typedef endian_arithmetic<order::big, int_least64_t, 40>      big_int40_t;
+  typedef endian_arithmetic<order::big, int_least64_t, 48>      big_int48_t;
+  typedef endian_arithmetic<order::big, int_least64_t, 56>      big_int56_t;
+  typedef endian_arithmetic<order::big, int_least64_t, 64>      big_int64_t;
+
+  // big endian unsigned integer unaligned types
+  typedef endian_arithmetic<order::big, uint_least8_t, 8>       big_uint8_t;
+  typedef endian_arithmetic<order::big, uint_least16_t, 16>     big_uint16_t;
+  typedef endian_arithmetic<order::big, uint_least32_t, 24>     big_uint24_t;
+  typedef endian_arithmetic<order::big, uint_least32_t, 32>     big_uint32_t;
+  typedef endian_arithmetic<order::big, uint_least64_t, 40>     big_uint40_t;
+  typedef endian_arithmetic<order::big, uint_least64_t, 48>     big_uint48_t;
+  typedef endian_arithmetic<order::big, uint_least64_t, 56>     big_uint56_t;
+  typedef endian_arithmetic<order::big, uint_least64_t, 64>     big_uint64_t;
+
+  // little endian signed integer unaligned types
+  typedef endian_arithmetic<order::little, int_least8_t, 8>     little_int8_t;
+  typedef endian_arithmetic<order::little, int_least16_t, 16>   little_int16_t;
+  typedef endian_arithmetic<order::little, int_least32_t, 24>   little_int24_t;
+  typedef endian_arithmetic<order::little, int_least32_t, 32>   little_int32_t;
+  typedef endian_arithmetic<order::little, int_least64_t, 40>   little_int40_t;
+  typedef endian_arithmetic<order::little, int_least64_t, 48>   little_int48_t;
+  typedef endian_arithmetic<order::little, int_least64_t, 56>   little_int56_t;
+  typedef endian_arithmetic<order::little, int_least64_t, 64>   little_int64_t;
+
+  // little endian unsigned integer unaligned types
+  typedef endian_arithmetic<order::little, uint_least8_t, 8>    little_uint8_t;
+  typedef endian_arithmetic<order::little, uint_least16_t, 16>  little_uint16_t;
+  typedef endian_arithmetic<order::little, uint_least32_t, 24>  little_uint24_t;
+  typedef endian_arithmetic<order::little, uint_least32_t, 32>  little_uint32_t;
+  typedef endian_arithmetic<order::little, uint_least64_t, 40>  little_uint40_t;
+  typedef endian_arithmetic<order::little, uint_least64_t, 48>  little_uint48_t;
+  typedef endian_arithmetic<order::little, uint_least64_t, 56>  little_uint56_t;
+  typedef endian_arithmetic<order::little, uint_least64_t, 64>  little_uint64_t;
+
+# ifdef BOOST_BIG_ENDIAN
+  // native endian signed integer unaligned types
+  typedef big_int8_t   native_int8_t;
+  typedef big_int16_t  native_int16_t;
+  typedef big_int24_t  native_int24_t;
+  typedef big_int32_t  native_int32_t;
+  typedef big_int40_t  native_int40_t;
+  typedef big_int48_t  native_int48_t;
+  typedef big_int56_t  native_int56_t;
+  typedef big_int64_t  native_int64_t;
+
+  // native endian unsigned integer unaligned types
+  typedef big_uint8_t   native_uint8_t;
+  typedef big_uint16_t  native_uint16_t;
+  typedef big_uint24_t  native_uint24_t;
+  typedef big_uint32_t  native_uint32_t;
+  typedef big_uint40_t  native_uint40_t;
+  typedef big_uint48_t  native_uint48_t;
+  typedef big_uint56_t  native_uint56_t;
+  typedef big_uint64_t  native_uint64_t;
+# else
+  // native endian signed integer unaligned types
+  typedef little_int8_t   native_int8_t;
+  typedef little_int16_t  native_int16_t;
+  typedef little_int24_t  native_int24_t;
+  typedef little_int32_t  native_int32_t;
+  typedef little_int40_t  native_int40_t;
+  typedef little_int48_t  native_int48_t;
+  typedef little_int56_t  native_int56_t;
+  typedef little_int64_t  native_int64_t;
+
+  // native endian unsigned integer unaligned types
+  typedef little_uint8_t   native_uint8_t;
+  typedef little_uint16_t  native_uint16_t;
+  typedef little_uint24_t  native_uint24_t;
+  typedef little_uint32_t  native_uint32_t;
+  typedef little_uint40_t  native_uint40_t;
+  typedef little_uint48_t  native_uint48_t;
+  typedef little_uint56_t  native_uint56_t;
+  typedef little_uint64_t  native_uint64_t;
+# endif
+
+# ifdef BOOST_ENDIAN_DEPRECATED_NAMES
+
+  typedef order endianness;
+  typedef align alignment;
+
+# ifndef  BOOST_NO_CXX11_TEMPLATE_ALIASES
+  template <BOOST_SCOPED_ENUM(order) Order, class T, std::size_t n_bits,
+    BOOST_SCOPED_ENUM(align) Align = align::no>
+  using endian = endian_arithmetic<Order, T, n_bits, Align>;
+# endif
+
+  // unaligned big endian signed integer types
+  typedef endian_arithmetic< order::big, int_least8_t, 8 >           big8_t;
+  typedef endian_arithmetic< order::big, int_least16_t, 16 >         big16_t;
+  typedef endian_arithmetic< order::big, int_least32_t, 24 >         big24_t;
+  typedef endian_arithmetic< order::big, int_least32_t, 32 >         big32_t;
+  typedef endian_arithmetic< order::big, int_least64_t, 40 >         big40_t;
+  typedef endian_arithmetic< order::big, int_least64_t, 48 >         big48_t;
+  typedef endian_arithmetic< order::big, int_least64_t, 56 >         big56_t;
+  typedef endian_arithmetic< order::big, int_least64_t, 64 >         big64_t;
+
+  // unaligned big endian_arithmetic unsigned integer types
+  typedef endian_arithmetic< order::big, uint_least8_t, 8 >          ubig8_t;
+  typedef endian_arithmetic< order::big, uint_least16_t, 16 >        ubig16_t;
+  typedef endian_arithmetic< order::big, uint_least32_t, 24 >        ubig24_t;
+  typedef endian_arithmetic< order::big, uint_least32_t, 32 >        ubig32_t;
+  typedef endian_arithmetic< order::big, uint_least64_t, 40 >        ubig40_t;
+  typedef endian_arithmetic< order::big, uint_least64_t, 48 >        ubig48_t;
+  typedef endian_arithmetic< order::big, uint_least64_t, 56 >        ubig56_t;
+  typedef endian_arithmetic< order::big, uint_least64_t, 64 >        ubig64_t;
+
+  // unaligned little endian_arithmetic signed integer types
+  typedef endian_arithmetic< order::little, int_least8_t, 8 >        little8_t;
+  typedef endian_arithmetic< order::little, int_least16_t, 16 >      little16_t;
+  typedef endian_arithmetic< order::little, int_least32_t, 24 >      little24_t;
+  typedef endian_arithmetic< order::little, int_least32_t, 32 >      little32_t;
+  typedef endian_arithmetic< order::little, int_least64_t, 40 >      little40_t;
+  typedef endian_arithmetic< order::little, int_least64_t, 48 >      little48_t;
+  typedef endian_arithmetic< order::little, int_least64_t, 56 >      little56_t;
+  typedef endian_arithmetic< order::little, int_least64_t, 64 >      little64_t;
+
+  // unaligned little endian_arithmetic unsigned integer types
+  typedef endian_arithmetic< order::little, uint_least8_t, 8 >       ulittle8_t;
+  typedef endian_arithmetic< order::little, uint_least16_t, 16 >     ulittle16_t;
+  typedef endian_arithmetic< order::little, uint_least32_t, 24 >     ulittle24_t;
+  typedef endian_arithmetic< order::little, uint_least32_t, 32 >     ulittle32_t;
+  typedef endian_arithmetic< order::little, uint_least64_t, 40 >     ulittle40_t;
+  typedef endian_arithmetic< order::little, uint_least64_t, 48 >     ulittle48_t;
+  typedef endian_arithmetic< order::little, uint_least64_t, 56 >     ulittle56_t;
+  typedef endian_arithmetic< order::little, uint_least64_t, 64 >     ulittle64_t;
+
+  // unaligned native endian_arithmetic signed integer types
+  typedef endian_arithmetic< order::native, int_least8_t, 8 >        native8_t;
+  typedef endian_arithmetic< order::native, int_least16_t, 16 >      native16_t;
+  typedef endian_arithmetic< order::native, int_least32_t, 24 >      native24_t;
+  typedef endian_arithmetic< order::native, int_least32_t, 32 >      native32_t;
+  typedef endian_arithmetic< order::native, int_least64_t, 40 >      native40_t;
+  typedef endian_arithmetic< order::native, int_least64_t, 48 >      native48_t;
+  typedef endian_arithmetic< order::native, int_least64_t, 56 >      native56_t;
+  typedef endian_arithmetic< order::native, int_least64_t, 64 >      native64_t;
+
+  // unaligned native endian_arithmetic unsigned integer types
+  typedef endian_arithmetic< order::native, uint_least8_t, 8 >       unative8_t;
+  typedef endian_arithmetic< order::native, uint_least16_t, 16 >     unative16_t;
+  typedef endian_arithmetic< order::native, uint_least32_t, 24 >     unative24_t;
+  typedef endian_arithmetic< order::native, uint_least32_t, 32 >     unative32_t;
+  typedef endian_arithmetic< order::native, uint_least64_t, 40 >     unative40_t;
+  typedef endian_arithmetic< order::native, uint_least64_t, 48 >     unative48_t;
+  typedef endian_arithmetic< order::native, uint_least64_t, 56 >     unative56_t;
+  typedef endian_arithmetic< order::native, uint_least64_t, 64 >     unative64_t;
+
+  //     aligned native endian_arithmetic typedefs are not provided because
+  //     <cstdint> types are superior for this use case
+
+  typedef endian_arithmetic< order::big, int16_t, 16, align::yes >      aligned_big16_t;
+  typedef endian_arithmetic< order::big, uint16_t, 16, align::yes >     aligned_ubig16_t;
+  typedef endian_arithmetic< order::little, int16_t, 16, align::yes >   aligned_little16_t;
+  typedef endian_arithmetic< order::little, uint16_t, 16, align::yes >  aligned_ulittle16_t;
+
+  typedef endian_arithmetic< order::big, int32_t, 32, align::yes >      aligned_big32_t;
+  typedef endian_arithmetic< order::big, uint32_t, 32, align::yes >     aligned_ubig32_t;
+  typedef endian_arithmetic< order::little, int32_t, 32, align::yes >   aligned_little32_t;
+  typedef endian_arithmetic< order::little, uint32_t, 32, align::yes >  aligned_ulittle32_t;
+
+  typedef endian_arithmetic< order::big, int64_t, 64, align::yes >      aligned_big64_t;
+  typedef endian_arithmetic< order::big, uint64_t, 64, align::yes >     aligned_ubig64_t;
+  typedef endian_arithmetic< order::little, int64_t, 64, align::yes >   aligned_little64_t;
+  typedef endian_arithmetic< order::little, uint64_t, 64, align::yes >  aligned_ulittle64_t;
+
+# endif
+
+//----------------------------------  end synopsis  ------------------------------------//
+
+//  endian class template specializations  ---------------------------------------------//
+
+    //  Specializations that represent unaligned bytes.
+    //  Taking an integer type as a parameter provides a nice way to pass both
+    //  the size and signness of the desired integer and get the appropriate
+    //  corresponding integer type for the interface.
+
+    //  unaligned integer big endian specialization
+    template <typename T, std::size_t n_bits>
+    class endian_arithmetic< order::big, T, n_bits, align::no >
+      : public endian_buffer< order::big, T, n_bits, align::no >,
+        cover_operators<endian_arithmetic<order::big, T, n_bits>, T>
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_arithmetic() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        BOOST_ENDIAN_EXPLICIT_OPT endian_arithmetic(T val) BOOST_NOEXCEPT
+        { 
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "big, unaligned, " << n_bits << "-bits, construct(" << val << ")\n";
+#       endif
+          detail::store_big_endian<T, n_bits/8>(this->m_value, val);
+        }
+#     endif
+        endian_arithmetic& operator=(T val) BOOST_NOEXCEPT
+          { detail::store_big_endian<T, n_bits/8>(this->m_value, val); return *this; }
+        operator value_type() const BOOST_NOEXCEPT { return this->value(); }
+    };
+
+    //  unaligned little endian specialization
+    template <typename T, std::size_t n_bits>
+    class endian_arithmetic< order::little, T, n_bits, align::no >
+      : public endian_buffer< order::little, T, n_bits, align::no >,
+        cover_operators< endian_arithmetic< order::little, T, n_bits >, T >
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_arithmetic() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        BOOST_ENDIAN_EXPLICIT_OPT endian_arithmetic(T val) BOOST_NOEXCEPT
+        { 
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "little, unaligned, " << n_bits << "-bits, construct(" << val << ")\n";
+#       endif
+          detail::store_little_endian<T, n_bits/8>(this->m_value, val);
+        }
+#     endif
+        endian_arithmetic& operator=(T val) BOOST_NOEXCEPT
+          { detail::store_little_endian<T, n_bits/8>(this->m_value, val); return *this; }
+        operator value_type() const BOOST_NOEXCEPT { return this->value(); }
+    };
+
+  //  align::yes specializations; only n_bits == 16/32/64 supported
+
+    //  aligned big endian specialization
+    template <typename T, std::size_t n_bits>
+    class endian_arithmetic<order::big, T, n_bits, align::yes>
+      : public endian_buffer< order::big, T, n_bits, align::yes >,
+        cover_operators<endian_arithmetic<order::big, T, n_bits, align::yes>, T>
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+        BOOST_STATIC_ASSERT( sizeof(T) == n_bits/8 );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_arithmetic() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        BOOST_ENDIAN_EXPLICIT_OPT endian_arithmetic(T val) BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "big, aligned, " << n_bits << "-bits, construct(" << val << ")\n";
+#       endif
+          this->m_value = ::boost::endian::native_to_big(val);
+        }
+
+#     endif  
+        endian_arithmetic& operator=(T val) BOOST_NOEXCEPT
+        {
+          this->m_value = ::boost::endian::native_to_big(val);
+          return *this;
+        }
+        operator value_type() const BOOST_NOEXCEPT { return this->value(); }
+    };
+
+    //  aligned little endian specialization
+    template <typename T, std::size_t n_bits>
+    class endian_arithmetic<order::little, T, n_bits, align::yes>
+      : public endian_buffer< order::little, T, n_bits, align::yes >,
+        cover_operators<endian_arithmetic<order::little, T, n_bits, align::yes>, T>
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+        BOOST_STATIC_ASSERT( sizeof(T) == n_bits/8 );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_arithmetic() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        BOOST_ENDIAN_EXPLICIT_OPT endian_arithmetic(T val) BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "little, aligned, " << n_bits << "-bits, construct(" << val << ")\n";
+#       endif
+          this->m_value = ::boost::endian::native_to_little(val);
+        }
+#     endif  
+        endian_arithmetic& operator=(T val) BOOST_NOEXCEPT
+        {
+          this->m_value = ::boost::endian::native_to_little(val);
+          return *this;
+        }
+        operator value_type() const BOOST_NOEXCEPT { return this->value(); }
+    };
+
+} // namespace endian
+} // namespace boost
+
+#if defined(__BORLANDC__) || defined( __CODEGEARC__)
+# pragma pack(pop)
+#endif
+
+#if defined(_MSC_VER)  
+# pragma warning(pop)  
+#endif 
+
+#endif // BOOST_ENDIAN_ARITHMETIC_HPP
diff --git a/boost/endian/buffers.hpp b/boost/endian/buffers.hpp
new file mode 100644
index 0000000..b48b8de
--- /dev/null
+++ b/boost/endian/buffers.hpp
@@ -0,0 +1,515 @@
+//  boost/endian/buffers.hpp  ----------------------------------------------------------//
+
+//  (C) Copyright Darin Adler 2000
+//  (C) Copyright Beman Dawes 2006, 2009, 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//--------------------------------------------------------------------------------------//
+
+//  Original design developed by Darin Adler based on classes developed by Mark
+//  Borgerding. Four original class templates were combined into a single endian
+//  class template by Beman Dawes, who also added the unrolled_byte_loops sign
+//  partial specialization to correctly extend the sign when cover integer size
+//  differs from endian representation size.
+
+// TODO: When a compiler supporting constexpr becomes available, try possible uses.
+
+#ifndef BOOST_ENDIAN_BUFFERS_HPP
+#define BOOST_ENDIAN_BUFFERS_HPP
+
+#if defined(_MSC_VER)  
+# pragma warning(push)  
+# pragma warning(disable:4365)  // conversion ... signed/unsigned mismatch
+#endif
+
+#ifdef BOOST_ENDIAN_LOG
+# include <iostream>
+#endif
+
+#if defined(__BORLANDC__) || defined( __CODEGEARC__)
+# pragma pack(push, 1)
+#endif
+
+#include <boost/config.hpp>
+#include <boost/predef/detail/endian_compat.h>
+#include <boost/endian/conversion.hpp>
+#include <boost/type_traits/is_signed.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/static_assert.hpp>
+#include <boost/core/scoped_enum.hpp>
+#include <iosfwd>
+#include <climits>
+
+# if CHAR_BIT != 8
+#   error Platforms with CHAR_BIT != 8 are not supported
+# endif
+
+# ifdef BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
+#   define BOOST_ENDIAN_DEFAULT_CONSTRUCT {}          // C++03
+# else
+#   define BOOST_ENDIAN_DEFAULT_CONSTRUCT = default;  // C++0x
+# endif
+
+# if defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && defined(BOOST_ENDIAN_FORCE_PODNESS)
+#   define BOOST_ENDIAN_NO_CTORS
+# endif
+
+//----------------------------------  synopsis  ----------------------------------------//
+
+namespace boost
+{
+namespace endian
+{
+
+  BOOST_SCOPED_ENUM_START(align)
+  {no, yes
+#   ifdef BOOST_ENDIAN_DEPRECATED_NAMES
+      , unaligned = no, aligned = yes
+#   endif
+  }; BOOST_SCOPED_ENUM_END
+
+  template <BOOST_SCOPED_ENUM(order) Order, class T, std::size_t n_bits,
+    BOOST_SCOPED_ENUM(align) A = align::no>
+      class endian_buffer;
+
+  // aligned big endian signed integer buffers
+  typedef endian_buffer<order::big, int8_t, 8, align::yes>       big_int8_buf_at;
+  typedef endian_buffer<order::big, int16_t, 16, align::yes>     big_int16_buf_at;
+  typedef endian_buffer<order::big, int32_t, 32, align::yes>     big_int32_buf_at;
+  typedef endian_buffer<order::big, int64_t, 64, align::yes>     big_int64_buf_at;
+
+  // aligned big endian unsigned integer buffers
+  typedef endian_buffer<order::big, uint8_t, 8, align::yes>      big_uint8_buf_at;
+  typedef endian_buffer<order::big, uint16_t, 16, align::yes>    big_uint16_buf_at;
+  typedef endian_buffer<order::big, uint32_t, 32, align::yes>    big_uint32_buf_at;
+  typedef endian_buffer<order::big, uint64_t, 64, align::yes>    big_uint64_buf_at;
+
+  // aligned little endian signed integer buffers
+  typedef endian_buffer<order::little, int8_t, 8, align::yes>    little_int8_buf_at;
+  typedef endian_buffer<order::little, int16_t, 16, align::yes>  little_int16_buf_at;
+  typedef endian_buffer<order::little, int32_t, 32, align::yes>  little_int32_buf_at;
+  typedef endian_buffer<order::little, int64_t, 64, align::yes>  little_int64_buf_at;
+
+  // aligned little endian unsigned integer buffers
+  typedef endian_buffer<order::little, uint8_t, 8, align::yes>   little_uint8_buf_at;
+  typedef endian_buffer<order::little, uint16_t, 16, align::yes> little_uint16_buf_at;
+  typedef endian_buffer<order::little, uint32_t, 32, align::yes> little_uint32_buf_at;
+  typedef endian_buffer<order::little, uint64_t, 64, align::yes> little_uint64_buf_at;
+
+  // aligned native endian typedefs are not provided because
+  // <cstdint> types are superior for this use case
+
+  // unaligned big endian signed integer buffers
+  typedef endian_buffer<order::big, int_least8_t, 8>        big_int8_buf_t;
+  typedef endian_buffer<order::big, int_least16_t, 16>      big_int16_buf_t;
+  typedef endian_buffer<order::big, int_least32_t, 24>      big_int24_buf_t;
+  typedef endian_buffer<order::big, int_least32_t, 32>      big_int32_buf_t;
+  typedef endian_buffer<order::big, int_least64_t, 40>      big_int40_buf_t;
+  typedef endian_buffer<order::big, int_least64_t, 48>      big_int48_buf_t;
+  typedef endian_buffer<order::big, int_least64_t, 56>      big_int56_buf_t;
+  typedef endian_buffer<order::big, int_least64_t, 64>      big_int64_buf_t;
+
+  // unaligned big endian unsigned integer buffers
+  typedef endian_buffer<order::big, uint_least8_t, 8>       big_uint8_buf_t;
+  typedef endian_buffer<order::big, uint_least16_t, 16>     big_uint16_buf_t;
+  typedef endian_buffer<order::big, uint_least32_t, 24>     big_uint24_buf_t;
+  typedef endian_buffer<order::big, uint_least32_t, 32>     big_uint32_buf_t;
+  typedef endian_buffer<order::big, uint_least64_t, 40>     big_uint40_buf_t;
+  typedef endian_buffer<order::big, uint_least64_t, 48>     big_uint48_buf_t;
+  typedef endian_buffer<order::big, uint_least64_t, 56>     big_uint56_buf_t;
+  typedef endian_buffer<order::big, uint_least64_t, 64>     big_uint64_buf_t;
+
+  // unaligned little endian signed integer buffers
+  typedef endian_buffer<order::little, int_least8_t, 8>     little_int8_buf_t;
+  typedef endian_buffer<order::little, int_least16_t, 16>   little_int16_buf_t;
+  typedef endian_buffer<order::little, int_least32_t, 24>   little_int24_buf_t;
+  typedef endian_buffer<order::little, int_least32_t, 32>   little_int32_buf_t;
+  typedef endian_buffer<order::little, int_least64_t, 40>   little_int40_buf_t;
+  typedef endian_buffer<order::little, int_least64_t, 48>   little_int48_buf_t;
+  typedef endian_buffer<order::little, int_least64_t, 56>   little_int56_buf_t;
+  typedef endian_buffer<order::little, int_least64_t, 64>   little_int64_buf_t;
+
+  // unaligned little endian unsigned integer buffers
+  typedef endian_buffer<order::little, uint_least8_t, 8>    little_uint8_buf_t;
+  typedef endian_buffer<order::little, uint_least16_t, 16>  little_uint16_buf_t;
+  typedef endian_buffer<order::little, uint_least32_t, 24>  little_uint24_buf_t;
+  typedef endian_buffer<order::little, uint_least32_t, 32>  little_uint32_buf_t;
+  typedef endian_buffer<order::little, uint_least64_t, 40>  little_uint40_buf_t;
+  typedef endian_buffer<order::little, uint_least64_t, 48>  little_uint48_buf_t;
+  typedef endian_buffer<order::little, uint_least64_t, 56>  little_uint56_buf_t;
+  typedef endian_buffer<order::little, uint_least64_t, 64>  little_uint64_buf_t;
+
+# ifdef BOOST_BIG_ENDIAN
+  // unaligned native endian signed integer buffers
+  typedef big_int8_buf_t   native_int8_buf_t;
+  typedef big_int16_buf_t  native_int16_buf_t;
+  typedef big_int24_buf_t  native_int24_buf_t;
+  typedef big_int32_buf_t  native_int32_buf_t;
+  typedef big_int40_buf_t  native_int40_buf_t;
+  typedef big_int48_buf_t  native_int48_buf_t;
+  typedef big_int56_buf_t  native_int56_buf_t;
+  typedef big_int64_buf_t  native_int64_buf_t;
+
+  // unaligned native endian unsigned integer buffers
+  typedef big_uint8_buf_t   native_uint8_buf_t;
+  typedef big_uint16_buf_t  native_uint16_buf_t;
+  typedef big_uint24_buf_t  native_uint24_buf_t;
+  typedef big_uint32_buf_t  native_uint32_buf_t;
+  typedef big_uint40_buf_t  native_uint40_buf_t;
+  typedef big_uint48_buf_t  native_uint48_buf_t;
+  typedef big_uint56_buf_t  native_uint56_buf_t;
+  typedef big_uint64_buf_t  native_uint64_buf_t;
+# else
+  // unaligned native endian signed integer buffers
+  typedef little_int8_buf_t   native_int8_buf_t;
+  typedef little_int16_buf_t  native_int16_buf_t;
+  typedef little_int24_buf_t  native_int24_buf_t;
+  typedef little_int32_buf_t  native_int32_buf_t;
+  typedef little_int40_buf_t  native_int40_buf_t;
+  typedef little_int48_buf_t  native_int48_buf_t;
+  typedef little_int56_buf_t  native_int56_buf_t;
+  typedef little_int64_buf_t  native_int64_buf_t;
+
+  // unaligned native endian unsigned integer buffers
+  typedef little_uint8_buf_t   native_uint8_buf_t;
+  typedef little_uint16_buf_t  native_uint16_buf_t;
+  typedef little_uint24_buf_t  native_uint24_buf_t;
+  typedef little_uint32_buf_t  native_uint32_buf_t;
+  typedef little_uint40_buf_t  native_uint40_buf_t;
+  typedef little_uint48_buf_t  native_uint48_buf_t;
+  typedef little_uint56_buf_t  native_uint56_buf_t;
+  typedef little_uint64_buf_t  native_uint64_buf_t;
+# endif
+
+  // Stream inserter
+  template <class charT, class traits, BOOST_SCOPED_ENUM(order) Order, class T,
+    std::size_t n_bits, BOOST_SCOPED_ENUM(align) A>
+  std::basic_ostream<charT, traits>&
+    operator<<(std::basic_ostream<charT, traits>& os,
+      const endian_buffer<Order, T, n_bits, A>& x)
+  {
+    return os << x.value();
+  }
+
+  // Stream extractor 
+  template <class charT, class traits, BOOST_SCOPED_ENUM(order) Order, class T,
+    std::size_t n_bits, BOOST_SCOPED_ENUM(align) A>
+  std::basic_istream<charT, traits>&
+    operator>>(std::basic_istream<charT, traits>& is,
+      endian_buffer<Order, T, n_bits, A>& x)
+  {
+    T i;
+    if (is >> i)
+      x = i;
+    return is;
+  }
+
+//----------------------------------  end synopsis  ------------------------------------//
+
+  namespace detail
+  {
+
+    // Unrolled loops for loading and storing streams of bytes.
+
+    template <typename T, std::size_t n_bytes,
+      bool sign=boost::is_signed<T>::value >
+    struct unrolled_byte_loops
+    {
+      typedef unrolled_byte_loops<T, n_bytes - 1, sign> next;
+
+      static T load_big(const unsigned char* bytes) BOOST_NOEXCEPT
+        { return static_cast<T>(*(bytes - 1) | (next::load_big(bytes - 1) << 8)); }
+      static T load_little(const unsigned char* bytes) BOOST_NOEXCEPT
+        { return static_cast<T>(*bytes | (next::load_little(bytes + 1) << 8)); }
+
+      static void store_big(char* bytes, T value) BOOST_NOEXCEPT
+        {
+          *(bytes - 1) = static_cast<char>(value);
+          next::store_big(bytes - 1, static_cast<T>(value >> 8));
+        }
+      static void store_little(char* bytes, T value) BOOST_NOEXCEPT
+        {
+          *bytes = static_cast<char>(value);
+          next::store_little(bytes + 1, static_cast<T>(value >> 8));
+        }
+    };
+
+    template <typename T>
+    struct unrolled_byte_loops<T, 1, false>
+    {
+      static T load_big(const unsigned char* bytes) BOOST_NOEXCEPT
+        { return *(bytes - 1); }
+      static T load_little(const unsigned char* bytes) BOOST_NOEXCEPT
+        { return *bytes; }
+      static void store_big(char* bytes, T value) BOOST_NOEXCEPT
+        { *(bytes - 1) = static_cast<char>(value); }
+      static void store_little(char* bytes, T value) BOOST_NOEXCEPT
+        { *bytes = static_cast<char>(value); }
+
+    };
+
+    template <typename T>
+    struct unrolled_byte_loops<T, 1, true>
+    {
+      static T load_big(const unsigned char* bytes) BOOST_NOEXCEPT
+        { return *reinterpret_cast<const signed char*>(bytes - 1); }
+      static T load_little(const unsigned char* bytes) BOOST_NOEXCEPT
+        { return *reinterpret_cast<const signed char*>(bytes); }
+      static void store_big(char* bytes, T value)  BOOST_NOEXCEPT
+        { *(bytes - 1) = static_cast<char>(value); }
+      static void store_little(char* bytes, T value) BOOST_NOEXCEPT
+        { *bytes = static_cast<char>(value); }
+    };
+
+    template <typename T, std::size_t n_bytes>
+    inline
+    T load_big_endian(const void* bytes) BOOST_NOEXCEPT
+    {
+      return unrolled_byte_loops<T, n_bytes>::load_big
+        (static_cast<const unsigned char*>(bytes) + n_bytes);
+    }
+
+    template <typename T, std::size_t n_bytes>
+    inline
+    T load_little_endian(const void* bytes) BOOST_NOEXCEPT
+    {
+#   if defined(__x86_64__) || defined(_M_X64) || defined(__i386) || defined(_M_IX86)
+      // On x86 (which is little endian), unaligned loads are permitted
+      if (sizeof(T) == n_bytes)  // GCC 4.9, VC++ 14.0, and probably others, elide this
+                                 // test and generate code only for the applicable return
+                                 // case since sizeof(T) and n_bytes are known at compile
+                                 // time.
+      {
+        return *reinterpret_cast<T const *>(bytes);
+      }
+#   endif
+      return unrolled_byte_loops<T, n_bytes>::load_little
+        (static_cast<const unsigned char*>(bytes));
+    }
+
+    template <typename T, std::size_t n_bytes>
+    inline
+    void store_big_endian(void* bytes, T value) BOOST_NOEXCEPT
+    {
+      unrolled_byte_loops<T, n_bytes>::store_big
+        (static_cast<char*>(bytes) + n_bytes, value);
+    }
+
+    template <typename T, std::size_t n_bytes>
+    inline
+    void store_little_endian(void* bytes, T value) BOOST_NOEXCEPT
+    {
+#     if defined(__x86_64__) || defined(_M_X64) || defined(__i386) || defined(_M_IX86)
+      // On x86 (which is little endian), unaligned stores are permitted
+      if (sizeof(T) == n_bytes)  // GCC 4.9, VC++ 14.0, and probably others, elide this
+                                 // test and generate code only for the applicable return
+                                 // case since sizeof(T) and n_bytes are known at compile
+                                 // time.
+      {
+        *reinterpret_cast<T *>(bytes) = value;
+        return;
+      }
+#     endif
+      unrolled_byte_loops<T, n_bytes>::store_little
+        (static_cast<char*>(bytes), value);
+    }
+
+  } // namespace detail
+
+# ifdef BOOST_ENDIAN_LOG
+    bool endian_log(true);
+# endif
+
+//  endian_buffer class template specializations  --------------------------------------//
+
+    //  Specializations that represent unaligned bytes.
+    //  Taking an integer type as a parameter provides a nice way to pass both
+    //  the size and signedness of the desired integer and get the appropriate
+    //  corresponding integer type for the interface.
+
+    // Q: Should endian_buffer supply "value_type operator value_type() const noexcept"?
+    // A: No. The rationale for endian_buffers is to prevent high-cost hidden
+    //    conversions. If an implicit conversion operator is supplied, hidden conversions
+    //    can occur.
+
+    //  unaligned big endian_buffer specialization
+    template <typename T, std::size_t n_bits>
+    class endian_buffer< order::big, T, n_bits, align::no >
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_buffer() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        explicit endian_buffer(T val) BOOST_NOEXCEPT
+        { 
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "big, unaligned, "
+              << n_bits << "-bits, construct(" << val << ")\n";
+#       endif
+          detail::store_big_endian<T, n_bits/8>(m_value, val);
+        }
+#     endif
+        endian_buffer & operator=(T val) BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if (endian_log)
+            std::cout << "big, unaligned, " << n_bits << "-bits, assign(" << val << ")\n";
+#       endif
+          detail::store_big_endian<T, n_bits/8>(m_value, val);
+          return *this;
+        }
+        value_type value() const BOOST_NOEXCEPT
+        { 
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "big, unaligned, " << n_bits << "-bits, convert("
+              << detail::load_big_endian<T, n_bits/8>(m_value) << ")\n";
+#       endif
+          return detail::load_big_endian<T, n_bits/8>(m_value);
+        }
+        const char* data() const BOOST_NOEXCEPT  { return m_value; }
+      protected:
+        char m_value[n_bits/8];
+    };
+
+    //  unaligned little endian_buffer specialization
+    template <typename T, std::size_t n_bits>
+    class endian_buffer< order::little, T, n_bits, align::no >
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_buffer() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        explicit endian_buffer(T val) BOOST_NOEXCEPT
+        { 
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "little, unaligned, " << n_bits << "-bits, construct("
+              << val << ")\n";
+#       endif
+          detail::store_little_endian<T, n_bits/8>(m_value, val);
+        }
+#     endif
+        endian_buffer & operator=(T val) BOOST_NOEXCEPT
+          { detail::store_little_endian<T, n_bits/8>(m_value, val); return *this; }
+        value_type value() const BOOST_NOEXCEPT
+        { 
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "little, unaligned, " << n_bits << "-bits, convert("
+              << detail::load_little_endian<T, n_bits/8>(m_value) << ")\n";
+#       endif
+          return detail::load_little_endian<T, n_bits/8>(m_value);
+        }
+        const char* data() const BOOST_NOEXCEPT  { return m_value; }
+      protected:
+        char m_value[n_bits/8];
+    };
+
+  //  align::yes specializations; only n_bits == 16/32/64 supported
+
+    //  aligned big endian_buffer specialization
+    template <typename T, std::size_t n_bits>
+    class endian_buffer<order::big, T, n_bits, align::yes>
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+        BOOST_STATIC_ASSERT( sizeof(T) == n_bits/8 );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_buffer() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        explicit endian_buffer(T val) BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "big, aligned, " << n_bits
+              << "-bits, construct(" << val << ")\n";
+#       endif
+          m_value = ::boost::endian::native_to_big(val);
+        }
+
+#     endif  
+        endian_buffer& operator=(T val) BOOST_NOEXCEPT
+        {
+          m_value = ::boost::endian::native_to_big(val);
+          return *this;
+        }
+        //operator value_type() const BOOST_NOEXCEPT
+        //{                                                                       
+        //  return ::boost::endian::big_to_native(m_value);
+        //}
+        value_type value() const BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "big, aligned, " << n_bits << "-bits, convert("
+              << ::boost::endian::big_to_native(m_value) << ")\n";
+#       endif
+          return ::boost::endian::big_to_native(m_value);
+        }
+        const char* data() const BOOST_NOEXCEPT
+          {return reinterpret_cast<const char*>(&m_value);}
+      protected:
+        T m_value;
+    };
+
+    //  aligned little endian_buffer specialization
+    template <typename T, std::size_t n_bits>
+    class endian_buffer<order::little, T, n_bits, align::yes>
+    {
+        BOOST_STATIC_ASSERT( (n_bits/8)*8 == n_bits );
+        BOOST_STATIC_ASSERT( sizeof(T) == n_bits/8 );
+      public:
+        typedef T value_type;
+#     ifndef BOOST_ENDIAN_NO_CTORS
+        endian_buffer() BOOST_ENDIAN_DEFAULT_CONSTRUCT
+        explicit endian_buffer(T val) BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "little, aligned, " << n_bits
+              << "-bits, construct(" << val << ")\n";
+#       endif
+          m_value = ::boost::endian::native_to_little(val);
+        }
+
+#     endif  
+        endian_buffer& operator=(T val) BOOST_NOEXCEPT
+        {
+          m_value = ::boost::endian::native_to_little(val);
+          return *this;
+        }
+        value_type value() const BOOST_NOEXCEPT
+        {
+#       ifdef BOOST_ENDIAN_LOG
+          if ( endian_log )
+            std::cout << "little, aligned, " << n_bits << "-bits, convert("
+              << ::boost::endian::little_to_native(m_value) << ")\n";
+#       endif
+          return ::boost::endian::little_to_native(m_value);
+        }
+        const char* data() const BOOST_NOEXCEPT
+          {return reinterpret_cast<const char*>(&m_value);}
+      protected:
+        T m_value;
+    };
+
+} // namespace endian
+} // namespace boost
+
+#if defined(__BORLANDC__) || defined( __CODEGEARC__)
+# pragma pack(pop)
+#endif
+
+#if defined(_MSC_VER)  
+# pragma warning(pop)  
+#endif 
+
+#endif // BOOST_ENDIAN_BUFFERS_HPP
diff --git a/boost/endian/conversion.hpp b/boost/endian/conversion.hpp
new file mode 100644
index 0000000..1d89596
--- /dev/null
+++ b/boost/endian/conversion.hpp
@@ -0,0 +1,487 @@
+//  boost/endian/conversion.hpp  -------------------------------------------------------//
+
+//  Copyright Beman Dawes 2010, 2011, 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+#ifndef BOOST_ENDIAN_CONVERSION_HPP
+#define BOOST_ENDIAN_CONVERSION_HPP
+
+#include <boost/config.hpp>
+#include <boost/predef/detail/endian_compat.h>
+#include <boost/cstdint.hpp>
+#include <boost/endian/detail/intrinsic.hpp>
+#include <boost/core/scoped_enum.hpp>
+#include <boost/static_assert.hpp>
+#include <algorithm>
+#include <cstring>  // for memcpy
+
+//------------------------------------- synopsis ---------------------------------------//
+
+namespace boost
+{
+namespace endian
+{
+#ifndef BOOST_ENDIAN_ORDER_ENUM_DEFINED
+  BOOST_SCOPED_ENUM_START(order)
+  {
+    big, little,
+# ifdef  BOOST_BIG_ENDIAN
+      native = big
+# else
+      native = little
+# endif
+  }; BOOST_SCOPED_ENUM_END
+# define BOOST_ENDIAN_ORDER_ENUM_DEFINED
+#endif
+
+//--------------------------------------------------------------------------------------//
+//                                                                                      //
+//                             return-by-value interfaces                               //
+//                             suggested by Phil Endecott                               //
+//                                                                                      //
+//                             user-defined types (UDTs)                                //
+//                                                                                      //
+//  All return-by-value conversion function templates are required to be implemented in //
+//  terms of an unqualified call to "endian_reverse(x)", a function returning the       //
+//  value of x with endianness reversed. This provides a customization point for any    //
+//  UDT that provides a "endian_reverse" free-function meeting the requirements.        //
+//  It must be defined in the same namespace as the UDT itself so that it will be found //
+//  by argument dependent lookup (ADL).                                                 //
+//                                                                                      //
+//--------------------------------------------------------------------------------------//
+  
+  //  customization for exact-length arithmetic types. See doc/conversion.html/#FAQ
+  inline int8_t   endian_reverse(int8_t x) BOOST_NOEXCEPT;
+  inline int16_t  endian_reverse(int16_t x) BOOST_NOEXCEPT;
+  inline int32_t  endian_reverse(int32_t x) BOOST_NOEXCEPT;
+  inline int64_t  endian_reverse(int64_t x) BOOST_NOEXCEPT;
+  inline uint8_t  endian_reverse(uint8_t x) BOOST_NOEXCEPT;
+  inline uint16_t endian_reverse(uint16_t x) BOOST_NOEXCEPT;
+  inline uint32_t endian_reverse(uint32_t x) BOOST_NOEXCEPT;
+  inline uint64_t endian_reverse(uint64_t x) BOOST_NOEXCEPT;
+
+  //  reverse byte order unless native endianness is big
+  template <class EndianReversible >
+    inline EndianReversible  big_to_native(EndianReversible  x) BOOST_NOEXCEPT;
+    //  Returns: x if native endian order is big, otherwise endian_reverse(x)
+  template <class EndianReversible >
+    inline EndianReversible  native_to_big(EndianReversible  x) BOOST_NOEXCEPT;
+    //  Returns: x if native endian order is big, otherwise endian_reverse(x)
+
+  //  reverse byte order unless native endianness is little
+  template <class EndianReversible >
+    inline EndianReversible  little_to_native(EndianReversible  x) BOOST_NOEXCEPT;
+    //  Returns: x if native endian order is little, otherwise endian_reverse(x)
+  template <class EndianReversible >
+    inline EndianReversible  native_to_little(EndianReversible  x) BOOST_NOEXCEPT;
+    //  Returns: x if native endian order is little, otherwise endian_reverse(x)
+
+  //  generic conditional reverse byte order
+  template <BOOST_SCOPED_ENUM(order) From, BOOST_SCOPED_ENUM(order) To,
+    class EndianReversible>
+      inline EndianReversible  conditional_reverse(EndianReversible from) BOOST_NOEXCEPT;
+    //  Returns: If From == To have different values, from.
+    //           Otherwise endian_reverse(from).
+    //  Remarks: The From == To test, and as a consequence which form the return takes, is
+    //           is determined at compile time.
+
+  //  runtime conditional reverse byte order
+  template <class EndianReversible >
+    inline EndianReversible  conditional_reverse(EndianReversible from,
+      BOOST_SCOPED_ENUM(order) from_order, BOOST_SCOPED_ENUM(order) to_order)
+        BOOST_NOEXCEPT;
+      //  Returns: from_order == to_order ? from : endian_reverse(from).
+
+  //------------------------------------------------------------------------------------//
+
+
+  //  Q: What happended to bswap, htobe, and the other synonym functions based on names
+  //     popularized by BSD, OS X, and Linux?
+  //  A: Turned out these may be implemented as macros on some systems. Ditto POSIX names
+  //     for such functionality. Since macros would cause endless problems with functions
+  //     of the same names, and these functions are just synonyms anyhow, they have been
+  //     removed.
+
+
+  //------------------------------------------------------------------------------------//
+  //                                                                                    //
+  //                            reverse in place interfaces                             //
+  //                                                                                    //
+  //                             user-defined types (UDTs)                              //
+  //                                                                                    //
+  //  All reverse in place function templates are required to be implemented in terms   // 
+  //  of an unqualified call to "endian_reverse_inplace(x)", a function reversing       //
+  //  the endianness of x, which is a non-const reference. This provides a              //
+  //  customization point for any UDT that provides a "reverse_inplace" free-function   //
+  //  meeting the requirements. The free-function must be declared in the same          //
+  //  namespace as the UDT itself so that it will be found by argument-dependent        //
+  //   lookup (ADL).                                                                    //
+  //                                                                                    //
+  //------------------------------------------------------------------------------------//
+
+  //  reverse in place
+  template <class EndianReversible>
+    inline void endian_reverse_inplace(EndianReversible& x) BOOST_NOEXCEPT;
+    //  Effects: x = endian_reverse(x)
+
+  //  reverse in place unless native endianness is big
+  template <class EndianReversibleInplace>
+    inline void big_to_native_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT;
+    //  Effects: none if native byte-order is big, otherwise endian_reverse_inplace(x)
+  template <class EndianReversibleInplace>
+    inline void native_to_big_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT;
+    //  Effects: none if native byte-order is big, otherwise endian_reverse_inplace(x)
+
+  //  reverse in place unless native endianness is little
+  template <class EndianReversibleInplace>
+    inline void little_to_native_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT;
+    //  Effects: none if native byte-order is little, otherwise endian_reverse_inplace(x);
+  template <class EndianReversibleInplace>
+    inline void native_to_little_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT;
+    //  Effects: none if native byte-order is little, otherwise endian_reverse_inplace(x);
+
+  //  generic conditional reverse in place
+  template <BOOST_SCOPED_ENUM(order) From, BOOST_SCOPED_ENUM(order) To,
+    class EndianReversibleInplace>
+  inline void conditional_reverse_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT; 
+
+  //  runtime reverse in place
+  template <class EndianReversibleInplace>
+  inline void conditional_reverse_inplace(EndianReversibleInplace& x,
+    BOOST_SCOPED_ENUM(order) from_order,  BOOST_SCOPED_ENUM(order) to_order)
+    BOOST_NOEXCEPT;
+
+//----------------------------------- end synopsis -------------------------------------//
+
+  namespace detail
+  {
+    //  generic reverse function template implementation approach using std::reverse
+    //  suggested by Mathias Gaunard. Primary motivation for inclusion is to have an
+    //  independent implementation to test against.
+
+    template <class T>
+    inline T std_endian_reverse(T x) BOOST_NOEXCEPT
+    {
+      T tmp(x);
+      std::reverse(
+        reinterpret_cast<unsigned char*>(&tmp),
+        reinterpret_cast<unsigned char*>(&tmp) + sizeof(T));
+      return tmp;
+    }
+
+    //  conditional unaligned reverse copy, patterned after std::reverse_copy
+    template <class T>
+      inline void big_reverse_copy(T from, char* to) BOOST_NOEXCEPT;
+    template <class T>
+      inline void big_reverse_copy(const char* from, T& to) BOOST_NOEXCEPT;
+    template <class T>
+      inline void little_reverse_copy(T from, char* to) BOOST_NOEXCEPT;
+    template <class T>
+      inline void little_reverse_copy(const char* from, T& to) BOOST_NOEXCEPT;
+  }  // namespace detail
+
+//--------------------------------------------------------------------------------------//
+//                                                                                      //
+//                            return-by-value implementation                            //
+//                                                                                      //
+//    -- portable approach suggested by tymofey, with avoidance of undefined behavior   //
+//       as suggested by Giovanni Piero Deretta, with a further refinement suggested    //
+//       by Pyry Jahkola.                                                               //
+//    -- intrinsic approach suggested by reviewers, and by David Stone, who provided    //
+//       his Boost licensed macro implementation (detail/intrinsic.hpp)                 //
+//                                                                                      //
+//--------------------------------------------------------------------------------------//
+
+  inline int8_t endian_reverse(int8_t x) BOOST_NOEXCEPT
+  {
+    return x;
+  }
+                                                
+  inline int16_t endian_reverse(int16_t x) BOOST_NOEXCEPT
+  {
+# ifdef BOOST_ENDIAN_NO_INTRINSICS  
+    return (static_cast<uint16_t>(x) << 8)
+      | (static_cast<uint16_t>(x) >> 8);
+# else
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(static_cast<uint16_t>(x));
+# endif
+  }
+
+  inline int32_t endian_reverse(int32_t x) BOOST_NOEXCEPT
+  {
+# ifdef BOOST_ENDIAN_NO_INTRINSICS  
+    uint32_t step16;
+    step16 = static_cast<uint32_t>(x) << 16 | static_cast<uint32_t>(x) >> 16;
+    return
+        ((static_cast<uint32_t>(step16) << 8) & 0xff00ff00)
+      | ((static_cast<uint32_t>(step16) >> 8) & 0x00ff00ff);
+# else
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(static_cast<uint32_t>(x));
+# endif
+  }
+
+  inline int64_t endian_reverse(int64_t x) BOOST_NOEXCEPT
+  {
+# ifdef BOOST_ENDIAN_NO_INTRINSICS  
+    uint64_t step32, step16;
+    step32 = static_cast<uint64_t>(x) << 32 | static_cast<uint64_t>(x) >> 32;
+    step16 = (step32 & 0x0000FFFF0000FFFFULL) << 16
+           | (step32 & 0xFFFF0000FFFF0000ULL) >> 16;
+    return static_cast<int64_t>((step16 & 0x00FF00FF00FF00FFULL) << 8
+           | (step16 & 0xFF00FF00FF00FF00ULL) >> 8);
+# else
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_8(static_cast<uint64_t>(x));
+# endif
+  }
+  
+  inline uint8_t endian_reverse(uint8_t x) BOOST_NOEXCEPT
+  {
+    return x;
+  }
+
+  inline uint16_t endian_reverse(uint16_t x) BOOST_NOEXCEPT
+  {
+# ifdef BOOST_ENDIAN_NO_INTRINSICS  
+    return (x << 8)
+      | (x >> 8);
+# else
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(x);
+# endif
+  }
+
+  inline uint32_t endian_reverse(uint32_t x) BOOST_NOEXCEPT                           
+  {
+# ifdef BOOST_ENDIAN_NO_INTRINSICS  
+    uint32_t step16;
+    step16 = x << 16 | x >> 16;
+    return
+        ((step16 << 8) & 0xff00ff00)
+      | ((step16 >> 8) & 0x00ff00ff);
+# else
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(x);
+# endif
+  }
+
+  inline uint64_t endian_reverse(uint64_t x) BOOST_NOEXCEPT
+  {
+# ifdef BOOST_ENDIAN_NO_INTRINSICS  
+    uint64_t step32, step16;
+    step32 = x << 32 | x >> 32;
+    step16 = (step32 & 0x0000FFFF0000FFFFULL) << 16
+           | (step32 & 0xFFFF0000FFFF0000ULL) >> 16;
+    return (step16 & 0x00FF00FF00FF00FFULL) << 8
+           | (step16 & 0xFF00FF00FF00FF00ULL) >> 8;
+# else
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_8(x);
+# endif
+  }
+
+  template <class EndianReversible >
+  inline EndianReversible  big_to_native(EndianReversible  x) BOOST_NOEXCEPT
+  {
+#   ifdef BOOST_BIG_ENDIAN
+    return x;
+#   else
+    return endian_reverse(x);
+#   endif
+  }
+
+  template <class EndianReversible >
+  inline EndianReversible  native_to_big(EndianReversible  x) BOOST_NOEXCEPT
+  {
+#   ifdef BOOST_BIG_ENDIAN
+    return x;
+#   else
+    return endian_reverse(x);
+#   endif
+  }
+
+  template <class EndianReversible >
+  inline EndianReversible  little_to_native(EndianReversible  x) BOOST_NOEXCEPT
+  {
+#   ifdef BOOST_LITTLE_ENDIAN
+    return x;
+#   else
+    return endian_reverse(x);
+#   endif
+  }
+
+  template <class EndianReversible >
+  inline EndianReversible  native_to_little(EndianReversible  x) BOOST_NOEXCEPT
+  {
+#   ifdef BOOST_LITTLE_ENDIAN
+    return x;
+#   else
+    return endian_reverse(x);
+#   endif
+  }
+
+  namespace detail
+  {
+    //  Primary template and specializations to support endian_reverse().
+    //  See rationale in endian_reverse() below.
+    template <BOOST_SCOPED_ENUM(order) From, BOOST_SCOPED_ENUM(order) To,
+        class EndianReversible>
+      class value_converter ;  // primary template
+    template <class T> class value_converter <order::big, order::big, T>
+      {public: T operator()(T x) BOOST_NOEXCEPT {return x;}};
+    template <class T> class value_converter <order::little, order::little, T>
+      {public: T operator()(T x) BOOST_NOEXCEPT {return x;}};
+    template <class T> class value_converter <order::big, order::little, T>
+      {public: T operator()(T x) BOOST_NOEXCEPT {return endian_reverse(x);}};
+    template <class T> class value_converter <order::little, order::big, T>
+      {public: T operator()(T x) BOOST_NOEXCEPT {return endian_reverse(x);}};
+  }
+
+  //  generic conditional reverse
+  template <BOOST_SCOPED_ENUM(order) From, BOOST_SCOPED_ENUM(order) To,
+    class EndianReversible>
+  inline EndianReversible  conditional_reverse(EndianReversible from) BOOST_NOEXCEPT  {
+    //  work around lack of function template partial specialization by instantiating
+    //  a function object of a class that is partially specialized on the two order
+    //  template parameters, and then calling its operator().
+    detail::value_converter <From, To, EndianReversible> tmp;
+    return tmp(from);
+  }
+
+  //  runtime conditional reverse
+  template <class EndianReversible >
+  inline EndianReversible  conditional_reverse(EndianReversible  from,
+    BOOST_SCOPED_ENUM(order) from_order, BOOST_SCOPED_ENUM(order) to_order) BOOST_NOEXCEPT
+  {
+    return from_order == to_order ? from : endian_reverse(from);
+  }
+
+//--------------------------------------------------------------------------------------//
+//                           reverse-in-place implementation                            //
+//--------------------------------------------------------------------------------------//
+
+  //  reverse in place
+  template <class EndianReversible>
+  inline void endian_reverse_inplace(EndianReversible& x) BOOST_NOEXCEPT
+  {
+    x = endian_reverse(x);
+  }
+
+  template <class EndianReversibleInplace>
+#   ifdef BOOST_BIG_ENDIAN
+  inline void big_to_native_inplace(EndianReversibleInplace&) BOOST_NOEXCEPT {}
+#   else
+  inline void big_to_native_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT
+    { endian_reverse_inplace(x); }
+#   endif
+  template <class EndianReversibleInplace>
+#   ifdef BOOST_BIG_ENDIAN
+  inline void native_to_big_inplace(EndianReversibleInplace&) BOOST_NOEXCEPT {}
+#   else
+  inline void native_to_big_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT
+  {
+    endian_reverse_inplace(x);
+  }
+#   endif
+
+  template <class EndianReversibleInplace>
+#   ifdef BOOST_LITTLE_ENDIAN
+  inline void little_to_native_inplace(EndianReversibleInplace&) BOOST_NOEXCEPT {}
+#   else
+  inline void little_to_native_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT
+    { endian_reverse_inplace(x); }
+#   endif
+  template <class EndianReversibleInplace>
+#   ifdef BOOST_LITTLE_ENDIAN
+  inline void native_to_little_inplace(EndianReversibleInplace&) BOOST_NOEXCEPT {}
+#   else
+  inline void native_to_little_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT
+  {
+    endian_reverse_inplace(x);
+  }
+#   endif
+
+  namespace detail
+  {
+    //  Primary template and specializations support generic 
+    //  endian_reverse_inplace().
+    //  See rationale in endian_reverse_inplace() below.
+    template <BOOST_SCOPED_ENUM(order) From, BOOST_SCOPED_ENUM(order) To,
+        class EndianReversibleInplace>
+      class converter;  // primary template
+    template <class T> class converter<order::big, order::big, T>
+      {public: void operator()(T&) BOOST_NOEXCEPT {/*no effect*/}};
+    template <class T> class converter<order::little, order::little, T>
+      {public: void operator()(T&) BOOST_NOEXCEPT {/*no effect*/}};
+    template <class T> class converter<order::big, order::little, T>
+      {public: void operator()(T& x) BOOST_NOEXCEPT { endian_reverse_inplace(x); }};
+    template <class T> class converter<order::little, order::big, T>
+      {public: void operator()(T& x) BOOST_NOEXCEPT { endian_reverse_inplace(x); }};
+  }  // namespace detail
+
+  //  generic conditional reverse in place
+  template <BOOST_SCOPED_ENUM(order) From, BOOST_SCOPED_ENUM(order) To,
+    class EndianReversibleInplace>
+  inline void conditional_reverse_inplace(EndianReversibleInplace& x) BOOST_NOEXCEPT
+  {
+    //  work around lack of function template partial specialization by instantiating
+    //  a function object of a class that is partially specialized on the two order
+    //  template parameters, and then calling its operator().
+    detail::converter<From, To, EndianReversibleInplace> tmp;
+    tmp(x);  // call operator ()
+  }
+
+  //  runtime reverse in place
+  template <class EndianReversibleInplace>
+  inline void conditional_reverse_inplace(EndianReversibleInplace& x,
+    BOOST_SCOPED_ENUM(order) from_order,  BOOST_SCOPED_ENUM(order) to_order)
+    BOOST_NOEXCEPT
+  {
+    if (from_order != to_order)
+      endian_reverse_inplace(x);
+  }
+
+
+  namespace detail
+  {
+    template <class T>
+    inline void big_reverse_copy(T from, char* to) BOOST_NOEXCEPT
+    {
+#     ifdef BOOST_BIG_ENDIAN
+      std::memcpy(to, reinterpret_cast<const char*>(&from), sizeof(T));
+#     else
+      std::reverse_copy(reinterpret_cast<const char*>(&from),
+        reinterpret_cast<const char*>(&from) + sizeof(T), to);
+#     endif
+    }
+    template <class T>
+    inline void big_reverse_copy(const char* from, T& to) BOOST_NOEXCEPT
+    {
+#     ifdef BOOST_BIG_ENDIAN
+      std::memcpy(reinterpret_cast<char*>(&to), from, sizeof(T));
+#     else
+      std::reverse_copy(from, from + sizeof(T), reinterpret_cast<char*>(&to));
+#     endif
+    }
+    template <class T>
+    inline void little_reverse_copy(T from, char* to) BOOST_NOEXCEPT
+    {
+#     ifdef BOOST_LITTLE_ENDIAN
+      std::memcpy(to, reinterpret_cast<const char*>(&from), sizeof(T));
+#     else
+      std::reverse_copy(reinterpret_cast<const char*>(&from),
+        reinterpret_cast<const char*>(&from) + sizeof(T), to);
+#     endif
+    }
+    template <class T>
+    inline void little_reverse_copy(const char* from, T& to) BOOST_NOEXCEPT
+    {
+#     ifdef BOOST_LITTLE_ENDIAN
+      std::memcpy(reinterpret_cast<char*>(&to), from, sizeof(T));
+#     else
+      std::reverse_copy(from, from + sizeof(T), reinterpret_cast<char*>(&to));
+#     endif
+    }
+  }  // namespace detail
+}  // namespace endian
+}  // namespace boost
+
+#endif // BOOST_ENDIAN_CONVERSION_HPP
diff --git a/boost/endian/detail/config.hpp b/boost/endian/detail/config.hpp
new file mode 100644
index 0000000..8ece0a1
--- /dev/null
+++ b/boost/endian/detail/config.hpp
@@ -0,0 +1,62 @@
+//  boost/endian/detail/config.hpp  ----------------------------------------------------//
+
+//  Copyright Beman Dawes 2003, 2010
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------// 
+
+#ifndef BOOST_ENDIAN_CONFIG_HPP
+#define BOOST_ENDIAN_CONFIG_HPP
+
+// This header implements separate compilation features as described in
+// http://www.boost.org/more/separate_compilation.html
+
+#include <boost/config.hpp>
+#include <boost/system/api_config.hpp>  // for BOOST_POSIX_API or BOOST_WINDOWS_API
+
+//  throw an exception  ----------------------------------------------------------------//
+//
+//  Exceptions were originally thrown via boost::throw_exception().
+//  As throw_exception() became more complex, it caused user error reporting
+//  to be harder to interpret, since the exception reported became much more complex.
+//  The immediate fix was to throw directly, wrapped in a macro to make any later change
+//  easier.
+
+#define BOOST_ENDIAN_THROW(EX) throw EX
+
+//  enable dynamic linking -------------------------------------------------------------//
+
+#if defined(BOOST_ALL_DYN_LINK) || defined(BOOST_ENDIAN_DYN_LINK)
+# if defined(BOOST_ENDIAN_SOURCE)
+#   define BOOST_ENDIAN_DECL BOOST_SYMBOL_EXPORT
+# else 
+#   define BOOST_ENDIAN_DECL BOOST_SYMBOL_IMPORT
+# endif
+#else
+# define BOOST_ENDIAN_DECL
+#endif
+
+//  enable automatic library variant selection  ----------------------------------------// 
+
+#if !defined(BOOST_ENDIAN_SOURCE) && !defined(BOOST_ALL_NO_LIB) \
+  && !defined(BOOST_ENDIAN_NO_LIB)
+//
+// Set the name of our library, this will get undef'ed by auto_link.hpp
+// once it's done with it:
+//
+#define BOOST_LIB_NAME boost_endian
+//
+// If we're importing code from a dll, then tell auto_link.hpp about it:
+//
+#if defined(BOOST_ALL_DYN_LINK) || defined(BOOST_ENDIAN_DYN_LINK)
+#  define BOOST_DYN_LINK
+#endif
+//
+// And include the header that does the work:
+//
+#include <boost/config/auto_link.hpp>
+#endif  // auto-linking disabled
+
+#endif // BOOST_ENDIAN_CONFIG_HPP
diff --git a/boost/endian/detail/cover_operators.hpp b/boost/endian/detail/cover_operators.hpp
new file mode 100644
index 0000000..f4fd052
--- /dev/null
+++ b/boost/endian/detail/cover_operators.hpp
@@ -0,0 +1,142 @@
+//  boost/endian/detail/cover_operators.hpp ----------------------------------//
+
+//  Copyright Darin Adler 2000
+//  Copyright Beman Dawes 2008
+
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_ENDIAN_COVER_OPERATORS_HPP
+#define BOOST_ENDIAN_COVER_OPERATORS_HPP
+
+#if defined(_MSC_VER)  
+# pragma warning(push)  
+# pragma warning(disable:4365)  // conversion ... signed/unsigned mismatch
+#endif
+
+# ifndef BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+#   include <boost/operators.hpp>
+# endif
+
+#include <boost/config.hpp>
+#include <iosfwd>
+
+namespace boost
+{
+  namespace endian
+  {
+
+//--------------------------------------------------------------------------------------//
+
+//  A class that adds arithmetic operators to an arithmetic cover class
+//
+//  Uses the curiously recurring template pattern (CRTP).
+//
+//  If the class being covered has a non-explicit conversion to an integer type
+//  then a smaller number of cover operations are needed. Define the macro
+//  BOOST_ENDIAN_MINIMAL_COVER_OPERATORS to indicate this.
+//
+//  Define BOOST_NO_IO_COVER_OPERATORS if I/O cover operations are not desired.
+
+//--------------------------------------------------------------------------------------//
+
+    template <class D,   // D is the CRTP derived type, i.e. the cover class
+              class ArithmeticT>
+    class cover_operators
+#    ifndef BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+      : boost::operators<D>
+#    endif
+    {
+      // The other operations take advantage of the type conversion that's
+      // built into unary +.
+
+      // Unary operations.
+      friend ArithmeticT operator+(const D& x) BOOST_NOEXCEPT { return x; }
+#   ifndef BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+      friend ArithmeticT operator-(const D& x) BOOST_NOEXCEPT { return -+x; }
+      friend ArithmeticT operator~(const D& x) BOOST_NOEXCEPT { return ~+x; }
+      friend ArithmeticT operator!(const D& x) BOOST_NOEXCEPT { return !+x; }
+
+      // The basic ordering operations.
+      friend bool operator==(const D& x, ArithmeticT y) BOOST_NOEXCEPT { return +x == y; }
+      friend bool operator<(const D& x, ArithmeticT y) BOOST_NOEXCEPT { return +x < y; }
+#   endif
+      
+      // The basic arithmetic operations.
+      friend D& operator+=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x + y); }
+      friend D& operator-=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x - y); }
+      friend D& operator*=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x * y); }
+      friend D& operator/=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x / y); }
+      friend D& operator%=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x % y); }
+      friend D& operator&=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x & y); }
+      friend D& operator|=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x | y); }
+      friend D& operator^=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x ^ y); }
+      friend D& operator<<=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x << y); }
+      friend D& operator>>=(D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return x = static_cast<ArithmeticT>(+x >> y); }
+      
+      // A few binary arithmetic operations not covered by operators base class.
+      friend ArithmeticT operator<<(const D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return static_cast<ArithmeticT>(+x << y); }
+      friend ArithmeticT operator>>(const D& x, ArithmeticT y) BOOST_NOEXCEPT
+        { return static_cast<ArithmeticT>(+x >> y); }
+      
+      // Auto-increment and auto-decrement can be defined in terms of the
+      // arithmetic operations.
+      friend D& operator++(D& x) BOOST_NOEXCEPT { return x += 1; }
+      friend D& operator--(D& x) BOOST_NOEXCEPT { return x -= 1; }
+
+#   ifdef BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+      friend D operator++(D& x, int) BOOST_NOEXCEPT
+      { 
+        D tmp(x);
+        x += 1;
+        return tmp;
+      }
+      friend D operator--(D& x, int) BOOST_NOEXCEPT
+      { 
+        D tmp(x);
+        x -= 1;
+        return tmp;
+      }
+#   endif
+
+#   ifndef BOOST_NO_IO_COVER_OPERATORS
+
+      // Stream inserter
+      template <class charT, class traits>
+      friend std::basic_ostream<charT, traits>&
+        operator<<(std::basic_ostream<charT, traits>& os, const D& x)
+      {
+        return os << +x; 
+      }
+
+      // Stream extractor 
+      template <class charT, class traits>
+      friend std::basic_istream<charT, traits>&
+        operator>>(std::basic_istream<charT, traits>& is, D& x)
+      {
+        ArithmeticT i;
+        if (is >> i)
+          x = i;
+        return is;
+      }
+#   endif
+    };
+  } // namespace endian
+} // namespace boost
+
+#if defined(_MSC_VER)  
+# pragma warning(pop)  
+#endif 
+
+#endif // BOOST_ENDIAN_COVER_OPERATORS_HPP
diff --git a/boost/endian/detail/disable_warnings.hpp b/boost/endian/detail/disable_warnings.hpp
new file mode 100644
index 0000000..082db8a
--- /dev/null
+++ b/boost/endian/detail/disable_warnings.hpp
@@ -0,0 +1,33 @@
+//  disable_warnings.hpp  --------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2011
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+#ifdef  _MSC_VER
+
+#ifndef _SCL_SECURE_NO_WARNINGS
+# define _SCL_SECURE_NO_WARNINGS
+#endif
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+# define _CRT_SECURE_NO_WARNINGS
+#endif
+
+# pragma warning(push)
+
+// triggered by boost/detail/lightweight_test.hpp
+# pragma warning( disable : 4640 )  // ... construction of local static object is not thread-safe
+
+// triggered by Microsoft's own headers, so disable
+# pragma warning( disable : 4820 )  // padding added after data member
+# pragma warning( disable : 4548 )  // expression before comma has no effect
+# pragma warning( disable : 4668 )  // ... is not defined as a preprocessor macro
+# pragma warning( disable : 4514 )  // ... unreferenced inline function has been removed
+# pragma warning( disable : 4710 )  // ... function not inlined
+# pragma warning( disable : 4986 )  // ... exception specification does not match previous declaration
+# pragma warning( disable : 4711 )  // ... selected for automatic inline expansion
+#endif
diff --git a/boost/endian/detail/disable_warnings_pop.hpp b/boost/endian/detail/disable_warnings_pop.hpp
new file mode 100644
index 0000000..0ebc74a
--- /dev/null
+++ b/boost/endian/detail/disable_warnings_pop.hpp
@@ -0,0 +1,12 @@
+//  disable_warnings_pop.hpp  ----------------------------------------------------------//
+
+//  Copyright Beman Dawes 2011
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+#ifdef  _MSC_VER
+# pragma warning(push)
+#endif
diff --git a/boost/endian/detail/intrinsic.hpp b/boost/endian/detail/intrinsic.hpp
new file mode 100644
index 0000000..6ead681
--- /dev/null
+++ b/boost/endian/detail/intrinsic.hpp
@@ -0,0 +1,64 @@
+//  endian/detail/intrinsic.hpp  -------------------------------------------------------//
+
+//  Copyright (C) 2012 David Stone
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+#ifndef BOOST_ENDIAN_INTRINSIC_HPP
+#define BOOST_ENDIAN_INTRINSIC_HPP
+
+//  Allow user to force BOOST_ENDIAN_NO_INTRINSICS in case they aren't available for a
+//  particular platform/compiler combination. Please report such platform/compiler
+//  combinations to the Boost mailing list.
+#ifndef BOOST_ENDIAN_NO_INTRINSICS
+
+#ifndef __has_builtin         // Optional of course
+  #define __has_builtin(x) 0  // Compatibility with non-clang compilers
+#endif
+
+//  GCC and Clang recent versions provide intrinsic byte swaps via builtins
+#if (defined(__clang__) && __has_builtin(__builtin_bswap32) && __has_builtin(__builtin_bswap64)) \
+  || (defined(__GNUC__ ) && \
+  (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)))
+# define BOOST_ENDIAN_INTRINSIC_MSG "__builtin_bswap16, etc."
+// prior to 4.8, gcc did not provide __builtin_bswap16 on some platforms so we emulate it
+// see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52624
+// Clang has a similar problem, but their feature test macros make it easier to detect
+# if (defined(__clang__) && __has_builtin(__builtin_bswap16)) \
+  || (defined(__GNUC__) &&(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)))
+#   define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(x) __builtin_bswap16(x)
+# else
+#   define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(x) __builtin_bswap32((x) << 16)
+# endif
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(x) __builtin_bswap32(x)
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_8(x) __builtin_bswap64(x)
+
+//  Linux systems provide the byteswap.h header, with 
+#elif defined(__linux__)
+//  don't check for obsolete forms defined(linux) and defined(__linux) on the theory that
+//  compilers that predefine only these are so old that byteswap.h probably isn't present.
+# define BOOST_ENDIAN_INTRINSIC_MSG "byteswap.h bswap_16, etc."
+# include <byteswap.h>
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(x) bswap_16(x)
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(x) bswap_32(x)
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_8(x) bswap_64(x)
+
+#elif defined(_MSC_VER)
+//  Microsoft documents these as being compatible since Windows 95 and specificly
+//  lists runtime library support since Visual Studio 2003 (aka 7.1).
+# define BOOST_ENDIAN_INTRINSIC_MSG "cstdlib _byteswap_ushort, etc."
+# include <cstdlib>
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(x) _byteswap_ushort(x)
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(x) _byteswap_ulong(x)
+# define BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_8(x) _byteswap_uint64(x)
+#else
+# define BOOST_ENDIAN_NO_INTRINSICS
+# define BOOST_ENDIAN_INTRINSIC_MSG "no byte swap intrinsics"
+#endif
+
+#elif !defined(BOOST_ENDIAN_INTRINSIC_MSG)
+# define BOOST_ENDIAN_INTRINSIC_MSG "no byte swap intrinsics"
+#endif  // BOOST_ENDIAN_NO_INTRINSICS
+#endif  // BOOST_ENDIAN_INTRINSIC_HPP
diff --git a/boost/endian/detail/lightweight_test.hpp b/boost/endian/detail/lightweight_test.hpp
new file mode 100644
index 0000000..eba315c
--- /dev/null
+++ b/boost/endian/detail/lightweight_test.hpp
@@ -0,0 +1,223 @@
+// boost/endian/detail/lightweight_test.hpp --------------------------------------------//
+
+#ifndef BOOST_ENDIAN_LIGHTWEIGHT_TEST_HPP
+#define BOOST_ENDIAN_LIGHTWEIGHT_TEST_HPP
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER)
+# pragma once
+#endif
+
+//
+//  Copyright (c) 2002, 2009, 2014 Peter Dimov
+//  Copyright (2) Beman Dawes 2010, 2011, 2015
+//  Copyright (3) Ion Gaztanaga 2013
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+//
+
+#include <boost/assert.hpp>
+#include <boost/current_function.hpp>
+#include <boost/core/no_exceptions_support.hpp>
+#include <cstring>    // for memcmp
+#include <iostream>
+
+//  IDE's like Visual Studio perform better if output goes to std::cout or
+//  some other stream, so allow user to configure output stream:
+#ifndef BOOST_LIGHTWEIGHT_TEST_OSTREAM
+# define BOOST_LIGHTWEIGHT_TEST_OSTREAM std::cerr
+#endif
+
+namespace boost
+{
+namespace endian
+{
+namespace detail
+{
+
+struct report_errors_reminder
+{
+    bool called_report_errors_function;
+
+    report_errors_reminder() : called_report_errors_function(false) {}
+
+    ~report_errors_reminder()
+    {
+        BOOST_ASSERT(called_report_errors_function);  // verify report_errors() was called  
+    }
+};
+
+inline report_errors_reminder& report_errors_remind()
+{
+    static report_errors_reminder r;
+    return r;
+}
+
+inline int & test_errors()
+{
+    static int x = 0;
+    report_errors_remind();
+    return x;
+}
+
+inline void test_failed_impl(char const * expr, char const * file, int line, char const * function)
+{
+    BOOST_LIGHTWEIGHT_TEST_OSTREAM
+      << file << "(" << line << "): test '" << expr << "' failed in function '"
+      << function << "'" << std::endl;
+    ++test_errors();
+}
+
+inline void error_impl(char const * msg, char const * file, int line, char const * function)
+{
+    BOOST_LIGHTWEIGHT_TEST_OSTREAM
+      << file << "(" << line << "): " << msg << " in function '"
+      << function << "'" << std::endl;
+    ++test_errors();
+}
+
+inline void throw_failed_impl(char const * excep, char const * file, int line, char const * function)
+{
+   BOOST_LIGHTWEIGHT_TEST_OSTREAM
+    << file << "(" << line << "): Exception '" << excep << "' not thrown in function '"
+    << function << "'" << std::endl;
+   ++test_errors();
+}
+
+template<class T, class U> inline void test_eq_impl( char const * expr1, char const * expr2,
+  char const * file, int line, char const * function, T const & t, U const & u )
+{
+    if( t == u )
+    {
+        report_errors_remind();
+    }
+    else
+    {
+        BOOST_LIGHTWEIGHT_TEST_OSTREAM
+            << file << "(" << line << "): test '" << expr1 << " == " << expr2
+            << "' failed in function '" << function << "': "
+            << "'" << t << "' != '" << u << "'" << std::endl;
+        ++test_errors();
+    }
+}
+
+template<class T, class U> inline void test_ne_impl( char const * expr1, char const * expr2,
+  char const * file, int line, char const * function, T const & t, U const & u )
+{
+    if( t != u )
+    {
+        report_errors_remind();
+    }
+    else
+    {
+        BOOST_LIGHTWEIGHT_TEST_OSTREAM
+            << file << "(" << line << "): test '" << expr1 << " != " << expr2
+            << "' failed in function '" << function << "': "
+            << "'" << t << "' == '" << u << "'" << std::endl;
+        ++test_errors();
+    }
+}
+
+template <class T>
+std::string to_hex(const T& x)
+{
+  const char hex[] = { '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };
+  std::string tmp;
+  const unsigned char* p = reinterpret_cast<const unsigned char*>(&x);
+  const unsigned char* e = p + sizeof(T);
+
+  for (; p < e; ++p)
+  {
+    tmp += hex[*p >> 4];    // high-order nibble
+    tmp += hex[*p & 0x0f];  // low-order nibble
+  }
+  return tmp;
+}
+
+template<class T, class U> inline bool test_memcmp_eq_impl(char const * expr1,
+  char const * expr2, char const * file, int line, char const * function, T const & t,
+  U const & u)
+{
+  BOOST_ASSERT(sizeof(T) == sizeof(U));
+  if (sizeof(T) == sizeof(U)
+    && std::memcmp(&t, &u, sizeof(T)) == 0)
+  {
+    report_errors_remind();
+    return true;
+  }
+  else
+  {
+    BOOST_LIGHTWEIGHT_TEST_OSTREAM
+      << file << "(" << line << "): test 'std::memcmp(" << expr1 << ", " << expr2
+      << ") == 0' fails in function '" << function << "': "
+      << " with values '" << to_hex(t) << "' and '" << to_hex(u) << "'" << std::endl;
+    ++test_errors();
+    return false;
+  }
+}
+
+} // namespace detail
+
+inline int report_errors()
+{
+    boost::endian::detail::report_errors_remind().called_report_errors_function = true;
+
+    int errors = boost::endian::detail::test_errors();
+
+    if( errors == 0 )
+    {
+        BOOST_LIGHTWEIGHT_TEST_OSTREAM
+          << "No errors detected." << std::endl;
+        return 0;
+    }
+    else
+    {
+        BOOST_LIGHTWEIGHT_TEST_OSTREAM
+          << errors << " error" << (errors == 1? "": "s") << " detected." << std::endl;
+        return 1;
+    }
+}
+
+} // namespace endian
+} // namespace boost
+
+//////////////////////////////////////////////////////////////////////////////////////////
+//  TODO: Should all test macros return bool?  See BOOST_TEST_MEM_EQ usage in fp_exaustive_test,cpp
+//////////////////////////////////////////////////////////////////////////////////////////
+
+
+#define BOOST_TEST(expr) \
+  ((expr)? (void)0: ::boost::endian::detail::test_failed_impl(#expr, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION))
+
+#define BOOST_ERROR(msg) \
+  ( ::boost::endian::detail::error_impl(msg, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION) )
+
+#define BOOST_TEST_EQ(expr1,expr2) \
+  ( ::boost::endian::detail::test_eq_impl(#expr1, #expr2, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION, expr1, expr2) )
+#define BOOST_TEST_NE(expr1,expr2) \
+  ( ::boost::endian::detail::test_ne_impl(#expr1, #expr2, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION, expr1, expr2) )
+
+#define BOOST_TEST_MEM_EQ(expr1,expr2) \
+  (::boost::endian::detail::test_memcmp_eq_impl(#expr1, #expr2, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION, expr1, expr2))
+
+#ifndef BOOST_NO_EXCEPTIONS
+   #define BOOST_TEST_THROWS( EXPR, EXCEP )                    \
+      try {                                                    \
+         EXPR;                                                 \
+         ::boost::detail::throw_failed_impl                    \
+         (#EXCEP, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION); \
+      }                                                        \
+      catch(EXCEP const&) {                                    \
+      }                                                        \
+      catch(...) {                                             \
+         ::boost::detail::throw_failed_impl                    \
+         (#EXCEP, __FILE__, __LINE__, BOOST_CURRENT_FUNCTION); \
+      }                                                        \
+   //
+#else
+   #define BOOST_TEST_THROWS( EXPR, EXCEP )
+#endif
+
+#endif // #ifndef BOOST_ENDIAN_LIGHTWEIGHT_TEST_HPP
diff --git a/boost/endian/endian.hpp b/boost/endian/endian.hpp
new file mode 100644
index 0000000..6c610c4
--- /dev/null
+++ b/boost/endian/endian.hpp
@@ -0,0 +1,19 @@
+//  boost/endian/endian.hpp  -----------------------------------------------------------//
+
+//  Copyright Beman Dawes 2015
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+#ifndef BOOST_ENDIAN_ENDIAN_HPP
+#define BOOST_ENDIAN_ENDIAN_HPP
+
+#ifndef BOOST_ENDIAN_DEPRECATED_NAMES
+# error "<boost/endian/endian.hpp> is deprecated. Define BOOST_ENDIAN_DEPRECATED_NAMES to use."
+#endif
+
+#include <boost/endian/arithmetic.hpp>
+
+#endif  //BOOST_ENDIAN_ENDIAN_HPP
diff --git a/boost/endian/std_pair.hpp b/boost/endian/std_pair.hpp
new file mode 100644
index 0000000..8da74b4
--- /dev/null
+++ b/boost/endian/std_pair.hpp
@@ -0,0 +1,38 @@
+//  boost/endian/std_pair.hpp  ---------------------------------------------------------//
+
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+#ifndef BOOST_ENDIAN_STD_PAIR_HPP
+#define BOOST_ENDIAN_STD_PAIR_HPP
+
+#include <boost/endian/conversion.hpp>
+#include <utility>
+
+namespace boost
+{
+namespace endian
+{
+  template <class ReversibleValueT, class ReversibleValueU>
+  std::pair<ReversibleValueT, ReversibleValueU>
+    reverse_value(std::pair<ReversibleValueT, ReversibleValueU> x)
+  {
+    return std::pair<ReversibleValueT, ReversibleValueU>(reverse_value(x.first),
+      reverse_value(x.second));
+  }
+
+  template <class ReversibleT, class ReversibleU>
+  void reverse(std::pair<ReversibleT, ReversibleU>& x)
+  {
+    reverse(x.first);
+    reverse(x.second);
+  }
+
+}
+}
+
+#endif  // BOOST_ENDIAN_STD_PAIR_HPP
diff --git a/libs/endian/README b/libs/endian/README
new file mode 100644
index 0000000..2039ba9
--- /dev/null
+++ b/libs/endian/README
@@ -0,0 +1,29 @@
+Boost Endian library
+
+The Endian library is included in Boost release 1.58.0 and later.
+
+See http://boostorg.github.io/endian to browse the documentation without having to
+download the library or install Boost.
+
+To experiment with the Endian library, various other boost libraries must be
+available. So you need to install Boost or clone a current version of boostorg/boost
+if you have not already done so.
+
+Boost.Endian is a header-only library, so there is no need to run a build
+for it, although you may need to do a "b2 headers".
+
+If your clone of boost is already in place, please remember to:
+
+  cd boost
+  git pull
+  git submodule update --init
+  git submodule update
+  ./b2 headers
+  
+On Windows, "./" is unnecessary.  
+
+---------------------------
+Copyright Beman Dawes, 2013
+
+Distributed under the Boost Software License, Version 1.0.
+http://www.boost.org/LICENSE_1_0.txt 
\ No newline at end of file
diff --git a/libs/endian/benchmark/Jamfile.v2 b/libs/endian/benchmark/Jamfile.v2
new file mode 100644
index 0000000..f61061a
--- /dev/null
+++ b/libs/endian/benchmark/Jamfile.v2
@@ -0,0 +1,25 @@
+# Build and install benchmark programs
+ 
+# Copyright Beman Dawes 2013
+# Distributed under the Boost Software License, Version 1.0.
+# See www.boost.org/LICENSE_1_0.txt
+
+project 
+    : source-location ../test    : requirements
+      <toolset>msvc:<asynch-exceptions>on
+      <library>/boost/timer//boost_timer
+    ;
+
+SOURCES = speed_test speed_test_functions ;
+    
+exe "speed_test"
+       : $(SOURCES).cpp 
+       : <toolset>gcc:<cxxflags>-march=native 
+       ;
+
+exe "loop_time_test"  
+       : loop_time_test.cpp 
+       : <toolset>gcc:<cxxflags>-march=native 
+       ;
+
+install bin : speed_test loop_time_test ;
diff --git a/libs/endian/benchmark/test.bat b/libs/endian/benchmark/test.bat
new file mode 100644
index 0000000..a8056d8
--- /dev/null
+++ b/libs/endian/benchmark/test.bat
@@ -0,0 +1,12 @@
+b2 -a toolset=msvc-14.0 variant=release link=static address-model=64
+bin\loop_time_test 1000 >msvc-loop-time.html
+msvc-loop-time.html
+
+echo The GCC static build does not work on Windows, probably because of a bjam/b2 bug
+b2 -a toolset=gcc-c++11 variant=release link=static address-model=64
+bin\loop_time_test 1000 >gcc-loop-time.html
+gcc-loop-time.html
+
+rem Copyright Beman Dawes 2015
+rem Distributed under the Boost Software License, Version 1.0.
+rem See www.boost.org/LICENSE_1_0.txt
diff --git a/libs/endian/doc/arithmetic.html b/libs/endian/doc/arithmetic.html
new file mode 100644
index 0000000..1066d14
--- /dev/null
+++ b/libs/endian/doc/arithmetic.html
@@ -0,0 +1,643 @@
+<html>
+
+<head>
+<meta http-equiv="Content-Language" content="en-us">
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>Endian Arithmetic Types</title>
+<link href="styles.css" rel="stylesheet">
+</style>
+</head>
+
+<body>
+
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
+  <tr>
+    <td>
+<a href="../../../index.html">
+<img src="../../../boost.png" alt="Boost logo" align="middle" border="0" width="277" height="86"></a></td>
+    <td align="middle">
+    <b>
+    <font size="6">Endian Arithmetic Types</font> </b>
+    </td>
+  </tr>
+</table>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
+  <tr>
+    <td><b>
+    <a href="index.html">Endian Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="conversion.html">Conversion Functions</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="arithmetic.html">Arithmetic Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="buffers.html">Buffer Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="choosing_approach.html">Choosing Approach</a></b></td>
+  </tr>
+</table>
+
+<p></p>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
+  <tr>
+    <td width="100%" bgcolor="#D7EEFF" align="center">
+      <i><b>Contents</b></i></td>
+  </tr>
+  <tr>
+    <td width="100%" bgcolor="#E8F5FF">
+      <a href="#Introduction">Introduction</a><br>
+      <a href="#Example">Example</a><br>
+      <a href="#Limitations">Limitations</a><br>
+      <a href="#Feature-set">Feature set</a><br>
+      <a href="#Types">Enums and typedefs</a><br>
+      <a href="#Class_template_endian">Class template <code>endian</code></a><br>
+      &nbsp;&nbsp;&nbsp;
+      <a href="#Synopsis">Synopsis</a><br>
+      &nbsp;&nbsp;&nbsp; <a href="#Members">Members</a><br>
+&nbsp;&nbsp;&nbsp; <a href="#Stream-inserter">Stream inserter</a><br>
+&nbsp;&nbsp;&nbsp; <a href="#Stream-extractor">Stream extractor</a><br>
+      <a href="#FAQ">FAQ</a><br>
+      <a href="#Design">Design</a><br>
+      <a href="#Experience">Experience</a><br>
+      <a href="#Motivating-use-cases">Motivating use cases</a><br>
+      <a href="#C++0x">C++11</a><br>
+      <a href="#Compilation">Compilation</a><br>
+      <a href="#Acknowledgements">Acknowledgements</a>
+    </td>
+  </tr>
+  </table>
+<h2><a name="Introduction">Introduction</a></h2>
+<p>Header <a href="arithmetic.html">boost/endian/arithmetic.hpp</a> 
+provides integer binary types with control over 
+byte order, value type, size, and alignment. Typedefs provide easy-to-use names 
+for common configurations.</p>
+<p>These types provide portable byte-holders for integer data, independent of 
+particular computer architectures. Use cases almost always involve I/O, either via files or 
+network connections. Although data portability is the primary motivation, these 
+integer byte-holders may 
+also be used to reduce memory use, file size, or network activity since they 
+provide binary integer sizes not otherwise available.</p>
+<p>Such integer byte-holder types are traditionally called <b><i>
+endian</i></b> types. See the
+<a href="http://en.wikipedia.org/wiki/Endian" name="endianness">Wikipedia</a> for 
+a full 
+exploration of <b><i>endianness</i></b>, including definitions of <i><b>big 
+endian</b></i> and <i><b>little endian</b></i>.</p>
+<p>Boost endian integers provide the same full set of C++ assignment, 
+arithmetic, and relational operators&nbsp;as C++ standard integral types, with 
+the standard semantics.</p>
+<p>Unary arithmetic operators are <b> <code><font face="Courier New">+</font></code></b>,
+<b> <code>-</code></b>, <b> <code>~</code></b>, <b>
+<code>!</code></b>, plus both prefix and postfix <b> <code>--</code></b> and <b> <code>++</code></b>. Binary 
+arithmetic operators are <b> <code>+</code></b>, <b> <code>+=</code></b>, <b> <code>-</code></b>,
+<b> <code>
+-=</code></b>, <b> <code>*</code></b>, <b> <code>*=</code></b>, <b> <code>/</code></b>,
+<b> <code>/=</code></b>, <b> <code>&amp;</code></b>, <b> <code>&amp;=</code></b>,
+<b> <code>|</code></b>, <b> <code>|=</code></b>, <b>
+<code>^</code></b>, <b> <code>^=</code></b>, <b> <code>&lt;&lt;</code></b>, <b> <code>&lt;&lt;=</code></b>, <code>
+<b>&gt;&gt;</b></code>, and <b>
+<code>&gt;&gt;=</code></b>. Binary relational operators are <b> <code>==</code></b>,
+<b> <code>!=</code></b>, <b>
+<code>&lt;</code></b>, <b> <code>&lt;=</code></b>, <b> <code>&gt;</code></b>, 
+and <b> <code>&gt;=</code></b>.</p>
+<p>Implicit conversion to the underlying value type is provided. An implicit 
+constructor converting from the underlying value type is provided. </p>
+<h2><a name="Example">Example</a></h2>
+<p>The <a href="../example/endian_example.cpp">endian_example.cpp</a> program writes a 
+binary file containing four-byte, big-endian and little-endian integers:</p>
+<blockquote>
+  <pre>#include &lt;iostream&gt;
+#include &lt;cstdio&gt;
+#include &lt;boost/endian/arithmetic.hpp&gt;
+#include &lt;boost/static_assert.hpp&gt;
+
+using namespace boost::endian;
+
+namespace 
+{
+  //  This is an extract from a very widely used GIS file format.
+  //  Why the designer decided to mix big and little endians in
+  //  the same file is not known. But this is a real-world format
+  //  and users wishing to write low level code manipulating these
+  //  files have to deal with the mixed endianness.
+
+  struct header
+  {
+    big_int32_t     file_code;
+    big_int32_t     file_length;
+    little_int32_t  version;
+    little_int32_t  shape_type;
+  };
+
+  const char* filename = &quot;test.dat&quot;;
+}
+
+int main(int, char* [])
+{
+  header h;
+
+  BOOST_STATIC_ASSERT(sizeof(h) == 16U);  // reality check
+  
+  h.file_code   = 0x01020304;
+  h.file_length = sizeof(header);
+  h.version     = 1;
+  h.shape_type  = 0x01020304;
+
+  //  Low-level I/O such as POSIX read/write or &lt;cstdio&gt;
+  //  fread/fwrite is sometimes used for binary file operations
+  //  when ultimate efficiency is important. Such I/O is often
+  //  performed in some C++ wrapper class, but to drive home the
+  //  point that endian integers are often used in fairly
+  //  low-level code that does bulk I/O operations, &lt;cstdio&gt;
+  //  fopen/fwrite is used for I/O in this example.
+
+  std::FILE* fi = std::fopen(filename, &quot;wb&quot;);  // MUST BE BINARY
+  
+  if (!fi)
+  {
+    std::cout &lt;&lt; &quot;could not open &quot; &lt;&lt; filename &lt;&lt; '\n';
+    return 1;
+  }
+
+  if (std::fwrite(&amp;h, sizeof(header), 1, fi)!= 1)
+  {
+    std::cout &lt;&lt; &quot;write failure for &quot; &lt;&lt; filename &lt;&lt; '\n';
+    return 1;
+  }
+
+  std::fclose(fi);
+
+  std::cout &lt;&lt; &quot;created file &quot; &lt;&lt; filename &lt;&lt; '\n';
+
+  return 0;
+}
+</pre>
+</blockquote>
+<p>After compiling and executing <a href="../example/endian_example.cpp">endian_example.cpp</a>, 
+a hex dump of <code>test.dat</code> shows:</p>
+<blockquote>
+  <pre>01020304 00000010 01000000 04030201</pre>
+</blockquote>
+<p>Notice that the first two 32-bit integers are big endian while the second two 
+are little endian, even though the machine this was compiled and run on was 
+little endian.</p>
+<h2><a name="Limitations">Limitations</a></h2>
+<p>Requires <code>&lt;climits&gt;</code> <code>CHAR_BIT == 8</code>. If <code>CHAR_BIT</code> 
+is some other value, compilation will result in an <code>#error</code>. This 
+restriction is in place because the design, implementation, testing, and 
+documentation has only considered issues related to 8-bit bytes, and there have 
+been no real-world use cases presented for other sizes.</p>
+<p>In C++03, <code>endian_arithmetic</code> does not meet the requirements for POD types 
+because it has constructors, private data members, and a base class. This means 
+that common use cases are relying on unspecified behavior in that the C++ 
+Standard does not guarantee memory layout for non-POD types. This has not been a 
+problem in practice since all known C++ compilers  lay out memory as if <code>
+endian</code> were a POD type. In C++11, it is possible to specify the 
+default constructor as trivial, and private data members and base classes  no longer disqualify a type from being a POD 
+type. Thus under C++11, <code>endian_arithmetic</code> 
+will no longer be relying on unspecified behavior.</p>
+<h2><a name="Feature-set">Feature set</a></h2>
+<ul>
+  <li>Big endian| little endian | native endian byte ordering.</li>
+  <li>Signed | unsigned</li>
+  <li>Unaligned | aligned</li>
+  <li>1-8 byte (unaligned) | 1, 2, 4, 8 byte (aligned)</li>
+  <li>Choice of  value type</li>
+</ul>
+<h2>Enums and t<a name="Types">ypedefs</a></h2>
+<p>Two scoped enums are provided:</p>
+<blockquote>
+  <pre>enum class order {big, little, native};
+
+enum class align {no, yes}; </pre>
+</blockquote>
+<p>One class template is provided:</p>
+<blockquote>
+  <pre>template &lt;order Order, typename T, std::size_t n_bits,
+  align Align = align::no&gt;
+class endian_arithmetic;
+</pre>
+</blockquote>
+<p>Typedefs, such as <code>big_int32_t</code>, provide convenient naming 
+conventions for common use cases:</p>
+<blockquote>
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="49%">
+  <tr>
+    <td width="18%" align="center"><b><i>Name</i></b></td>
+    <td width="49%" align="center"><b><i>Alignment</i></b></td>
+    <td width="10%" align="center"><b><i>Endianness</i></b></td>
+    <td width="10%" align="center"><b><i>Sign</i></b></td>
+    <td width="15%" align="center"><b><i>Sizes in bits (n)</i></b></td>
+  </tr>
+  <tr>
+    <td width="18%"><code>big_int</code><b><i>n</i></b><code>_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>big</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>big_uint</code><i><b>n</b></i><code>_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>big</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>little_int</code><i><b>n</b></i><code>_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>little</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>little_uint</code><i><b>n</b></i><code>_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>little</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>native_int</code><i><b>n</b></i><code>_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>native</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>native_uint</code><i><b>n</b></i><code>_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>native</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>big_int</code><i><b>n</b></i><code>_at</code></td>
+    <td width="49%" align="center"><code>yes</code></td>
+    <td width="10%" align="center"><code>big</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,32,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>big_uint</code><i><b>n</b></i><code>_at</code></td>
+    <td width="49%" align="center"><code>yes</code></td>
+    <td width="10%" align="center"><code>big</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,32,64</td>
+  </tr>
+  <tr>
+    <td width="18%" dir="ltr"><code>little_int</code><i><b>n</b></i><code>_at</code></td>
+    <td width="49%" align="center" dir="ltr"><code>yes</code></td>
+    <td width="10%" align="center" dir="ltr"><code>little</code></td>
+    <td width="10%" align="center" dir="ltr">signed</td>
+    <td width="15%" dir="ltr">8,16,32,64</td>
+  </tr>
+  <tr>
+    <td width="18%" dir="ltr"><code>little_uint</code><i><b>n</b></i><code>_at</code></td>
+    <td width="49%" align="center" dir="ltr"><code>yes</code></td>
+    <td width="10%" align="center" dir="ltr"><code>little</code></td>
+    <td width="10%" align="center" dir="ltr">unsigned</td>
+    <td width="15%" dir="ltr">8,16,32,64</td>
+  </tr>
+   </table>
+</blockquote>
+<p>The unaligned types do not cause compilers to insert padding bytes in classes 
+and structs. This is an important characteristic that can be exploited to minimize wasted space in 
+memory, files, and network transmissions. </p>
+<p><font color="#FF0000"><b><i><span style="background-color: #FFFFFF">Warning:</span></i></b></font><span style="background-color: #FFFFFF"> 
+Code that uses a</span>ligned types is possibly non-portable because alignment 
+requirements vary between hardware architectures and because alignment may be 
+affected by compiler switches or pragmas. For example, alignment of an 64-bit 
+integer may be to a 32-bit boundary on a 32-bit machine. Furthermore, aligned types 
+are only available on architectures with 8, 16, 32, and 64-bit integer types.</p>
+<p><i><b>Recommendation:</b></i> Prefer unaligned arithmetic types.</p>
+<p><i><b>Recommendation:</b></i> Protect yourself against alignment ills. For 
+example:</p>
+<blockquote>
+  <pre>static_assert(sizeof(containing_struct) == 12, &quot;sizeof(containing_struct) is wrong&quot;); </pre>
+</blockquote>
+<p><b><i>Note:</i></b> <b><i>Note:</i></b> One-byte arithmetic types 
+have identical layout on all platforms, so they never actually reverse endianness. They are provided to enable generic code, and 
+to improve code readability and searchability.</p>
+<h2><a name="Class_template_endian">Class template <code>endian</code></a><code>_arithmetic</code></h2>
+<p>An endian is an integer byte-holder with user-specified <a href="#endianness">
+endianness</a>, value type, size, and <a href="#alignment">alignment</a>. The 
+usual operations on integers are supplied.</p>
+<h3><a name="Synopsis">Synopsis</a></h3>
+<pre>namespace boost
+{
+  namespace endian
+  {
+    //  C++11 features emulated if not available
+   
+    enum class <a name="order">order</a>
+    {
+      big,                             // big-endian
+      little,                          // little-endian
+      native = <b><i>implementation-defined</i></b>  // same as order::big or order::little<b><i>
+    </i></b>};
+
+    enum class <a name="alignment">align</a> {no, yes};            
+
+    template &lt;order Order, class T, std::size_t n_bits,
+      align Align = align::no&gt;
+    class endian_arithmetic
+      : public endian_buffer&lt;Order, T, n_bits, Align&gt;
+    {
+    public:
+      typedef T value_type;
+
+      // if BOOST_ENDIAN_FORCE_PODNESS is defined &amp;&amp; C++11 PODs are not
+      // available then these two constructors will not be present
+      <a href="#endian">endian_arithmetic</a>() noexcept = default;
+      <a href="#explicit-endian">endian_arithmetic</a>(T v) noexcept;
+
+      endian_arithmetic&amp; <a href="#operator-eq">operator=</a>(T v) noexcept;
+      <a href="#operator-T">operator value_type</a>() const noexcept;
+      value_type value() const noexcept; // for exposition; see endian_buffer
+      const char* <a href="#data">data</a>() const noexcept; // for exposition; see endian_buffer
+
+      // arithmetic operations
+      //   note that additional operations are provided by the value_type 
+      value_type operator+(const endian&amp; x) noexcept;
+      endian&amp; operator+=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator-=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator*=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator/=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator%=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator&amp;=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator|=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator^=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator&lt;&lt;=(endian&amp; x, value_type y) noexcept;
+      endian&amp; operator&gt;&gt;=(endian&amp; x, value_type y noexcept;
+      value_type operator&lt;&lt;(const endian&amp; x, value_type y) noexcept;
+      value_type operator&gt;&gt;(const endian&amp; x, value_type y) noexcept;
+      endian&amp; operator++(endian&amp; x) noexcept;
+      endian&amp; operator--(endian&amp; x) noexcept;
+      endian operator++(endian&amp; x, int) noexcept;
+      endian operator--(endian&amp; x, int) noexcept;
+
+      // Stream inserter
+      template &lt;class charT, class traits&gt;
+      friend std::basic_ostream&lt;charT, traits&gt;&amp;
+        operator&lt;&lt;(std::basic_ostream&lt;charT, traits&gt;&amp; os, const T&amp; x);
+
+      // Stream extractor 
+      template &lt;class charT, class traits&gt;
+      friend std::basic_istream&lt;charT, traits&gt;&amp;
+        operator&gt;&gt;(std::basic_istream&lt;charT, traits&gt;&amp; is, T&amp; x);
+    };
+
+    // typedefs  
+
+    // unaligned big endian signed integer types
+    typedef endian&lt;order::big, int_least8_t, 8&gt;        big_int8_t;
+    typedef endian&lt;order::big, int_least16_t, 16&gt;      big_int16_t;
+    typedef endian&lt;order::big, int_least32_t, 24&gt;      big_int24_t;
+    typedef endian&lt;order::big, int_least32_t, 32&gt;      big_int32_t;
+    typedef endian&lt;order::big, int_least64_t, 40&gt;      big_int40_t;
+    typedef endian&lt;order::big, int_least64_t, 48&gt;      big_int48_t;
+    typedef endian&lt;order::big, int_least64_t, 56&gt;      big_int56_t;
+    typedef endian&lt;order::big, int_least64_t, 64&gt;      big_int64_t;
+  
+    // unaligned big endian unsigned integer types
+    typedef endian&lt;order::big, uint_least8_t, 8&gt;       big_uint8_t;
+    typedef endian&lt;order::big, uint_least16_t, 16&gt;     big_uint16_t;
+    typedef endian&lt;order::big, uint_least32_t, 24&gt;     big_uint24_t;
+    typedef endian&lt;order::big, uint_least32_t, 32&gt;     big_uint32_t;
+    typedef endian&lt;order::big, uint_least64_t, 40&gt;     big_uint40_t;
+    typedef endian&lt;order::big, uint_least64_t, 48&gt;     big_uint48_t;
+    typedef endian&lt;order::big, uint_least64_t, 56&gt;     big_uint56_t;
+    typedef endian&lt;order::big, uint_least64_t, 64&gt;     big_uint64_t;
+
+    // unaligned little endian signed integer types
+    typedef endian&lt;order::little, int_least8_t, 8&gt;     little_int8_t;
+    typedef endian&lt;order::little, int_least16_t, 16&gt;   little_int16_t;
+    typedef endian&lt;order::little, int_least32_t, 24&gt;   little_int24_t;
+    typedef endian&lt;order::little, int_least32_t, 32&gt;   little_int32_t;
+    typedef endian&lt;order::little, int_least64_t, 40&gt;   little_int40_t;
+    typedef endian&lt;order::little, int_least64_t, 48&gt;   little_int48_t;
+    typedef endian&lt;order::little, int_least64_t, 56&gt;   little_int56_t;
+    typedef endian&lt;order::little, int_least64_t, 64&gt;   little_int64_t;
+  
+    // unaligned little endian unsigned integer types
+    typedef endian&lt;order::little, uint_least8_t, 8&gt;    little_uint8_t;
+    typedef endian&lt;order::little, uint_least16_t, 16&gt;  little_uint16_t;
+    typedef endian&lt;order::little, uint_least32_t, 24&gt;  little_uint24_t;
+    typedef endian&lt;order::little, uint_least32_t, 32&gt;  little_uint32_t;
+    typedef endian&lt;order::little, uint_least64_t, 40&gt;  little_uint40_t;
+    typedef endian&lt;order::little, uint_least64_t, 48&gt;  little_uint48_t;
+    typedef endian&lt;order::little, uint_least64_t, 56&gt;  little_uint56_t;
+    typedef endian&lt;order::little, uint_least64_t, 64&gt;  little_uint64_t;
+
+    // unaligned native endian signed integer types
+    typedef <b><i>implementation-defined</i></b>_int8_t   native_int8_t;
+    typedef <b><i>implementation-defined</i></b>_int16_t  native_int16_t;
+    typedef <b><i>implementation-defined</i></b>_int24_t  native_int24_t;
+    typedef <b><i>implementation-defined</i></b>_int32_t  native_int32_t;
+    typedef <b><i>implementation-defined</i></b>_int40_t  native_int40_t;
+    typedef <b><i>implementation-defined</i></b>_int48_t  native_int48_t;
+    typedef <b><i>implementation-defined</i></b>_int56_t  native_int56_t;
+    typedef <b><i>implementation-defined</i></b>_int64_t  native_int64_t;
+
+    // unaligned native endian unsigned integer types
+    typedef <b><i>implementation-defined</i></b>_uint8_t   native_uint8_t;
+    typedef <b><i>implementation-defined</i></b>_uint16_t  native_uint16_t;
+    typedef <b><i>implementation-defined</i></b>_uint24_t  native_uint24_t;
+    typedef <b><i>implementation-defined</i></b>_uint32_t  native_uint32_t;
+    typedef <b><i>implementation-defined</i></b>_uint40_t  native_uint40_t;
+    typedef <b><i>implementation-defined</i></b>_uint48_t  native_uint48_t;
+    typedef <b><i>implementation-defined</i></b>_uint56_t  native_uint56_t;
+    typedef <b><i>implementation-defined</i></b>_uint64_t  native_uint64_t;
+    
+    // aligned big endian signed integer types
+    typedef endian&lt;order::big, int8_t, 8, align::yes&gt;       big_int8_at;
+    typedef endian&lt;order::big, int16_t, 16, align::yes&gt;     big_int16_at;
+    typedef endian&lt;order::big, int32_t, 32, align::yes&gt;     big_int32_at;
+    typedef endian&lt;order::big, int64_t, 64, align::yes&gt;     big_int64_at;
+
+    // aligned big endian unsigned integer types
+    typedef endian&lt;order::big, uint8_t, 8, align::yes&gt;      big_uint8_at;
+    typedef endian&lt;order::big, uint16_t, 16, align::yes&gt;    big_uint16_at;
+    typedef endian&lt;order::big, uint32_t, 32, align::yes&gt;    big_uint32_at;
+    typedef endian&lt;order::big, uint64_t, 64, align::yes&gt;    big_uint64_at;
+
+    // aligned little endian signed integer types
+    typedef endian&lt;order::little, int8_t, 8, align::yes&gt;    little_int8_at;
+    typedef endian&lt;order::little, int16_t, 16, align::yes&gt;  little_int16_at;
+    typedef endian&lt;order::little, int32_t, 32, align::yes&gt;  little_int32_at;
+    typedef endian&lt;order::little, int64_t, 64, align::yes&gt;  little_int64_at;
+
+    // aligned little endian unsigned integer types
+    typedef endian&lt;order::little, uint8_t, 8, align::yes&gt;   little_uint8_at;
+    typedef endian&lt;order::little, uint16_t, 16, align::yes&gt; little_uint16_at;
+    typedef endian&lt;order::little, uint32_t, 32, align::yes&gt; little_uint32_at;
+    typedef endian&lt;order::little, uint64_t, 64, align::yes&gt; little_uint64_at;
+
+    // aligned native endian typedefs are not provided because
+    // &lt;cstdint&gt; types are superior for that use case
+  
+  } // namespace endian
+} // namespace boost</pre>
+<p>The <i><b><code>implementation-defined</code></b></i> text above is either
+<code>big</code> or <code>little</code> according to the endianness of the 
+platform.</p>
+<h3><a name="Members">Members</a></h3>
+<div dir="ltr">
+  <pre><code><a name="endian">endian</a>() = default;  // C++03: endian(){}</code></pre>
+</div>
+<blockquote>
+<p><i>Effects:</i> Constructs an uninitialized object of type <code>endian_arithmetic&lt;E, T, n_bits, A&gt;</code>.</p>
+</blockquote>
+<pre><code><a name="explicit-endian">endian</a>(T v);</code></pre>
+<blockquote>
+<p><i>Effects:</i> Constructs an object of type <code>endian_arithmetic&lt;E, T, n_bits, A&gt;</code>.</p>
+<p><i>Postcondition:</i> <code>x == v,</code> where <code>x</code> is the 
+constructed object.</p>
+</blockquote>
+<pre><code>endian&amp; <a name="operator-eq">operator=</a>(T v);</code></pre>
+<blockquote>
+  <p><i>Postcondition:</i> <code>x == v,</code> where <code>x</code> is the 
+  constructed object.</p>
+  <p><i>Returns:</i> <code>*this</code>.</p>
+</blockquote>
+<pre><code><a name="operator-T">operator T</a>() const;</code></pre>
+<blockquote>
+<p><i>Returns:</i> The current value stored in <code>*this</code>, converted to
+<code>value_type</code>.</p>
+</blockquote>
+<pre><code>const char* <a name="data">data</a>() const;</code></pre>
+<blockquote>
+<p><i>Returns:</i> A pointer to the first byte of the endian binary value stored 
+in <code>*this</code>.</p>
+</blockquote>
+<h3>Other operators</h3>
+<p>Other operators on endian objects are forwarded to the equivalent 
+operator on <code>value_type</code>.</p>
+<h3><a name="Stream-inserter">Stream inserter</a></h3>
+<pre>template &lt;class charT, class traits&gt;
+friend std::basic_ostream&lt;charT, traits&gt;&amp;
+  operator&lt;&lt;(std::basic_ostream&lt;charT, traits&gt;&amp; os, const T&amp; x);
+</pre>
+<blockquote>
+<p><i>Returns:</i> <code>os &lt;&lt; +x</code>.</p>
+</blockquote>
+<h3><a name="Stream-extractor">Stream extractor</a></h3>
+<pre>template &lt;class charT, class traits&gt;
+friend std::basic_istream&lt;charT, traits&gt;&amp;
+  operator&gt;&gt;(std::basic_istream&lt;charT, traits&gt;&amp; is, T&amp; x);
+</pre>
+<blockquote>
+<p><i>Effects: </i>As if:</p>
+  <blockquote>
+    <pre>T i;
+if (is &gt;&gt; i)
+  x = i;
+</pre>
+  </blockquote>
+  <p><i>Returns: </i><code>is</code><i>.</i></p>
+</blockquote>
+<h2><a name="FAQ">FAQ</a></h2>
+
+<p>See the <a href="index.html#FAQ">Endian home page</a> FAQ for a library-wide 
+FAQ.</p>
+
+<p><b>Why not just use Boost.Serialization?</b> Serialization involves a 
+conversion for every object involved in I/O. Endian integers require no 
+conversion or copying. They are already in the desired format for binary I/O. 
+Thus they can be read or written in bulk.</p>
+<p><b>Are endian types PODs?</b> Yes for C++11. No for C++03, although several
+<a href="#Compilation">macros</a> are available to force PODness in all cases.</p>
+<p><b>What are the implications of endian integer types not being PODs with C++03 
+compilers?</b> They 
+can't be used in unions. Also, compilers aren't required to align or lay 
+out storage in portable ways, although this potential problem hasn't prevented 
+use of Boost.Endian with 
+real compilers.</p>
+<p><b>What good is <i>native </i>endianness?</b> It  provides alignment and 
+size guarantees not available from the built-in types. It eases generic 
+programming.</p>
+<p><b>Why bother with the aligned endian types?</b> Aligned integer operations 
+may be faster (as much as 10 to 20 times faster) if the endianness and alignment of 
+the type matches the endianness and alignment requirements of the machine. The code, 
+however, will be somewhat less portable than with the unaligned types.</p>
+<p><b>Why provide the arithmetic operations?</b> Providing a full set of operations reduces program 
+clutter and makes code both easier to write and to read. Consider 
+incrementing a variable in a record. It is very convenient to write:</p>
+<pre wrap>    ++record.foo;</pre>
+<p wrap>Rather than:</p>
+<pre wrap>    int temp(record.foo);
+    ++temp;
+    record.foo = temp;</pre>
+<h2><a name="Design">Design</a> considerations for Boost.Endian types</h2>
+<ul>
+  <li>Must be suitable for I/O - in other words, must be memcpyable.</li>
+  <li>Must provide exactly the size and internal byte ordering specified.</li>
+  <li>Must work correctly when the internal integer representation has more bits 
+  that the sum of the bits in the external byte representation. Sign extension 
+  must work correctly when the internal integer representation type has more 
+  bits than the sum of the bits in the external bytes. For example, using 
+  a 64-bit integer internally to represent 40-bit (5 byte) numbers must work for 
+  both positive and negative values.</li>
+  <li>Must work correctly (including using the same defined external 
+  representation) regardless of whether a compiler treats char as signed or 
+  unsigned.</li>
+  <li>Unaligned types must not cause compilers to insert padding bytes.</li>
+  <li>The implementation should supply optimizations with great care. Experience has shown that optimizations of endian 
+  integers often become pessimizations when changing 
+  machines or compilers. Pessimizations can also happen when changing compiler switches, 
+  compiler versions, or CPU models of the same architecture.</li>
+</ul>
+<h2><a name="Experience">Experience</a></h2>
+<p>Classes with similar functionality have been independently developed by 
+several Boost programmers and used very successful in high-value, high-use 
+applications for many years. These independently developed endian libraries 
+often evolved from C libraries that were also widely used. Endian types have proven widely useful across a wide 
+range of computer architectures and applications.</p>
+<h2><a name="Motivating-use-cases">Motivating use cases</a></h2>
+<p>Neil Mayhew writes: &quot;I can also provide a meaningful use-case for this 
+library: reading TrueType font files from disk and processing the contents. The 
+data format has fixed endianness (big) and has unaligned values in various 
+places. Using Boost.Endian simplifies and cleans the code wonderfully.&quot;</p>
+<h2><a name="C++0x">C++11</a></h2>
+<p>The availability of the C++11
+<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">
+Defaulted Functions</a> feature is detected automatically, and will be used if 
+present to ensure that objects of <code>class endian_arithmetic</code> are trivial, and 
+thus PODs.</p>
+<h2><a name="Compilation">Compilation</a></h2>
+<p>Boost.Endian is implemented entirely within headers, with no need to link to 
+any Boost object libraries.</p>
+<p>Several macros allow user control over features:</p>
+<ul>
+  <li>BOOST_ENDIAN_NO_CTORS causes <code>class endian_arithmetic</code> to have no 
+  constructors. The intended use is for compiling user code that must be 
+  portable between compilers regardless of C++11
+  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">
+  Defaulted Functions</a> support. Use of constructors will always fail, <br>
+&nbsp;</li>
+  <li>BOOST_ENDIAN_FORCE_PODNESS causes BOOST_ENDIAN_NO_CTORS to be defined if 
+  the compiler does not support C++11
+  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">
+  Defaulted Functions</a>. This is ensures that objects of <code>class endian_arithmetic</code> 
+  are PODs, and so can be used in C++03 unions. 
+  In C++11, <code>class endian_arithmetic</code> objects are PODs, even though they have 
+  constructors, so can always be used in unions.</li>
+</ul>
+<h2><a name="Acknowledgements">Acknowledgements</a></h2>
+<p>Original design developed by Darin Adler based on classes developed by Mark 
+Borgerding. Four original class templates combined into a single <code>endian_arithmetic</code> 
+class template by Beman Dawes, who put the library together, provided 
+documentation,  added the typedefs, and also added the <code>unrolled_byte_loops</code> 
+sign partial specialization to correctly extend the sign when cover integer size 
+differs from endian representation size.</p>
+<hr>
+<p>Last revised:
+<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->25 March, 2015<!--webbot bot="Timestamp" endspan i-checksum="28920" --></p>
+<p> Copyright Beman Dawes, 2006-2009, 2013</p>
+<p>Distributed under the Boost Software License, Version 1.0. See
+<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/bikeshed.txt b/libs/endian/doc/bikeshed.txt
new file mode 100644
index 0000000..da17001
--- /dev/null
+++ b/libs/endian/doc/bikeshed.txt
@@ -0,0 +1,79 @@
+Conversion function naming bikeshed
+
+return-by-value          modify-argument
+------------------       ---------------
+
+reverse_endianness       reverse_endianness_in_place    
+       "                 reverse_endianness_arg
+endian_reverse           endian_reverse_in_place
+       "                 endian_reverse_inplace
+	   "                 endian_reverse_replace
+       "                 endian_reverse_in_situ
+       "                 endian_reverse_here
+       "                 endian_reverse_this          
+       "                 endian_reverse_self
+       "                 endian_reverse_arg
+       "                 endian_reverse_in  
+
+reverse                  reverse_in_place
+reverse_endian           reverse_endian_in_place
+
+swap_endianness          swap_endianness_in_place
+swap_endian              swap_endian_in_place
+endian_swap              endian_swap_this
+
+flip_endianness          flip_endianness_in_place
+flip_endian              flip_endian_in_place
+endian_flip              endian_flip_in_place
+
+
+reverse_order            reverse_order_in_place
+
+
+Key points:
+
+* The above names are defined in a user namespace as customization points to be found by
+  ADL, and so cannot depend on the enclosing namespace name to signal readers that they
+  are related to endianness.
+* The above functions are rarely called directly by user code, which is more likely to use
+  the various conditional functions instead. So explicitness is more important than 
+  brevity.
+
+Conditional names
+
+big_to_native  native_to_big  little_to_native  native_to_little
+
+big_to_host    host_to_big    
+                              
+be_to_ne       ne_to_be
+
+from_big, to_big
+
+big_to_native                  big_to_native
+native_to_big                  native_to_big
+
+conditional_reverse            runtime_conditional_reverse
+conditional_reverse            conditional_reverse              <------
+
+merriam-webster.com/dictionary
+
+reverse [1] (adjective): opposite or contrary to a previous or normal condition <reverse order>
+reverse [2] (verb) : to change (something) to an opposite state or condition
+
+swap (verb) : to give something to someone and receive something in return : to trade or exchange (things)
+
+flip (verb)
+
+: to turn (something) over by throwing it up in the air with a quick movement
+
+: to cause (something) to turn or turn over quickly
+
+: to move (something) with a quick light movement
+
+--------------------------------------------------
+
+Copyright Beman Dawes, 2014
+Distributed under the Boost Software License, Version 1.0.
+See www.boost.org/LICENSE_1_0.txt
+
+ 
\ No newline at end of file
diff --git a/libs/endian/doc/buffers.html b/libs/endian/doc/buffers.html
new file mode 100644
index 0000000..85aae22
--- /dev/null
+++ b/libs/endian/doc/buffers.html
@@ -0,0 +1,614 @@
+<html>
+
+<head>
+<meta http-equiv="Content-Language" content="en-us">
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>Endian Buffer Types</title>
+<link href="styles.css" rel="stylesheet">
+</style>
+</head>
+
+<body>
+
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
+  <tr>
+    <td>
+<a href="../../../index.html">
+<img src="../../../boost.png" alt="Boost logo" align="middle" border="0" width="277" height="86"></a></td>
+    <td align="middle">
+    <b>
+    <font size="6">Endian Buffer Types</font> </b>
+    </td>
+  </tr>
+</table>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
+  <tr>
+    <td><b>
+    <a href="index.html">Endian Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="conversion.html">Conversion Functions</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="arithmetic.html">Arithmetic Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="buffers.html">Buffer Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="choosing_approach.html">Choosing Approach</a></b></td>
+  </tr>
+</table>
+
+<p></p>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
+  <tr>
+    <td width="100%" bgcolor="#D7EEFF" align="center">
+      <i><b>Contents</b></i></td>
+  </tr>
+  <tr>
+    <td width="100%" bgcolor="#E8F5FF">
+      <a href="#Introduction">Introduction</a><br>
+      <a href="#Example">Example</a><br>
+      <a href="#Limitations">Limitations</a><br>
+      <a href="#Feature-set">Feature set</a><br>
+      <a href="#Types">Enums and typedefs</a><br>
+      <a href="#Class_template_endian">Class template <code>endian_buffer</code></a><br>
+      &nbsp;&nbsp;&nbsp;
+      <a href="#Synopsis">Synopsis</a><br>
+      &nbsp;&nbsp;&nbsp; <a href="#Members">Members</a><br>
+&nbsp;&nbsp;&nbsp; <a href="#Non-member-functions">Non-Members</a><br>
+      <a href="#FAQ">FAQ</a><br>
+      <a href="#Design">Design</a><br>
+      <a href="#C++0x">C++11</a><br>
+      <a href="#Compilation">Compilation</a></td>
+  </tr>
+  </table>
+<h2><a name="Introduction">Introduction</a></h2>
+<p>The internal byte order of arithmetic types is traditionally called <b><i>endianness</i></b>. See 
+the
+<a href="http://en.wikipedia.org/wiki/Endian" name="endianness">Wikipedia</a> for 
+a full 
+exploration of <b><i>endianness</i></b>, including definitions of <i><b>big 
+endian</b></i> and <i><b>little endian</b></i>.</p>
+<p>Header <b><code>boost/endian/buffers.hpp</code></b> 
+provides <code>endian_buffer</code>, a portable endian integer binary buffer 
+class template with control over 
+byte order, value type, size, and alignment independent of the platform&#39;s native 
+endianness. Typedefs provide easy-to-use names 
+for common configurations.</p>
+<p>Use cases primarily involve data portability, either via files or network 
+connections, but these byte-holders may 
+also be used to reduce memory use, file size, or network activity since they 
+ 
+provide binary numeric sizes not otherwise available.</p>
+<p dir="ltr">Class <code>endian_buffer</code> is aimed at users who wish 
+explicit control over when endianness conversions occur. It also serves as the 
+base class for the <code><a href="arithmetic.html">endian_arithmetic</a></code> 
+class template, which is aimed at users who wish fully automatic endianness 
+conversion and direct support for all normal arithmetic operations.</p>
+<h2><a name="Example">Example</a></h2>
+<p>The <b><code>example/endian_example.cpp</code></b> program writes a 
+binary file containing four-byte, big-endian and little-endian integers:</p>
+<blockquote>
+  <pre>#include &lt;iostream&gt;
+#include &lt;cstdio&gt;
+#include &lt;boost/endian/buffers.hpp&gt;  // see <a href="#Synopsis">Synopsis</a> below
+#include &lt;boost/static_assert.hpp&gt;
+
+using namespace boost::endian;
+
+namespace 
+{
+  //  This is an extract from a very widely used GIS file format.
+  //  Why the designer decided to mix big and little endians in
+  //  the same file is not known. But this is a real-world format
+  //  and users wishing to write low level code manipulating these
+  //  files have to deal with the mixed endianness.
+
+  struct header
+  {
+    big_int32_<code>buf_</code>t     file_code;
+    big_int32_<code>buf_</code>t     file_length;
+    little_int32_<code>buf_</code>t  version;
+    little_int32_<code>buf_</code>t  shape_type;
+  };
+
+  const char* filename = &quot;test.dat&quot;;
+}
+
+int main(int, char* [])
+{
+  header h;
+
+  BOOST_STATIC_ASSERT(sizeof(h) == 16U);  // reality check
+  
+  h.file_code   = 0x01020304;
+  h.file_length = sizeof(header);
+  h.version     = 1;
+  h.shape_type  = 0x01020304;
+
+  //  Low-level I/O such as POSIX read/write or &lt;cstdio&gt;
+  //  fread/fwrite is sometimes used for binary file operations
+  //  when ultimate efficiency is important. Such I/O is often
+  //  performed in some C++ wrapper class, but to drive home the
+  //  point that endian integers are often used in fairly
+  //  low-level code that does bulk I/O operations, &lt;cstdio&gt;
+  //  fopen/fwrite is used for I/O in this example.
+
+  std::FILE* fi = std::fopen(filename, &quot;wb&quot;);  // MUST BE BINARY
+  
+  if (!fi)
+  {
+    std::cout &lt;&lt; &quot;could not open &quot; &lt;&lt; filename &lt;&lt; '\n';
+    return 1;
+  }
+
+  if (std::fwrite(&amp;h, sizeof(header), 1, fi)!= 1)
+  {
+    std::cout &lt;&lt; &quot;write failure for &quot; &lt;&lt; filename &lt;&lt; '\n';
+    return 1;
+  }
+
+  std::fclose(fi);
+
+  std::cout &lt;&lt; &quot;created file &quot; &lt;&lt; filename &lt;&lt; '\n';
+
+  return 0;
+}
+</pre>
+</blockquote>
+<p>After compiling and executing <b><code>example/endian_example.cpp</code></b>, 
+a hex dump of <code>test.dat</code> shows:</p>
+<blockquote>
+  <pre>01020304 00000010 01000000 04030201</pre>
+</blockquote>
+<p>Notice that the first two 32-bit integers are big endian while the second two 
+are little endian, even though the machine this was compiled and run on was 
+little endian.</p>
+<h2><a name="Limitations">Limitations</a></h2>
+<p>Requires <code>&lt;climits&gt;</code> <code>CHAR_BIT == 8</code>. If <code>CHAR_BIT</code> 
+is some other value, compilation will result in an <code>#error</code>. This 
+restriction is in place because the design, implementation, testing, and 
+documentation has only considered issues related to 8-bit bytes, and there have 
+been no real-world use cases presented for other sizes.</p>
+<p>In C++03, <code>endian_buffer</code> does not meet the requirements for POD types 
+because it has constructors, private data members, and a base class. This means 
+that common use cases are relying on unspecified behavior in that the C++ 
+Standard does not guarantee memory layout for non-POD types. This has not been a 
+problem in practice since all known C++ compilers  lay out memory as if <code>
+endian</code> were a POD type. In C++11, it is possible to specify the 
+default constructor as trivial, and private data members and base classes  no longer disqualify a type from being a POD 
+type. Thus under C++11, <code>endian_buffer</code> 
+will no longer be relying on unspecified behavior.</p>
+<h2><a name="Feature-set">Feature set</a></h2>
+<ul>
+  <li>Big endian| little endian | native endian byte ordering.</li>
+  <li>Signed | unsigned</li>
+  <li>Unaligned | aligned</li>
+  <li>1-8 byte (unaligned) | 1, 2, 4, 8 byte (aligned)</li>
+  <li>Choice of  value type</li>
+</ul>
+<h2>Enums and t<a name="Types">ypedefs</a></h2>
+<p>Two scoped enums are provided:</p>
+<blockquote>
+  <pre>enum class order {big, little, native};
+
+enum class align {no, yes}; </pre>
+</blockquote>
+<p>One class template is provided:</p>
+<blockquote>
+  <pre>template &lt;order Order, typename T, std::size_t Nbits,
+  align Align = align::no&gt;
+class endian_buffer;
+</pre>
+</blockquote>
+<p>Typedefs, such as <code>big_int32_buf_t</code>, provide convenient naming 
+conventions for common use cases:</p>
+<blockquote>
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="49%">
+  <tr>
+    <td width="18%" align="center"><b><i>Name</i></b></td>
+    <td width="49%" align="center"><b><i>Alignment</i></b></td>
+    <td width="10%" align="center"><b><i>Endianness</i></b></td>
+    <td width="10%" align="center"><b><i>Sign</i></b></td>
+    <td width="15%" align="center"><b><i>Sizes in bits (n)</i></b></td>
+  </tr>
+  <tr>
+    <td width="18%" dir="ltr"><code>big_int</code><b><i>n</i></b><code>_buf_t</code></td>
+    <td width="49%" align="center" dir="ltr"><code>no</code></td>
+    <td width="10%" align="center" dir="ltr"><code>big</code></td>
+    <td width="10%" align="center" dir="ltr">signed</td>
+    <td width="15%" dir="ltr">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%" dir="ltr"><code>big_uint</code><i><b>n</b></i><code>_buf_t</code></td>
+    <td width="49%" align="center" dir="ltr"><code>no</code></td>
+    <td width="10%" align="center" dir="ltr"><code>big</code></td>
+    <td width="10%" align="center" dir="ltr">unsigned</td>
+    <td width="15%" dir="ltr">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>little_int</code><i><b>n</b></i><code>_buf_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>little</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>little_uint</code><i><b>n</b></i><code>_buf_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>little</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>native_int</code><i><b>n</b></i><code>_buf_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>native</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>native_uint</code><i><b>n</b></i><code>_buf_t</code></td>
+    <td width="49%" align="center"><code>no</code></td>
+    <td width="10%" align="center"><code>native</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,24,32,40,48,56,64</td>
+    </tr>
+  <tr>
+    <td width="18%"><code>big_int</code><i><b>n</b></i><code>_buf_at</code></td>
+    <td width="49%" align="center"><code>yes</code></td>
+    <td width="10%" align="center"><code>big</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,32,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>big_uint</code><i><b>n</b></i><code>_</code><code>buf_at</code></td>
+    <td width="49%" align="center"><code>yes</code></td>
+    <td width="10%" align="center"><code>big</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,32,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>little_int</code><i><b>n</b></i><code>_</code><code>buf_at</code></td>
+    <td width="49%" align="center"><code>yes</code></td>
+    <td width="10%" align="center"><code>little</code></td>
+    <td width="10%" align="center">signed</td>
+    <td width="15%">8,16,32,64</td>
+  </tr>
+  <tr>
+    <td width="18%"><code>little_uint</code><i><b>n</b></i><code>_</code><code>buf_at</code></td>
+    <td width="49%" align="center"><code>yes</code></td>
+    <td width="10%" align="center"><code>little</code></td>
+    <td width="10%" align="center">unsigned</td>
+    <td width="15%">8,16,32,64</td>
+  </tr>
+</table>
+</blockquote>
+<p>The unaligned types do not cause compilers to insert padding bytes in classes 
+and structs. This is an important characteristic that can be exploited to minimize wasted space in 
+memory, files, and network transmissions. </p>
+<p><font color="#FF0000"><b><i><span style="background-color: #FFFFFF">Warning:</span></i></b></font><span style="background-color: #FFFFFF"> 
+Code that uses a</span>ligned types is possibly non-portable because alignment 
+requirements vary between hardware architectures and because alignment may be 
+affected by compiler switches or pragmas. For example, alignment of an 64-bit 
+integer may be to a 32-bit boundary on a 32-bit machine and to a 64-bit boundary 
+on a 64-bit machine. Furthermore, aligned types 
+are only available on architectures with 8, 16, 32, and 64-bit integer types. </p>
+<p><i><b>Recommendation:</b></i> Prefer unaligned buffer types.</p>
+<p><i><b>Recommendation:</b></i> Protect yourself against alignment ills. For 
+example:</p>
+<blockquote>
+  <pre>static_assert(sizeof(containing_struct) == 12, &quot;sizeof(containing_struct) is wrong&quot;); </pre>
+</blockquote>
+<p><b><i>Note:</i></b> One-byte big and little buffer types 
+have identical layout on all platforms, so they never actually reverse endianness. They are provided to enable generic code, and 
+to improve code readability and searchability.</p>
+<h2><a name="Class_template_endian">Class template <code>endian</code></a><code>_buffer</code></h2>
+<p>An <code>endian_buffer</code> is an integer byte-holder with user-specified <a href="#endianness">
+endianness</a>, value type, size, and <a href="#alignment">alignment</a>. The 
+usual operations on integers are supplied.</p>
+<h3><a name="Synopsis">Synopsis</a></h3>
+<pre>namespace boost
+{
+  namespace endian
+  {
+    //  C++11 features emulated if not available
+   
+    enum class <a name="order">order</a>
+    {
+      big,                             // big-endian
+      little,                          // little-endian
+      native = <b><i>implementation-defined</i></b>  // same as order::big or order::little<b><i>
+    </i></b>};
+
+    enum class <a name="alignment">align</a> {no, yes};            
+
+    template &lt;order Order, class T, std::size_t Nbits,
+      align Align = align::no&gt;
+    class endian_buffer
+    {
+    public:
+      typedef T value_type;
+
+      <a href="#endian">endian_buffer</a>() noexcept = default;
+      explicit <a href="#explicit-endian">endian_buffer</a>(T v) noexcept;
+
+      endian_buffer&amp; <a href="#operator-eq">operator=</a>(T v) noexcept;
+      value_type     <a href="#value">value</a>() const noexcept;
+      const char*    <a href="#data">data</a>() const noexcept;
+    protected:
+      <b><i>implementaton-defined</i></b>  endian_value;  // for exposition only
+    };
+    
+    //  stream inserter
+    template &lt;class charT, class traits, order Order, class T,
+      std::size_t n_bits, align Align&gt;
+    std::basic_ostream&lt;charT, traits&gt;&amp;
+      <a href="#inserter">operator&lt;&lt;</a>(std::basic_ostream&lt;charT, traits&gt;&amp; os,
+        const endian_buffer&lt;Order, T, n_bits, Align&gt;&amp; x);
+
+    //  stream extractor 
+    template &lt;class charT, class traits, order Order, class T,
+      std::size_t n_bits, align A&gt;
+    std::basic_istream&lt;charT, traits&gt;&amp;
+      <a href="#extractor">operator&gt;&gt;</a>(std::basic_istream&lt;charT, traits&gt;&amp; is,
+        endian_buffer&lt;Order, T, n_bits, Align&gt;&amp; x);
+
+    // typedefs  
+
+    // unaligned big endian signed integer buffers
+    typedef endian_buffer&lt;order::big, int_least8_t, 8&gt;        big_int8_buf_t;
+    typedef endian_buffer&lt;order::big, int_least16_t, 16&gt;      big_int16_buf_t;
+    typedef endian_buffer&lt;order::big, int_least32_t, 24&gt;      big_int24_buf_t;
+    typedef endian_buffer&lt;order::big, int_least32_t, 32&gt;      big_int32_buf_t;
+    typedef endian_buffer&lt;order::big, int_least64_t, 40&gt;      big_int40_buf_t;
+    typedef endian_buffer&lt;order::big, int_least64_t, 48&gt;      big_int48_buf_t;
+    typedef endian_buffer&lt;order::big, int_least64_t, 56&gt;      big_int56_buf_t;
+    typedef endian_buffer&lt;order::big, int_least64_t, 64&gt;      big_int64_buf_t;
+  
+    // unaligned big endian unsigned integer buffers
+    typedef endian_buffer&lt;order::big, uint_least8_t, 8&gt;       big_uint8_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least16_t, 16&gt;     big_uint16_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least32_t, 24&gt;     big_uint24_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least32_t, 32&gt;     big_uint32_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least64_t, 40&gt;     big_uint40_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least64_t, 48&gt;     big_uint48_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least64_t, 56&gt;     big_uint56_buf_t;
+    typedef endian_buffer&lt;order::big, uint_least64_t, 64&gt;     big_uint64_buf_t;
+  
+    // unaligned little endian signed integer buffers
+    typedef endian_buffer&lt;order::little, int_least8_t, 8&gt;     little_int8_buf_t;
+    typedef endian_buffer&lt;order::little, int_least16_t, 16&gt;   little_int16_buf_t;
+    typedef endian_buffer&lt;order::little, int_least32_t, 24&gt;   little_int24_buf_t;
+    typedef endian_buffer&lt;order::little, int_least32_t, 32&gt;   little_int32_buf_t;
+    typedef endian_buffer&lt;order::little, int_least64_t, 40&gt;   little_int40_buf_t;
+    typedef endian_buffer&lt;order::little, int_least64_t, 48&gt;   little_int48_buf_t;
+    typedef endian_buffer&lt;order::little, int_least64_t, 56&gt;   little_int56_buf_t;
+    typedef endian_buffer&lt;order::little, int_least64_t, 64&gt;   little_int64_buf_t;
+  
+    // unaligned little endian unsigned integer buffers
+    typedef endian_buffer&lt;order::little, uint_least8_t, 8&gt;    little_uint8_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least16_t, 16&gt;  little_uint16_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least32_t, 24&gt;  little_uint24_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least32_t, 32&gt;  little_uint32_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least64_t, 40&gt;  little_uint40_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least64_t, 48&gt;  little_uint48_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least64_t, 56&gt;  little_uint56_buf_t;
+    typedef endian_buffer&lt;order::little, uint_least64_t, 64&gt;  little_uint64_buf_t;
+  
+    // unaligned native endian signed integer types
+    typedef <b><i>implementation-defined</i></b>_int8_buf_t   native_int8_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int16_buf_t  native_int16_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int24_buf_t  native_int24_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int32_buf_t  native_int32_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int40_buf_t  native_int40_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int48_buf_t  native_int48_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int56_buf_t  native_int56_buf_t;
+    typedef <b><i>implementation-defined</i></b>_int64_buf_t  native_int64_buf_t;
+
+    // unaligned native endian unsigned integer types
+    typedef <b><i>implementation-defined</i></b>_uint8_buf_t   native_uint8_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint16_buf_t  native_uint16_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint24_buf_t  native_uint24_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint32_buf_t  native_uint32_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint40_buf_t  native_uint40_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint48_buf_t  native_uint48_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint56_buf_t  native_uint56_buf_t;
+    typedef <b><i>implementation-defined</i></b>_uint64_buf_t  native_uint64_buf_t;
+    
+    // aligned big endian signed integer buffers
+    typedef endian_buffer&lt;order::big, int8_t, 8, align::yes&gt;       big_int8_buf_at;
+    typedef endian_buffer&lt;order::big, int16_t, 16, align::yes&gt;     big_int16_buf_at;
+    typedef endian_buffer&lt;order::big, int32_t, 32, align::yes&gt;     big_int32_buf_at;
+    typedef endian_buffer&lt;order::big, int64_t, 64, align::yes&gt;     big_int64_buf_at;
+  
+    // aligned big endian unsigned integer buffers
+    typedef endian_buffer&lt;order::big, uint8_t, 8, align::yes&gt;      big_uint8_buf_at;
+    typedef endian_buffer&lt;order::big, uint16_t, 16, align::yes&gt;    big_uint16_buf_at;
+    typedef endian_buffer&lt;order::big, uint32_t, 32, align::yes&gt;    big_uint32_buf_at;
+    typedef endian_buffer&lt;order::big, uint64_t, 64, align::yes&gt;    big_uint64_buf_at;
+  
+    // aligned little endian signed integer buffers
+    typedef endian_buffer&lt;order::little, int8_t, 8, align::yes&gt;    little_int8_buf_at;
+    typedef endian_buffer&lt;order::little, int16_t, 16, align::yes&gt;  little_int16_buf_at;
+    typedef endian_buffer&lt;order::little, int32_t, 32, align::yes&gt;  little_int32_buf_at;
+    typedef endian_buffer&lt;order::little, int64_t, 64, align::yes&gt;  little_int64_buf_at;
+  
+    // aligned little endian unsigned integer buffers
+    typedef endian_buffer&lt;order::little, uint8_t, 8, align::yes&gt;   little_uint8_buf_at;
+    typedef endian_buffer&lt;order::little, uint16_t, 16, align::yes&gt; little_uint16_buf_at;
+    typedef endian_buffer&lt;order::little, uint32_t, 32, align::yes&gt; little_uint32_buf_at;
+    typedef endian_buffer&lt;order::little, uint64_t, 64, align::yes&gt; little_uint64_buf_at;
+
+    // aligned native endian typedefs are not provided because
+    // &lt;cstdint&gt; types are superior for this use case
+  
+  } // namespace endian
+} // namespace boost</pre>
+<p>The <i><b><code>implementation-defined</code></b></i> text in typedefs above is either
+<code>big</code> or <code>little</code> according to the native endianness of the 
+platform.</p>
+<p>The expository data member <code>endian_value</code> stores the current value 
+of an <code>endian_value</code> object as a sequence of bytes ordered as 
+specified by the <code>Order</code> template parameter.&nbsp; The <i><b><code>
+implementation-defined</code></b></i> type of <code>endian_value</code> is a 
+type such as <code><span style="font-size: 85%">char[Nbits/CHAR_BIT]</span></code> 
+or <code><span style="font-size: 85%">T</span></code> that meets the 
+requirements imposed by the <code>Nbits</code> and <code>Align</code> template 
+parameters.&nbsp; The <code><span style="font-size: 85%">CHAR_BIT</span></code> 
+macro is defined in <code><span style="font-size: 85%">&lt;climits&gt;</span></code>. 
+The only value of <code><span style="font-size: 85%">CHAR_BIT</span></code> that 
+is required to be supported is 8.</p>
+<p>Template parameter <code><span style="font-size: 85%">T</span></code> is 
+required to be a standard integer type (C++std, 3.9.1) and <code>
+<span style="font-size: 85%">sizeof(T)*CHAR_BIT</span></code> is required to be 
+greater or equal to <span style="font-size: 85%"> <code>Nbits</code>.</span></p>
+<h3><a name="Members">Members</a></h3>
+  <pre><code><a name="endian">endian</a>_buffer() noexcept = default;</code></pre>
+<blockquote>
+<p><i>Effects:</i> Constructs an uninitialized object of type <code>endian_buffer&lt;Order, T, 
+Nbits, Align&gt;</code>.</p>
+</blockquote>
+<pre><code>explicit <a name="explicit-endian">endian</a>_buffer(T v) noexcept;</code></pre>
+<blockquote>
+<p><i>Effects:</i> Constructs an object of type <code>endian_buffer&lt;Order, T, 
+Nbits, Align&gt;</code>.</p>
+<p><i>Postcondition:</i> <code>value() == v &amp; mask</code>, where <code>mask</code> 
+is a constant of type <code>value_type</code> with <code>Nbits</code> low-order 
+bits set to one.</p>
+<p><i>Remarks:</i> If <code>Align</code> is <code>align::yes</code> then 
+endianness conversion, if required, is performed by <code>
+boost::endian::endian_reverse</code>.</p>
+</blockquote>
+<pre><code>endian_buffer&amp; <a name="operator-eq">operator=</a>(T v) noexcept;</code></pre>
+<blockquote>
+  <p><i>Postcondition:</i> <code>value() == v &amp; mask</code>, where <code>mask</code> 
+  is a constant of type <code>value_type</code> with <code>Nbits</code> 
+  low-order bits set to one.</p>
+  <p><i>Returns:</i> <code>*this</code>.</p>
+<p><i>Remarks:</i> If <code>Align</code> is <code>align::yes</code> then 
+endianness conversion, if required, is performed by <code>
+boost::endian::endian_reverse</code>.</p>
+</blockquote>
+<pre>value_type <a name="value">value</a>()<code> const noexcept;</code></pre>
+<blockquote>
+<p><i>Returns:</i> <code>endian_value</code>, converted to <code>value_type</code>, 
+if required, and having the endianness of the native platform.</p>
+<p><i>Remarks:</i> If <code>Align</code> is <code>align::yes</code> then 
+endianness conversion, if required, is performed by <code>
+boost::endian::endian_reverse</code>.</p>
+</blockquote>
+<pre><code>const char* <a name="data">data</a>() const noexcept;</code></pre>
+<blockquote>
+<p><i>Returns:</i> A pointer to the first byte of <code>endian_value</code>.</p>
+</blockquote>
+<h3><a name="Non-member-functions">Non-member functions</a></h3>
+<pre>template &lt;class charT, class traits, order Order, class T,
+  std::size_t n_bits, align Align&gt;
+std::basic_ostream&lt;charT, traits&gt;&amp; <a name="inserter">operator&lt;&lt;</a>(std::basic_ostream&lt;charT, traits&gt;&amp; os,
+  const endian_buffer&lt;Order, T, n_bits, Align&gt;&amp; x);
+</pre>
+<blockquote>
+  <p><i>Returns:</i> <code>os &lt;&lt; x.value()</code>.</p>
+</blockquote>
+<pre>template &lt;class charT, class traits, order Order, class T,
+  std::size_t n_bits, align A&gt;
+std::basic_istream&lt;charT, traits&gt;&amp; <a name="extractor">operator&gt;&gt;</a>(std::basic_istream&lt;charT, traits&gt;&amp; is,
+  endian_buffer&lt;Order, T, n_bits, Align&gt;&amp; x);
+</pre>
+<blockquote>
+  <p><i>Effects: </i>As if:</p>
+  <blockquote>
+    <pre>T i;
+if (is &gt;&gt; i)
+  x = i;
+</pre>
+  </blockquote>
+  <p><i>Returns:</i> <code>is</code>.</p>
+</blockquote>
+<h2><a name="FAQ">FAQ</a></h2>
+
+<p>See the <a href="index.html#FAQ">Endian home page</a> FAQ for a library-wide 
+FAQ.</p>
+
+<p><b>Why not just use Boost.Serialization?</b> Serialization involves a 
+conversion for every object involved in I/O. Endian integers require no 
+conversion or copying. They are already in the desired format for binary I/O. 
+Thus they can be read or written in bulk.</p>
+<p><b>Are endian types PODs?</b> Yes for C++11. No for C++03, although several
+<a href="#Compilation">macros</a> are available to force PODness in all cases.</p>
+<p><b>What are the implications of endian integer types not being PODs with C++03 
+compilers?</b> They 
+can't be used in unions. Also, compilers aren't required to align or lay 
+out storage in portable ways, although this potential problem hasn't prevented 
+use of Boost.Endian with 
+real compilers.</p>
+<p><b>What good is <i>native </i>endianness?</b> It  provides alignment and 
+size guarantees not available from the built-in types. It eases generic 
+programming.</p>
+<p><b>Why bother with the aligned endian types?</b> Aligned integer operations 
+may be faster (as much as 10 to 20 times faster) if the endianness and alignment of 
+the type matches the endianness and alignment requirements of the machine. The code, 
+however, is 
+likely to be somewhat less portable than with the unaligned types.</p>
+<p><b>Why provide the arithmetic operations?</b> Providing a full set of operations reduces program 
+clutter and makes code both easier to write and to read. Consider 
+incrementing a variable in a record. It is very convenient to write:</p>
+<pre wrap>    ++record.foo;</pre>
+<p wrap>Rather than:</p>
+<pre wrap>    int temp(record.foo);
+    ++temp;
+    record.foo = temp;</pre>
+<h2><a name="Design">Design</a> considerations for Boost.Endian buffers</h2>
+<ul>
+  <li>Must be suitable for I/O - in other words, must be memcpyable.</li>
+  <li>Must provide exactly the size and internal byte ordering specified.</li>
+  <li>Must work correctly when the internal integer representation has more bits 
+  that the sum of the bits in the external byte representation. Sign extension 
+  must work correctly when the internal integer representation type has more 
+  bits than the sum of the bits in the external bytes. For example, using 
+  a 64-bit integer internally to represent 40-bit (5 byte) numbers must work for 
+  both positive and negative values.</li>
+  <li>Must work correctly (including using the same defined external 
+  representation) regardless of whether a compiler treats char as signed or 
+  unsigned.</li>
+  <li>Unaligned types must not cause compilers to insert padding bytes.</li>
+  <li>The implementation should supply optimizations with great care. Experience has shown that optimizations of endian 
+  integers often become pessimizations when changing 
+  machines or compilers. Pessimizations can also happen when changing compiler switches, 
+  compiler versions, or CPU models of the same architecture.</li>
+</ul>
+<h2><a name="C++0x">C++11</a></h2>
+<p>The availability of the C++11
+<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">
+Defaulted Functions</a> feature is detected automatically, and will be used if 
+present to ensure that objects of <code>class endian_buffer</code> are trivial, and 
+thus PODs.</p>
+<h2><a name="Compilation">Compilation</a></h2>
+<p>Boost.Endian is implemented entirely within headers, with no need to link to 
+any Boost object libraries.</p>
+<p>Several macros allow user control over features:</p>
+<ul>
+  <li>BOOST_ENDIAN_NO_CTORS causes <code>class endian_buffer</code> to have no 
+  constructors. The intended use is for compiling user code that must be 
+  portable between compilers regardless of C++11
+  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">
+  Defaulted Functions</a> support. Use of constructors will always fail, <br>
+&nbsp;</li>
+  <li>BOOST_ENDIAN_FORCE_PODNESS causes BOOST_ENDIAN_NO_CTORS to be defined if 
+  the compiler does not support C++11
+  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">
+  Defaulted Functions</a>. This is ensures that objects of <code>class endian_buffer</code> 
+  are PODs, and so can be used in C++03 unions. 
+  In C++11, <code>class endian_buffer</code> objects are PODs, even though they have 
+  constructors, so can always be used in unions.</li>
+</ul>
+<hr>
+<p>Last revised:
+<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->25 March, 2015<!--webbot bot="Timestamp" endspan i-checksum="28920" --></p>
+<p> Copyright Beman Dawes, 2006-2009, 2013</p>
+<p>Distributed under the Boost Software License, Version 1.0. See
+<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/choosing_approach.html b/libs/endian/doc/choosing_approach.html
new file mode 100644
index 0000000..effb79f
--- /dev/null
+++ b/libs/endian/doc/choosing_approach.html
@@ -0,0 +1,412 @@
+<html>
+
+<head>
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>Choosing Approach</title>
+<link href="styles.css" rel="stylesheet">
+</head>
+
+<body>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
+  <tr>
+    <td width="339">
+<a href="../../../index.html">
+<img src="../../../boost.png" alt="Boost logo" align="middle" border="0" width="277" height="86"></a></td>
+    <td align="middle" width="1253">
+    <font size="6"><b>Choosing the Approach</b></font></td>
+  </tr>
+</table>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
+  bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
+  <tr>
+    <td><b>
+    <a href="index.html">Endian Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="conversion.html">Conversion Functions</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="arithmetic.html">Arithmetic Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="buffers.html">Buffer Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="choosing_approach.html">Choosing Approach</a></b></td>
+  </tr>
+</table>
+<p></p>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
+  <tr>
+    <td width="100%" bgcolor="#D7EEFF" align="center">
+      <i><b>Contents</b></i></td>
+  </tr>
+  <tr>
+    <td width="100%" bgcolor="#E8F5FF">
+<a href="#Introduction">Introduction</a><br>
+<a href="#Choosing">Choosing between conversion functions,</a><br>
+  &nbsp;  <a href="#Choosing">buffer types, and  arithmetic types</a><br>
+&nbsp;&nbsp;&nbsp;<a href="#Characteristics">Characteristics</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Endianness-invariants">Endianness invariants</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Conversion-explicitness">Conversion explicitness</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Arithmetic-operations">Arithmetic operations</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Sizes">Sizes</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Alignments">Alignments</a><br>
+&nbsp;&nbsp;&nbsp;<a href="#Design-patterns">Design patterns</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#As-needed">Convert only as needed (i.e. lazy)</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Anticipating-need">Convert in anticipation of need</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Convert-generally-as-needed-locally-in-anticipation">Generally 
+as needed, locally in anticipation</a><br>
+&nbsp;&nbsp;&nbsp;<a href="#Use-cases">Use case examples</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Porting-endian-unaware-codebase">Porting endian unaware codebase</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Porting-endian-aware-codebase">Porting endian aware codebase</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Reliability-arithmetic-speed">Reliability and arithmetic-speed</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Reliability-ease-of-use">Reliability and ease-of-use</a></td>
+  </tr>
+  </table>
+
+<h2><a name="Introduction">Introduction</a></h2>
+
+<p>Deciding which is the best endianness approach (conversion functions, buffer 
+types, or arithmetic types) for a particular application involves complex 
+engineering trade-offs. It is hard to assess those trade-offs without some 
+understanding of the different interfaces, so you might want to read the
+<a href="conversion.html">conversion functions</a>, <a href="buffers.html">
+buffer types</a>, and <a href="arithmetic.html">arithmetic types</a> pages 
+before diving into this page.</p>
+
+<h2><a name="Choosing">Choosing</a> between  conversion functions,  buffer types, 
+and  arithmetic types</h2>
+
+<p>The best approach to endianness for a particular application  depends on  the interaction between 
+the application&#39;s needs and the characteristics of each of the three  approaches.</p>
+
+<p><b>Recommendation:</b> If you are new to endianness, uncertain, or don&#39;t want to invest 
+the time to 
+study 
+engineering trade-offs, use <a href="arithmetic.html">endian arithmetic types</a>. They are safe, easy 
+to use, and easy to maintain. Use the
+<a href="#Anticipating-need"> <i>
+anticipating need</i></a> design pattern locally around performance hot spots 
+like lengthy loops, if needed.</p>
+
+<h3><a name="Background">Background</a> </h3>
+
+<p>A dealing with endianness usually implies a program portability or a data 
+portability requirement, and often both. That means real programs dealing with 
+endianness are usually complex, so the examples shown here would really be 
+written as multiple functions spread across multiple translation units. They 
+would involve interfaces that can not be altered as they are supplied by 
+third-parties or the standard library. </p>
+
+<h3><a name="Characteristics">Characteristics</a></h3>
+
+<p>The characteristics that differentiate the three approaches to endianness are the endianness 
+invariants, conversion explicitness, arithmetic operations, sizes available, and 
+alignment requirements.</p>
+
+<h4><a name="Endianness-invariants">Endianness invariants</a></h4>
+
+<blockquote>
+
+<p><b>Endian conversion functions</b> use objects of the ordinary C++ arithmetic 
+types like <code>int</code> or <code>unsigned short</code> to hold values. That 
+breaks the implicit invariant that the C++ language rules apply. The usual 
+language rules only apply if the endianness of the object is currently set to the native endianness for the platform. That can 
+make it very hard to reason about logic flow, and result in difficult to 
+find bugs.</p>
+
+<p>For example:</p>
+
+<blockquote>
+  <pre>struct data_t  // big endian
+{
+  int32_t   v1;  // description ...
+  int32_t   v2;  // description ...
+  ... additional character data members (i.e. non-endian)
+  int32_t   v3;  // description ...
+};
+
+data_t data;
+
+read(data);
+big_to_native_inplace(data.v1);
+big_to_native_inplace(data.v2);
+
+... 
+
+++v1;
+third_party::func(data.v2);
+
+... 
+
+native_to_big_inplace(data.v1);
+native_to_big_inplace(data.v2);
+write(data);
+</pre>
+  <p>The programmer didn&#39;t bother to convert <code>data.v3</code> to native 
+  endianness because that member isn&#39;t used. A later maintainer needs to pass
+  <code>data.v3</code> to the third-party function, so adds <code>third_party::func(data.v3);</code> 
+  somewhere deep in the code. This causes a silent failure because the usual 
+  invariant that an object of type <code>int32_t</code> holds a value as 
+  described by the C++ core language does not apply.</p>
+</blockquote>
+<p><b>Endian buffer and arithmetic types</b> hold values internally as arrays of 
+characters with an invariant that the endianness of the array never changes. 
+That makes these types easier to use and programs easier to maintain. </p>
+<p>Here is the same example, using an endian arithmetic type:</p>
+<blockquote>
+  <pre>struct data_t
+{
+  big_int32_t   v1;  // description ...
+  big_int32_t   v2;  // description ...
+  ... additional character data members (i.e. non-endian)
+  big_int32_t   v3;  // description ...
+};
+
+data_t data;
+
+read(data);
+
+... 
+
+++v1;
+third_party::func(data.v2);
+
+... 
+
+write(data);
+</pre>
+  <p>A later maintainer can add <code>third_party::func(data.v3)</code>and it 
+  will just-work.</p>
+</blockquote>
+
+</blockquote>
+
+<h4><a name="Conversion-explicitness">Conversion explicitness</a></h4>
+
+<blockquote>
+
+<p><b>Endian conversion functions</b> and <b>buffer types</b> never perform 
+implicit conversions. This gives users explicit control of when conversion 
+occurs, and may help avoid unnecessary conversions.</p>
+
+<p><b>Endian arithmetic types</b> perform conversion implicitly. That makes 
+these types very easy to use, but can result in unnecessary conversions. Failure 
+to hoist conversions out of inner loops can bring a performance penalty.</p>
+
+</blockquote>
+
+<h4><a name="Arithmetic-operations">Arithmetic operations</a></h4>
+
+<blockquote>
+
+<p><b>Endian conversion functions</b> do not supply arithmetic 
+operations, but this is not a concern since this approach uses ordinary C++ 
+arithmetic types to hold values.</p>
+
+<p><b>Endian buffer types</b> do not supply arithmetic operations. Although this 
+approach avoids unnecessary conversions, it can result in the introduction of 
+additional variables and confuse maintenance programmers.</p>
+
+<p><b>Endian</b> <b>arithmetic types</b> do supply arithmetic operations. They 
+are very easy to use if lots of arithmetic is involved. </p>
+
+</blockquote>
+
+<h4><a name="Sizes">Sizes</a></h4>
+
+<blockquote>
+
+<p><b>Endianness conversion functions</b> only support 1, 2, 4, and 8 byte 
+integers. That&#39;s sufficient for many applications.</p>
+
+<p><b>Endian buffer and arithmetic types</b> support 1, 2, 3, 4, 5, 6, 7, and 8 
+byte integers. For an application where memory use or I/O speed is the limiting 
+factor, using sizes tailored to application needs can be  useful.</p>
+
+</blockquote>
+
+<h4><a name="Alignments">Alignments</a></h4>
+
+<blockquote>
+
+<p><b>Endianness conversion functions</b> only support aligned integer and 
+floating-point types. That&#39;s sufficient for most applications.</p>
+
+<p><b>Endian buffer and arithmetic types</b> support both aligned and unaligned 
+integer and floating-point types. Unaligned types are rarely needed, but when 
+needed they are often very useful and workarounds are painful. For example,</p>
+
+<blockquote>
+  <p>Non-portable code like this:<blockquote>
+      <pre>struct S {
+  uint16_t a;&nbsp; // big endian
+  uint32_t b;&nbsp; // big endian
+} __attribute__ ((packed));</pre>
+    </blockquote>
+    <p>Can be replaced with portable code like this:</p>
+    <blockquote>
+      <pre>struct S {
+  big_uint16_ut a;
+  big_uint32_ut b;
+};</pre>
+    </blockquote>
+      </blockquote>
+
+</blockquote>
+
+<h3><a name="Design-patterns">Design patterns</a></h3>
+
+<p>Applications often traffic in endian data as records or packets containing 
+multiple endian data elements. For simplicity, we will just call them records.</p>
+
+<p>If desired endianness differs from native endianness, a conversion has to be 
+performed. When should that conversion occur? Three design patterns have 
+evolved.</p>
+
+<h4><a name="As-needed">Convert only as needed</a> (i.e. lazy)</h4>
+
+<p>This pattern defers conversion to the point in the code where the data 
+element is actually used.</p>
+
+<p>This pattern is appropriate when which endian element is actually used varies 
+greatly according to record content or other circumstances</p>
+
+<h4><a name="Anticipating-need">Convert in anticipation of need</a></h4>
+
+<p>This pattern performs conversion to native endianness in anticipation of use, 
+such as immediately after reading records. If needed, conversion to the output 
+endianness is performed after all possible needs have passed, such as just 
+before writing records.</p>
+
+<p>One implementation of this pattern is to create a proxy record with 
+endianness converted to native in a read function, and expose only that proxy to 
+the rest of the implementation. If a write function, if needed, handles the 
+conversion from native to the desired output endianness.</p>
+
+<p>This pattern is appropriate when all endian elements in a record are 
+typically used regardless of record content or other circumstances</p>
+
+<h4><a name="Convert-generally-as-needed-locally-in-anticipation">Convert 
+only as needed, except locally in anticipation of need</a></h4>
+
+<p>This pattern in general defers conversion but for specific local needs does 
+anticipatory conversion. Although particularly appropriate when coupled with the endian buffer 
+or arithmetic types, it also works well with the conversion functions.</p>
+
+<p>Example:</p>
+
+<blockquote>
+  <pre>struct data_t
+{
+  big_int32_t   v1;
+  big_int32_t   v2;
+  big_int32_t   v3;
+};
+
+data_t data;
+
+read(data);
+
+...
+++v1;
+...
+
+int32_t v3_temp = data.v3;  // hoist conversion out of loop
+
+for (int32_t i = 0; i &lt; <i><b>large-number</b></i>; ++i)
+{
+  ... <i><b>lengthy computation that accesses </b></i>v3_temp<i><b> many times</b></i> ...
+}
+data.v3 = v3_temp; 
+
+write(data);
+</pre>
+</blockquote>
+
+<p dir="ltr">In general the above pseudo-code leaves conversion up to the endian 
+arithmetic type <code>big_int32_t</code>. But to avoid conversion inside the 
+loop, a temporary is created before the loop is entered, and then used to set 
+the new value of <code>data.v3</code> after the loop is complete.</p>
+
+<blockquote>
+
+<p dir="ltr">Question: Won&#39;t the compiler&#39;s optimizer hoist the conversion out 
+of the loop anyhow?</p>
+
+<p dir="ltr">Answer: VC++ 2015 Preview, and probably others, does not, even for 
+a toy test program. Although the savings is small (two register <code>
+<span style="font-size: 85%">bswap</span></code> instructions), the cost might 
+be significant if the loop is repeated enough times. On the other hand, the 
+program may be so dominated by I/O time that even a lengthy loop will be 
+immaterial.</p>
+
+</blockquote>
+
+<h3><a name="Use-cases">Use case examples</a></h3>
+
+<h4><a name="Porting-endian-unaware-codebase">Porting endian unaware codebase</a></h4>
+
+<p>An existing codebase runs on  big endian systems. It does not 
+currently deal with endianness. The codebase needs to be modified so it can run 
+on&nbsp; little endian systems under various operating systems. To ease 
+transition and protect value of existing files, external data will continue to 
+be maintained as big endian.</p>
+
+<p dir="ltr">The <a href="arithmetic.html">endian 
+arithmetic approach</a> is recommended to meet these needs. A relatively small 
+number of header files dealing with binary I/O layouts need to change types. For 
+example,&nbsp;
+<code>short</code> or <code>int16_t</code> would change to <code>big_int16_t</code>. No 
+changes are required for <code>.cpp</code> files.</p>
+
+<h4><a name="Porting-endian-aware-codebase">Porting endian aware codebase</a></h4>
+
+<p>An existing codebase runs on little-endian Linux systems. It already 
+deals with endianness via
+<a href="http://man7.org/linux/man-pages/man3/endian.3.html">Linux provided 
+functions</a>. Because of a business merger, the codebase has to be quickly 
+modified for Windows and possibly other operating systems, while still 
+supporting Linux. The codebase is reliable and the programmers are all 
+well-aware of endian issues. </p>
+
+<p dir="ltr">These factors all argue for an <a href="conversion.html">endian conversion 
+approach</a> that just mechanically changes the calls to <code>htobe32</code>, 
+etc. to <code>boost::endian::native_to_big</code>, etc. and replaces <code>&lt;endian.h&gt;</code> 
+with <code>&lt;boost/endian/conversion.hpp&gt;</code>.</p>
+
+<h4><a name="Reliability-arithmetic-speed">Reliability and arithmetic-speed</a></h4>
+
+<p>A new, complex, multi-threaded application is to be developed that must run 
+on little endian machines, but do big endian network I/O. The developers believe 
+computational speed for endian variable is critical but have seen numerous bugs 
+result from inability to reason about endian conversion state. They are also 
+worried that future maintenance changes could inadvertently introduce a lot of 
+slow conversions if full-blown endian arithmetic types are used.</p>
+
+<p>The <a href="buffers.html">endian buffers</a> approach is made-to-order for 
+this use case.</p>
+
+<h4><a name="Reliability-ease-of-use">Reliability and ease-of-use</a></h4>
+
+<p>A new, complex, multi-threaded application is to be developed that must run 
+on little endian machines, but do big endian network I/O. The developers believe 
+computational speed for endian variables is <b>not critical</b> but have seen 
+numerous bugs result from inability to reason about endian conversion state. 
+They are also concerned about ease-of-use both during development and long-term 
+maintenance.</p>
+
+<p>Removing concern about conversion speed and adding concern about ease-of-use 
+tips the balance strongly in favor the <a href="arithmetic.html">endian 
+arithmetic approach</a>.</p>
+
+<hr>
+<p>Last revised:
+<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->19 January, 2015<!--webbot bot="Timestamp" endspan i-checksum="38903" --></p>
+<p> Copyright Beman Dawes, 2011, 2013, 2014</p>
+<p>Distributed under the Boost Software License, Version 1.0. See
+<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+
+<p>&nbsp;</p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/conversion.html b/libs/endian/doc/conversion.html
new file mode 100644
index 0000000..d811e07
--- /dev/null
+++ b/libs/endian/doc/conversion.html
@@ -0,0 +1,371 @@
+<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns="http://www.w3.org/TR/REC-html40">
+
+<head>
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+
+<title>Endian Conversion Functions</title>
+<link href="styles.css" rel="stylesheet">
+</head>
+
+<body>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
+  <tr>
+    <td>
+<a href="../../../index.html">
+<img src="../../../boost.png" alt="Boost logo" align="middle" border="0" width="277" height="86" ></a></td>
+    <td align="middle">
+    <b>
+    <font size="6">Endian Conversion Functions</font></b></td>
+  </tr>
+</table>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
+  <tr>
+    <td><b>
+    <a href="index.html">Endian Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="conversion.html">Conversion Functions</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="arithmetic.html">Arithmetic Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="buffers.html">Buffer Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="choosing_approach.html">Choosing Approach</a></b></td>
+  </tr>
+</table>
+
+<p></p>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
+  <tr>
+    <td width="100%" bgcolor="#D7EEFF" align="center">
+      <i><b>Contents</b></i></td>
+  </tr>
+  <tr>
+    <td width="100%" bgcolor="#E8F5FF">
+      <a href="#Introduction">Introduction</a><br>
+      <a href="#Reference">Reference</a><br>
+&nbsp;&nbsp;&nbsp; <a href="#Synopsis">Synopsis</a><br>
+&nbsp;&nbsp;&nbsp; <a href="#Requirements">Requirements</a><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code><a href="#EndianReversible">EndianReversible</a></code><br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Customization-points">Customization for 
+      UDTs</a><br>
+      <a href="#Functions">Functions</a><br>
+      <a href="#FAQ">FAQ</a><br>
+      <a href="#Acknowledgements">Acknowledgements</a></td>
+  </tr>
+  </table>
+
+<h2><a name="Introduction">Introduction</a></h2>
+
+<p>Header <a href="../include/boost/endian/conversion.hpp">boost/endian/conversion.hpp</a> 
+provides byte order reversal and conversion functions that convert objects of 
+the built-in 
+integer types 
+between native, big, or little endian byte 
+ordering. User defined types are also supported.</p>
+
+<h2><a name="Reference">Reference</a></h2>
+
+<p>Functions are implemented <code>inline</code> if appropriate.<code> </code>
+For C++03 compilers, <code> noexcept</code> is 
+elided  . 
+Boost scoped enum emulation is used so that the library still works for compilers that do not support scoped enums.</p>
+
+<h3>
+Header <code>&lt;boost/endian/conversion.hpp&gt;</code>
+<a name="Synopsis">Synopsis</a></h3>
+
+<pre>#define BOOST_ENDIAN_INTRINSIC_MSG \
+   &quot;<b><font face="Arial"><i>message describing presence or absence of intrinsics</i></font></b>&quot;
+
+namespace boost
+{
+namespace endian
+{
+  enum class <a name="order">order</a>
+  {
+    big,                             // big endian
+    little,                          // little endian
+    native = <b><i>implementation-defined-as-big-or-little
+  </i></b>};
+
+  int8_t   <a href="#endian_reverse">endian_reverse</a>(int8_t x) noexcept;
+  int16_t  <a href="#endian_reverse">endian_reverse</a>(int16_t x) noexcept;
+  int32_t  <a href="#endian_reverse">endian_reverse</a>(int32_t x) noexcept;
+  int64_t  <a href="#endian_reverse">endian_reverse</a>(int64_t x) noexcept;
+  uint8_t  <a href="#endian_reverse">endian_reverse</a>(uint8_t x) noexcept;
+  uint16_t <a href="#endian_reverse">endian_reverse</a>(uint16_t x) noexcept;
+  uint32_t <a href="#endian_reverse">endian_reverse</a>(uint32_t x) noexcept;
+  uint64_t <a href="#endian_reverse">endian_reverse</a>(uint64_t x) noexcept;
+
+  template &lt;class EndianReversible&gt;
+    EndianReversible big_to_native(EndianReversible x) noexcept;
+  template &lt;class EndianReversible&gt;
+    EndianReversible native_to_big(EndianReversible x) noexcept;
+  template &lt;class EndianReversible&gt;
+    EndianReversible little_to_native(EndianReversible x) noexcept;
+  template &lt;class EndianReversible&gt;
+    EndianReversible native_to_little(EndianReversible x) noexcept;
+  template &lt;order O1, order O2, class EndianReversible&gt;
+    EndianReversible conditional_reverse(EndianReversible x) noexcept;
+  template &lt;class EndianReversible&gt;
+    EndianReversible conditional_reverse(EndianReversible x,
+      order order1, order order2) noexcept;
+      
+  template &lt;class EndianReversible&gt;
+    void endian_reverse_inplace(EndianReversible&amp; x) noexcept;
+
+  template &lt;class EndianReversibleInplace&gt;
+    void big_to_native_inplace(EndianReversibleInplace&amp; x) noexcept;
+  template &lt;class EndianReversibleInplace&gt;
+    void native_to_big_inplace(EndianReversibleInplace&amp; x) noexcept;
+  template &lt;class EndianReversibleInplace&gt;
+    void little_to_native_inplace(EndianReversibleInplace&amp; x) noexcept;
+  template &lt;class EndianReversibleInplace&gt;
+    void native_to_little_inplace(EndianReversibleInplace&amp; x) noexcept;
+  template &lt;order O1, order O2, class EndianReversibleInplace&gt;
+    void conditional_reverse_inplace(EndianReversibleInplace&amp; x) noexcept; 
+  template &lt;class EndianReversibleInplace&gt;
+   void conditional_reverse_inplace(EndianReversibleInplace&amp; x,
+     order order1, order order2) noexcept;
+
+} // namespace endian
+} // namespace boost</pre>
+<p dir="ltr">The implementation is required to define the <code>enum class order</code> 
+constant <code>native</code> as
+<code>big</code> on big endian platforms and <code>little</code> on little 
+endian platforms.</p>
+<h3 dir="ltr"><a name="Definitions">Definitions</a></h3>
+<p dir="ltr">The standard integral types (C++std 3.9.1) except <code>bool</code>, 
+are collectively called the <i>endian types</i>.</p>
+<h3><a name="Requirements">Requirements</a></h3>
+<h4><a name="Template-argument-requirements">Template argument requirements</a></h4>
+<p dir="ltr">The template definitions in the <code>boost/endian/conversion.hpp</code> 
+header refer to various named requirements whose details are set out in the 
+tables in this subsection. In these tables, <code>T</code> is an object or 
+reference type to be supplied by a C++ program instantiating a template; <code>x</code> 
+is a value of type (possibly <code>const</code>) <code>T</code>; <code>mlx</code> is a 
+modifiable lvalue of type <code>T</code>.</p>
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
+  <tr>
+    <td colspan="3" align="center"><b><code><a name="EndianReversible">EndianReversible</a></code></b> 
+    requirements (in addition to <b><code>CopyConstructible</code></b>)</td>
+  </tr>
+  <tr>
+    <td><b>Expression</b></td>
+    <td><b>Return<br>
+    type</b></td>
+    <td><b>Requirements</b></td>
+  </tr>
+  <tr>
+    <td valign="top"><code>endian_reverse(x)</code></td>
+    <td align="center" valign="top"><code>T</code></td>
+    <td> <code>T</code> is an endian type or a class type.<p>If <code>T</code> is 
+    an endian type, returns the value of <code>x</code> with the order of bytes 
+    reversed.</p>
+    <p>If <code>T</code> is a class type, the function:</p>
+    <ul>
+      <li>Returns the value of <code>x</code> 
+    with the order of bytes reversed for all data members of types or arrays of 
+    types that meet the <code>EndianReversible</code> requirements, and;</li>
+      <li>Is a non-member function in the same namespace as <code>T</code> that 
+can be found by argument dependent lookup (ADL). </li>
+    </ul>
+    </td>
+  </tr>
+</table>
+<p>&nbsp;</p>
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
+  <tr>
+    <td colspan="2" align="center"><b><code><a name="EndianReversibleInplace">EndianReversibleInplace</a></code></b> 
+    requirements (in addition to <b><code>CopyConstructible</code></b>)</td>
+  </tr>
+  <tr>
+    <td><b>Expression</b></td>
+    <td><b>Requirements</b></td>
+  </tr>
+  <tr>
+    <td valign="top"><code>endian_reverse_inplace(mlx)</code></td>
+    <td> <code>T</code> is an endian type or a class type.<p>If <code>T</code> is 
+    an endian type, reverses the order of bytes in <code>mlx</code>.</p>
+    <p>If <code>T</code> is a class type, the function:</p>
+    <ul>
+      <li>Reverses the order of bytes of all data members of <code>mlx</code> 
+      that have types or arrays of 
+    types that meet the <code>EndianReversible</code> or <code>EndianReversibleInplace</code> 
+      requirements, and;</li>
+      <li>Is a non-member function in the same namespace as <code>T</code> that 
+can be found by argument dependent lookup (ADL).&nbsp; </li>
+    </ul>
+    </td>
+  </tr>
+</table>
+
+<p> [<i>Note:</i> Because there is a function template for <code>endian_reverse_inplace</code> 
+that calls <code>endian_reverse</code>, only <code>endian_reverse</code> 
+is required for a user-defined type to meet the <code>EndianReversibleInplace</code> 
+requirements. Although User-defined types are not required to supply an <code>endian_reverse_inplace</code> 
+function, doing so may improve efficiency. <i>&nbsp;&mdash;end note</i>]</p>
+
+<h4> <a name="Customization-points">Customization points</a> for user-defined types (<a name="UDT">UDT</a>s)</h4>
+
+<p> This subsection describes requirements on the Endian library&#39;s  implementation.</p>
+
+<p> The library&#39;s function templates requiring <code>
+<a href="#EndianReversible">EndianReversible</a></code> are 
+required to perform reversal of endianness if needed by making an unqualified 
+call to <code>endian_reverse()</code>.</p>
+
+<p> The library&#39;s function templates requiring <code>
+<a href="#EndianReversibleInplace">EndianReversibleInplace</a></code> are required to perform reversal of endianness if needed by making an 
+unqualified call to <code>endian_reverse_inplace()</code>.</p>
+
+<p> See <b><code>example/udt_conversion_example.cpp</code></b> for an example user-defined type.</p>
+
+<h3><a name="Functions">Functions</a></h3>
+<pre><a name="endian_reverse"></a>int8_t   endian_reverse(int8_t x) noexcept;
+int16_t  endian_reverse(int16_t x) noexcept;
+int32_t  endian_reverse(int32_t x) noexcept;
+int64_t  endian_reverse(int64_t x) noexcept;
+uint8_t  endian_reverse(uint8_t x) noexcept;
+uint16_t endian_reverse(uint16_t x) noexcept;
+uint32_t endian_reverse(uint32_t x) noexcept;
+uint64_t endian_reverse(uint64_t x) noexcept;</pre>
+<blockquote>
+  <p dir="ltr"><i>Returns:</i> <i><code>x</code></i>, with the order of its 
+  constituent bytes reversed.</p>
+  <p><i>Remarks:</i> The type of <i><code>x</code></i> meets the <code>EndianReversible</code> requirements.</p>
+  <p>[<i>Note:</i> The Boost.Endian library does not provide overloads for the C++ standard library 
+    supplied types. <i>&mdash;end note</i>]</p>
+</blockquote>
+
+<pre>template &lt;class EndianReversible&gt;
+EndianReversible big_to_native(EndianReversible x) noexcept;</pre>
+    <blockquote>
+        <p>
+            <i>Returns:</i> <code>conditional_reverse&lt;order::big, order::native&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversible&gt;
+EndianReversible native_to_big(EndianReversible x) noexcept; </pre>
+<blockquote>
+  <p><i>Returns:</i> <code>conditional_reverse&lt;order::native, order::big&gt;(x)</code>.</p>
+</blockquote>
+<pre>template &lt;class EndianReversible&gt;
+EndianReversible little_to_native(EndianReversible x) noexcept; </pre>
+    <blockquote>
+        <p><i>Returns:</i> <code>conditional_reverse&lt;order::little, order::native&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversible&gt;
+EndianReversible native_to_little(EndianReversible x) noexcept; </pre>
+    <blockquote>
+        <p><i>Returns:</i> <code>conditional_reverse&lt;order::native, order::little&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;order O1, order O2, class EndianReversible&gt;
+EndianReversible conditional_reverse(EndianReversible x) noexcept; </pre>
+    <blockquote>
+        <p><i>Returns:</i> <code>x</code> if <code>O1 == O2,</code> otherwise <code>endian_reverse(x)</code>.</p>
+        <p><i>Remarks: </i>Whether <code>x</code> or <code>endian_reverse(x)</code> is to be returned shall be determined at compile time.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversible&gt;
+EndianReversible conditional_reverse(EndianReversible x,
+      order order1, order order2) noexcept; </pre>
+    <blockquote>
+        <p><i>Returns:</i> <code>order1 == order2 ? x : endian_reverse(x)</code>.</p>
+    </blockquote>
+      
+<pre>template &lt;class EndianReversible&gt;
+void endian_reverse_inplace(EndianReversible&amp; x) noexcept; </pre>
+
+<blockquote>
+        <p><i>Effects:</i> <code>x</code> <code>= endian_reverse(x)</code>.</p>
+    </blockquote>
+
+<pre>template &lt;class EndianReversibleInplace&gt;
+void big_to_native_inplace(EndianReversibleInplace&amp; x) noexcept; </pre>
+<blockquote>
+        <p>
+            <i>Effects:</i> <code>conditional_reverse_inplace&lt;order::big, order::native&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversibleInplace&gt;
+void native_to_big_inplace(EndianReversibleInplace&amp; x) noexcept; </pre>
+<blockquote>
+        <p>
+            <i>Effects:</i> <code>conditional_reverse_inplace&lt;order::native, order::big&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversibleInplace&gt;
+void little_to_native_inplace(EndianReversibleInplace&amp; x) noexcept; </pre>
+<blockquote>
+        <p>
+            <i>Effects:</i> <code>conditional_reverse_inplace&lt;order::little, order::native&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversibleInplace&gt;
+void native_to_little_inplace(EndianReversibleInplace&amp; x) noexcept; </pre>
+<blockquote>
+        <p>
+            <i>Effects:</i> <code>conditional_reverse_inplace&lt;order::native, order::little&gt;(x)</code>.</p>
+    </blockquote>
+<pre>template &lt;order O1, order O2, class EndianReversibleInplace&gt;
+void conditional_reverse_inplace(EndianReversibleInplace&amp; x) noexcept; </pre> 
+<blockquote>
+        <p><i>Effects:</i> None if <code>O1 == O2,</code> otherwise <code>endian_reverse_inplace(x)</code>.</p>
+        <p><i>Remarks: </i>Which effect applies shall be determined at compile time.</p>
+    </blockquote>
+<pre>template &lt;class EndianReversibleInplace&gt;
+void conditional_reverse_inplace(EndianReversibleInplace&amp; x,
+     order order1, order order2) noexcept; </pre>
+
+
+<blockquote>
+        <p><i>Effects: </i>If <code>order1 == order2</code> then <code>endian_reverse_inplace(x)</code>.</p>
+    </blockquote>
+
+
+<h2> <a name="FAQ">FAQ</a></h2>
+
+<p>See the <a href="index.html#FAQ">Endian home page</a> FAQ for a library-wide 
+FAQ.</p>
+
+<p><b>Why are both value returning and modify-in-place functions provided?</b></p>
+
+<blockquote>
+
+<p>Returning the result by value is the standard C and C++ idiom for functions that compute a 
+value from an argument. Modify-in-place functions allow cleaner code in many real-world 
+endian use cases and are more efficient for user-defined types that have 
+members such as string data that do not need to be reversed. Thus both forms are 
+provided.</p>
+
+</blockquote>
+
+<p><b>Why are exact-length 8, 16, 32, and 64-bit integers supported rather than the built-in 
+char, short, int, long, long long, etc?</b></p>
+
+<blockquote>
+
+<p>The primary use case, portable file or network data, needs these de facto 
+standard sizes. Using types that vary with the platform would greatly limit 
+portability for both programs and data.</p>
+
+</blockquote>
+
+<h2><a name="Acknowledgements">Acknowledgements</a></h2><p>Tomas Puverle was instrumental
+in identifying and articulating the need to support endian conversion as separate from
+endian integer types. Phil Endecott suggested the form of the value returning signatures.
+Vicente Botet and other reviewers suggested supporting  user defined types.
+General reverse template implementation approach using std::reverse suggested by Mathias Gaunard.
+Portable implementation approach for 16, 32, and 64-bit integers suggested by tymofey,
+with avoidance of undefined behavior as suggested by Giovanni Piero Deretta,
+and a further refinement suggested by Pyry Jahkola.
+Intrinsic builtins implementation approach for 16, 32, and 64-bit integers suggested by
+several reviewers, and by David Stone, who provided his Boost licensed macro implementation
+that became the starting point for <b><code>boost/endian/detail/intrinsic.hpp</code></b>. 
+Pierre Talbot provided the <code>int8_t endian_reverse()</code> and templated
+<code>endian_reverse_inplace()</code> implementations.</p>
+<hr>
+<p>Last revised: <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->26 March, 2015<!--webbot bot="Timestamp" endspan i-checksum="28922" --></p>
+<p> Copyright Beman Dawes, 2011, 2013</p>
+<p>Distributed under the Boost Software License, Version 1.0. See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/fp_concerns.html b/libs/endian/doc/fp_concerns.html
new file mode 100644
index 0000000..5c5f67c
--- /dev/null
+++ b/libs/endian/doc/fp_concerns.html
@@ -0,0 +1,97 @@
+<html>
+
+<head>
+<meta http-equiv="Content-Language" content="en-us">
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
+<title>Floating Point Concerns</title>
+<link href="styles.css" rel="stylesheet">
+</head>
+
+<body>
+
+<h1>Floating Point Concerns</h1>
+
+<p>Consider this simple implementation of <code>endian_reverse</code>:</p>
+
+<blockquote>
+  <pre>template &lt;class T&gt;
+inline T endian_reverse(T x) BOOST_NOEXCEPT
+{
+  std::reverse(reinterpret_cast&lt;unsigned char*&gt;(&amp;x),
+    reinterpret_cast&lt;unsigned char*&gt;(&amp;x) + sizeof(T));
+  return x;
+}</pre>
+</blockquote>
+<p><b>Under what conditions with this code fail?</b></p>
+<p dir="ltr">It will fail if an object of type <code>T</code> has one or more 
+bit patterns that cause a failure. Failures usually occur when&nbsp; an invalid 
+or otherwise special bit pattern is loaded into or saved from a hardware 
+register.</p>
+<p dir="ltr">The problem could in theory occur with both integers and floating 
+point numbers, but the <a href="http://en.wikipedia.org/wiki/Two's_complement">
+two's complement integers</a> ubiquitous in modern computer architectures do not 
+have any invalid or otherwise special bit patterns that cause failure when 
+byte-wise reversed.</p>
+<p dir="ltr">But floating point numbers are a different story. Even if we limit 
+discussion to IEEE 754 (aka ISO/IEC/IEEE 60559) binary representations of 4 and 
+8 byte sizes, several problems are easy to demonstrate:</p>
+<ul>
+  <li dir="ltr">
+  <p dir="ltr">...</li>
+</ul>
+<h2 dir="ltr">Safe interfaces and possible reference implementations</h2>
+<h3 dir="ltr">In-place interface</h3>
+<blockquote>
+  <pre dir="ltr">template &lt;class T&gt;
+inline void endian_reverse_inplace(T&amp; x)
+{
+  std::reverse(reinterpret_cast&lt;unsigned char*&gt;(&amp;x),
+    reinterpret_cast&lt;unsigned char*&gt;(&amp;x) + sizeof(T));
+}</pre>
+</blockquote>
+<p dir="ltr">This is the same as the current (i.e integer) customization point 
+interface, so there is no need for any change.</p>
+<p dir="ltr"><b>Warning:</b> Even thought <code>x</code> may have had a valid 
+value on the originating platform, after calling this function the value of
+<code>x</code> may differ or be invalid on this platform.</p>
+<h3 dir="ltr">Copy interface</h3>
+<blockquote>
+  <pre dir="ltr">template &lt;class T&gt;
+inline void endian_reverse_copy(const T&amp; from, T&amp; to)
+{
+  std::reverse_copy(reinterpret_cast&lt;const unsigned char*&gt;(&amp;from),
+    reinterpret_cast&lt;const unsigned char*&gt;(&amp;from) + sizeof(T),
+    reinterpret_cast&lt;unsigned char*&gt;(&amp;to));
+}</pre>
+</blockquote>
+<p><b>Warning:</b> Even thought <code>from</code> may have been a valid value on 
+the originating platform, after calling this function the value of <code>to</code> 
+may differ or be invalid on this platform.</p>
+<h3>Return-by-value interface</h3>
+<blockquote>
+  <pre>template &lt;class T&gt;
+inline T endian_reverse_to_native(<span style="background-color: #FFFF00">const</span><span style="background-color: #FFFF00"> T&amp;</span> x) BOOST_NOEXCEPT
+{
+  T tmp;
+  std::reverse_copy(reinterpret_cast&lt;const unsigned char*&gt;(&amp;x),
+    reinterpret_cast&lt;const unsigned char*&gt;(&amp;x) + sizeof(T),
+    reinterpret_cast&lt;unsigned char*&gt;(&amp;tmp));
+  return tmp;
+}</pre>
+</blockquote>
+<p><b>Warning:</b> Even thought <code>x</code> may have had a valid value on the 
+originating platform, the value of returned by this function may differ or be 
+invalid on this platform.</p>
+<h2>Acknowledgements</h2>
+<hr>
+<p>Last revised: <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->27 March, 2015<!--webbot bot="Timestamp" endspan i-checksum="28924" --></p>
+<p> Copyright Beman Dawes, 2015</p>
+<p>Distributed under the Boost Software License, Version 1.0. See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+
+<p>&nbsp;</p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/index.html b/libs/endian/doc/index.html
new file mode 100644
index 0000000..627977d
--- /dev/null
+++ b/libs/endian/doc/index.html
@@ -0,0 +1,616 @@
+<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns="http://www.w3.org/TR/REC-html40">
+
+<head>
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+
+<title>Endian Library</title>
+<link href="styles.css" rel="stylesheet">
+</head>
+
+<body>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
+  <tr>
+    <td width="339">
+<a href="../../../index.html">
+<img src="../../../boost.png" alt="Boost logo" align="middle" border="0" width="277" height="86"></a></td>
+    <td align="middle" width="1253">
+    <b>
+    <font size="6">Endian Library</font></b></td>
+  </tr>
+</table>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
+  bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
+  <tr>
+    <td><b>
+    <a href="index.html">Endian Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="conversion.html">Conversion Functions</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="arithmetic.html">Arithmetic Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="buffers.html">Buffer Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="choosing_approach.html">Choosing Approach</a></b></td>
+  </tr>
+</table>
+<p></p>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
+  <tr>
+    <td width="100%" bgcolor="#D7EEFF" align="center">
+      <i><b>Contents</b></i></td>
+  </tr>
+  <tr>
+    <td width="100%" bgcolor="#E8F5FF">
+<a href="#Abstract">Abstract</a><br>
+<a href="#Introduction-to-endianness">Introduction to endianness</a><br>
+<a href="#Introduction">Introduction to the Boost.Endian library</a><br>
+<a href="#Choosing">Choosing between conversion functions,</a><br>
+  &nbsp;  <a href="#Choosing">buffer types, and  arithmetic types</a><br>
+<a href="#Intrinsic">Built-in support for Intrinsics</a><br>
+<a href="#Performance">Performance</a><br>
+&nbsp;&nbsp;&nbsp;<a href="#Timings">Timings</a><br>
+<a href="#FAQ">Overall FAQ</a><br>
+<a href="#Release-history">Release history</a><br>
+&nbsp;&nbsp;&nbsp;<a href="#Changes-requested-by-formal-review">Changes 
+requested by formal review</a><br>
+&nbsp;&nbsp; <a href="#Other-changes-since-formal-review">Other changes since 
+formal review</a><br>
+<a href="#Compatibility">Compatibility with interim releases</a><br>
+<a href="#C++03-support">C++03 support for C++11 features</a><br>
+<a href="#Future-directions">Future directions</a><br>
+<a href="#Acknowledgements">Acknowledgements</a><br>
+    </td>
+  </tr>
+  </table>
+
+<h2><a name="Abstract">Abstract</a></h2>
+
+<p>Boost.Endian provides facilities to manipulate the 
+<a href="#Introduction-to-endianness">endianness</a> of integers and user-defined types.</p>
+<ul>
+  <li>Three approaches to endianness are supported. Each has a 
+  long history of successful use, and each approach has use cases where it is 
+  preferred over the other approaches.<br>
+&nbsp;</li>
+  <li>Primary uses:<br>
+&nbsp;<ul>
+  <li>Data portability. The Endian library supports binary data exchange, via either external media or network transmission, 
+  regardless of platform endianness.<br>
+&nbsp;</li>
+  <li>Program portability. POSIX-based and 
+  Windows-based operating systems traditionally supply libraries with 
+  non-portable functions to perform endian conversion. There are at least four 
+  incompatible sets of functions in common use. The Endian library is 
+  portable across all C++ platforms.<br>
+&nbsp;</li>
+</ul>
+
+  </li>
+  <li>Secondary use: Minimizing data size via sizes and/or alignments not supported by the 
+  standard C++ arithmetic types.<br>
+  </li>
+</ul>
+
+<div align="center">
+  <center>
+  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="90%">
+    <tr>
+      <td width="100%">
+      <p align="center"><b><font size="4">Notice</font></b></p>
+      <p align="left">This first release (1.58.0) of the Endian library as an 
+      official Boost library removes for floating point type support that was 
+      present in the mini-review pre-release. Floating point types will be 
+      supported in the Boost 1.59.0 release with a slightly modified floating 
+      point conversion interface and implementation that addresses reliability 
+      concerns.</td>
+    </tr>
+  </table>
+  </center>
+</div>
+
+<h2><a name="Introduction-to-endianness">Introduction to endianness</a></h2>
+
+<p>Consider the following code:</p>
+
+<blockquote>
+  <pre>int16_t i = 0x0102;
+FILE * file = fopen(&quot;test.bin&quot;, &quot;wb&quot;);   // binary file!
+fwrite(&amp;i, sizeof(int16_t), 1, file);
+fclose(file);</pre>
+</blockquote>
+<p>On OS X, Linux, or Windows systems with an Intel CPU, a hex dump 
+of the &quot;test.bin&quot; output file produces:</p>
+<blockquote>
+  <p><code>0201</code></p>
+</blockquote>
+<p>On OS X systems with a PowerPC CPU, or Solaris systems with a SPARC CPU, a hex dump of the &quot;test.bin&quot; 
+output file produces:</p>
+<blockquote>
+  <p><code>0102</code></p>
+</blockquote>
+<p>What's happening here is that Intel CPUs order the bytes of an integer with 
+the least-significant byte first, while SPARC CPUs place the most-significant 
+byte first. Some CPUs, such as the PowerPC, allow the operating system to 
+choose which ordering applies.</p>
+<p><a name="definition"></a>Most-significant-byte-first ordering is traditionally called &quot;big endian&quot; 
+ordering and  least-significant-byte-first is traditionally called 
+&quot;little-endian&quot; ordering. The names are derived from
+<a href="http://en.wikipedia.org/wiki/Jonathan_Swift" title="Jonathan Swift">
+Jonathan Swift</a>'s satirical novel <i>
+<a href="http://en.wikipedia.org/wiki/Gulliver's_Travels" title="Gulliver's Travels">
+Gullivers Travels</a></i>, where rival kingdoms opened their soft-boiled eggs 
+at different ends.</p>
+<p>See Wikipedia's
+<a href="http://en.wikipedia.org/wiki/Endianness">Endianness</a> article for an 
+extensive discussion of endianness.</p>
+<p>Programmers can usually ignore endianness, except when reading a core 
+dump on little-endian systems. But programmers  have to deal with endianness  when exchanging binary integers and binary floating point 
+values between computer systems with differing endianness, whether by physical file transfer or over a network. 
+And programmers may also want to use the library when minimizing either internal or 
+external data sizes is advantageous.</p>
+<h2><a name="Introduction">Introduction</a> to the Boost.Endian library</h2>
+
+<p>Boost.Endian provides three different approaches to dealing with 
+ 
+endianness. All three approaches support integers and user-define types (UDTs).</p>
+
+<p>Each approach has a long history of successful use, and each approach has use 
+cases where it is preferred to the other approaches.</p>
+
+<blockquote>
+
+<p><b><a href="conversion.html">Endian conversion functions</a> -</b> The 
+application uses the built-in integer types to hold values, and calls the 
+provided conversion functions to convert byte ordering as needed. Both mutating 
+and non-mutating conversions are supplied, and each comes in unconditional and 
+conditional variants.</p>
+
+<p><b><a href="buffers.html">Endian buffer types</a> -</b> The application uses the provided endian 
+buffer types 
+to hold values, and explicitly converts to and from the built-in integer types.  Buffer sizes of 8, 16, 24, 32, 40, 48, 56, and 64 bits (i.e. 
+1, 2, 3, 4, 5, 6, 7, and 8 bytes) are provided. Unaligned integer buffer types 
+are provided for all sizes, and aligned buffer types are provided for 16, 32, and 
+64-bit sizes. The provided specific types are typedefs for a generic class 
+template that may be used directly for less common use cases.</p>
+
+<p><b><a href="arithmetic.html">Endian arithmetic types</a> -</b> The 
+application uses the provided endian arithmetic types, which supply the same 
+operations as the built-in C++ arithmetic types. All conversions are implicit. 
+Arithmetic sizes of 8, 16, 24, 32, 40, 48, 56, and 64 bits (i.e. 1, 2, 3, 4, 5, 
+6, 7, and 8 bytes) are provided. Unaligned integer types are provided for all 
+sizes and aligned 
+arithmetic types are provided for 16, 32, and 64-bit sizes. The provided 
+specific types are typedefs for a generic class template that may be used 
+directly in generic code of for less common use cases.</p>
+
+</blockquote>
+
+<p>Boost Endian is a header-only library. C++11 features 
+affecting interfaces, such as <code>noexcept</code>, are  used only if available. 
+See <a href="#C++03-support">C++03 support for C++11 features</a> for details.</p>
+
+<h2><a name="Choosing">Choosing</a> between  conversion functions,  buffer types, 
+and  arithmetic types</h2>
+
+<p>This section has been moved to its own <a href="choosing_approach.html">
+Choosing the Approach</a> page. </p>
+
+<h2>Built-in support for <a name="Intrinsic">Intrinsic</a>s</h2>
+<p>Most compilers, including GCC, Clang, and Visual C++, supply  built-in support for byte swapping intrinsics. 
+The Endian library uses these intrinsics when available since they may result in smaller and faster generated code, particularly for 
+optimized 
+builds.</p>
+<p>Defining the macro <code>BOOST_ENDIAN_NO_INTRINSICS</code> will suppress use 
+of the intrinsics. This is useful when a compiler has no intrinsic support or 
+fails to locate the appropriate header, perhaps because it 
+is an older release or has very limited supporting libraries.</p>
+<p>The macro <code>BOOST_ENDIAN_INTRINSIC_MSG</code> is defined as 
+either <code>&quot;no byte swap intrinsics&quot;</code> or a string describing the 
+particular set of intrinsics being used. This is useful for eliminating missing 
+intrinsics as a source of performance issues.</p>
+
+<h2><a name="Performance">Performance</a></h2>
+
+<p>Consider this problem:</p>
+
+<div align="center">
+  <center>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
+  <tr>
+    <td colspan="2">
+    <p align="center"><i><b><a name="Example-1">Example 1</a></b></i></td>
+  </tr>
+  <tr>
+    <td colspan="2"><b><i>Add 100 to a big endian value in a file, then write the 
+    result to a file</i> </b> </td>
+  </tr>
+  <tr>
+    <td><i><b>Endian arithmetic type approach</b></i></td>
+    <td><i><b>Endian conversion function approach</b></i></td>
+  </tr>
+  <tr>
+    <td valign="top">
+    <pre>big_int32_at x;
+
+... read into x from a file ...
+
+x += 100;
+
+... write x to a file ...
+</pre>
+    </td>
+    <td>
+    <pre>  
+int32_t x;
+
+... read into x from a file ...
+
+big_to_native_inplace(x);
+x += 100;
+native_to_big_inplace(x);
+
+... write x to a file ...
+</pre>
+    </td>
+  </tr>
+</table>
+
+  </center>
+</div>
+
+<p><b>There will be no performance difference between the two approaches in 
+optimized builds, 
+regardless of the native endianness of the machine.</b> That&#39;s because optimizing compilers will  generate exactly the same code for each. That conclusion was confirmed by 
+studying the generated assembly code for GCC and Visual C++. Furthermore, time 
+spent doing I/O will determine the speed of this application.</p>
+
+<p>Now consider a slightly different problem:&nbsp; </p>
+
+<div align="center">
+  <center>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
+  <tr>
+    <td colspan="2">
+    <p align="center"><b><i><a name="Example-2">Example 2</a></i></b></td>
+  </tr>
+  <tr>
+    <td colspan="2"><i><b>Add a million values to a big endian value in a file, then write the 
+    result to a file </b></i> </td>
+  </tr>
+  <tr>
+    <td><i><b>Endian arithmetic type approach</b></i></td>
+    <td><i><b>Endian conversion function approach</b></i></td>
+  </tr>
+  <tr>
+    <td valign="top">
+    <pre>big_int32_at x;
+
+... read into x from a file ...
+
+for (int32_t i = 0; i &lt; 1000000; ++i)
+  x += i;
+
+... write x to a file ...
+</pre>
+    </td>
+    <td>
+    <pre>int32_t x;
+
+... read into x from a file ...
+
+big_to_native_inplace(x);
+
+for (int32_t i = 0; i &lt; 1000000; ++i)
+  x += i;
+
+native_to_big_inplace(x);
+
+... write x to a file ...
+</pre>
+    </td>
+  </tr>
+</table>
+
+  </center>
+</div>
+
+<p>With the Endian arithmetic approach, on little endian platforms an implicit conversion from and then back to 
+big endian is done inside the loop. With the Endian conversion function 
+approach, the user has ensured the conversions are done outside the loop, so the 
+code may run more quickly on little endian platforms.</p>
+
+<h3><a name="Timings">Timings</a></h3>
+<p>These tests were run against release builds on a circa 2012 4-core little endian X64 Intel Core i5-3570K 
+CPU @ 3.40GHz under Windows 7.</p>
+
+<p><b>Caveat emptor: The Windows CPU timer has very high granularity. Repeated 
+runs of the same tests often yield considerably different results.</b></p>
+
+<p>See <b>test/loop_time_test.cpp</b> for the actual code and <b>benchmark/Jamfile.v2</b> for the build 
+setup.</p>
+
+
+<div align="center">
+  <center>
+<table border="1" cellpadding="5" cellspacing="0"style="border-collapse: collapse" bordercolor="#111111">
+<tr><td colspan="6" align="center"><b>GNU C++ version 4.8.2 on Linux virtual 
+  machine</b></td></tr>
+<tr><td colspan="6" align="center"><b> Iterations: 10'000'000'000, Intrinsics: __builtin_bswap16, etc.</b></td></tr>
+<tr><td><b>Test Case</b></td>
+<td align="center"><b>Endian<br>arithmetic<br>type</b></td>
+<td align="center"><b>Endian<br>conversion<br>function</b></td>
+</tr>
+<tr><td>16-bit aligned big endian</td><td align="right">8.46 s</td><td align="right">5.28 s</td></tr>
+<tr><td>16-bit aligned little endian</td><td align="right">5.28 s</td><td align="right">5.22 s</td></tr>
+<tr><td>32-bit aligned big endian</td><td align="right">8.40 s</td><td align="right">2.11 s</td></tr>
+<tr><td>32-bit aligned little endian</td><td align="right">2.11 s</td><td align="right">2.10 s</td></tr>
+<tr><td>64-bit aligned big endian</td><td align="right">14.02 s</td><td align="right">3.10 s</td></tr>
+<tr><td>64-bit aligned little endian</td><td align="right">3.00 s</td><td align="right">3.03 s</td></tr>
+
+</table>
+  </center>
+</div>
+<p></p>
+
+<div align="center"> <center>
+<table border="1" cellpadding="5" cellspacing="0"style="border-collapse: collapse" bordercolor="#111111">
+<tr><td colspan="6" align="center"><b>Microsoft Visual C++ version 14.0</b></td></tr>
+<tr><td colspan="6" align="center"><b> Iterations: 10'000'000'000, Intrinsics: cstdlib _byteswap_ushort, etc.</b></td></tr>
+<tr><td><b>Test Case</b></td>
+<td align="center"><b>Endian<br>arithmetic<br>type</b></td>
+<td align="center"><b>Endian<br>conversion<br>function</b></td>
+</tr>
+<tr><td>16-bit aligned big endian</td><td align="right">8.27 s</td><td align="right">5.26 s</td></tr>
+<tr><td>16-bit aligned little endian</td><td align="right">5.29 s</td><td align="right">5.32 s</td></tr>
+<tr><td>32-bit aligned big endian</td><td align="right">8.36 s</td><td align="right">5.24 s</td></tr>
+<tr><td>32-bit aligned little endian</td><td align="right">5.24 s</td><td align="right">5.24 s</td></tr>
+<tr><td>64-bit aligned big endian</td><td align="right">13.65 s</td><td align="right">3.34 s</td></tr>
+<tr><td>64-bit aligned little endian</td><td align="right">3.35 s</td><td align="right">2.73 s</td></tr>
+</table>
+ </center></div>
+
+
+<h2>Overall <a name="FAQ">FAQ</a></h2>
+
+<p><b>Is the implementation header only?</b></p>
+
+<blockquote>
+
+<p>Yes.</p>
+
+</blockquote>
+
+<p><b>Are C++03 compilers supported?</b></p>
+
+<blockquote>
+
+<p>Yes.</p>
+
+</blockquote>
+
+<p><b>Does the implementation use compiler intrinsic built-in byte swapping?</b></p>
+
+<blockquote>
+
+<p>Yes, if available. See <a href="#Intrinsic">Intrinsic built-in support</a>.</p>
+
+</blockquote>
+
+<p><b>Why bother with endianness?</b></p>
+<blockquote>
+<p>Binary data portability is the primary use case.</p>
+</blockquote>
+<p><b>Does endianness have any uses outside of portable binary file or network 
+I/O formats?</b> </p>
+<blockquote>
+<p>Using the unaligned integer types with a size tailored to the application&#39;s 
+needs is a minor secondary use that saves internal or external memory space. For 
+example, using <code>big_int40_buf_t</code> or <code>big_int40_t</code> in a 
+large array saves a lot of space compared to one of the 64-bit types.</p>
+</blockquote>
+<p><b>Why bother with binary I/O? Why not just use C++ Standard Library stream 
+inserters and extractors?</b></p>
+<blockquote>
+<p>Data interchange formats often specify binary arithmetic data.</p>
+<p>Binary arithmetic data is smaller and therefore I/O is faster and file sizes 
+are smaller. Transfer between systems is less expensive.</p>
+<p dir="ltr">Furthermore, binary arithmetic data is of fixed size, and so fixed-size disk 
+records are possible without padding, easing sorting and allowing random access.</p>
+<p dir="ltr">Disadvantages, such as the inability to use text utilities on the 
+resulting files, limit usefulness to applications where the binary I/O 
+advantages are paramount.</p>
+</blockquote>
+
+<p><b>Which is better, big-endian or little-endian?</b></p>
+<blockquote>
+<p>Big-endian tends to be preferred in a networking environment and is a bit 
+more of an industry standard, but little-endian may be preferred for 
+applications that run primarily on x86, x86-64, and other little-endian 
+CPU's. The <a href="http://en.wikipedia.org/wiki/Endian">Wikipedia</a> article 
+gives more pros and cons.</p>
+</blockquote>
+
+<p><b>Why are only big, little, and native endianness supported?</b></p>
+<blockquote>
+<p>These are the only endian schemes that have any practical value today. PDP-11 
+and the other middle endian approaches are interesting historical curiosities 
+but have no relevance to today&#39;s C++ developers.</p>
+</blockquote>
+
+<p><b>Why do both the buffer and arithmetic types exist?</b></p>
+<blockquote>
+<p>Conversions in the buffer types are explicit. Conversions in the arithmetic 
+types are implicit. This fundamental difference is a deliberate design feature 
+that would be lost if the inheritance hierarchy were collapsed.</p>
+<p>The original design provided only arithmetic types. Buffer types were 
+requested during formal review by those wishing total control over when 
+conversion occurs. They also felt that buffer types would be less likely to be 
+misused by maintenance programmers not familiar with the implications of 
+performing a lot of arithmetic operations on the endian arithmetic types.</p>
+</blockquote>
+<p><b>What is gained by using the buffer types rather than always just using the 
+arithmetic types?</b></p>
+<blockquote>
+<p>Assurance than hidden conversions are not performed. This is of overriding 
+importance to users concerned about achieving the ultimate in terms of speed. </p>
+<p>&quot;Always just using the arithmetic types&quot; is fine for other users. When the 
+ultimate in speed needs to be ensured, the arithmetic types can be used in the 
+same design patterns or idioms that would be used for buffer types, resulting in 
+the same code being generated for either types.</p>
+</blockquote>
+
+<p><b>What are the limitations of floating point support?</b></p>
+
+<blockquote>
+
+<p><strike>The only supported types are four-byte <code>float</code> and eight-byte
+<code>double</code>. The only supported format is
+<a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a> (also 
+know as ISO/IEC/IEEE 60559). Systems on which  integer endianness differs from floating point 
+endianness are not supported.</strike></p>
+
+<p>Support for floating point types was removed from Boost 1.58.0 because there 
+was not enough time to resolve reliability concerns. It is expected that 
+floating point support will be available in Boost 1.59.0.</p>
+
+</blockquote>
+
+<p><b>What are the limitations of integer support?</b></p>
+
+<blockquote>
+
+<p>Tests have only been 
+performed on machines that  use two's complement arithmetic. The Endian 
+conversion functions only support 16, 32, and 64-bit aligned integers. The 
+endian types only support 8, 16, 24, 32, 40, 48, 56, and 64-bit unaligned integers, 
+and 8, 16, 32, and 64-bit aligned integers.</p>
+
+</blockquote>
+
+<h2><a name="Release-history">Release history</a></h2>
+<h3><a name="Changes-requested-by-formal-review">Changes requested by formal review</a></h3>
+<p>The library was reworked from top to bottom to accommodate changes requested 
+during the formal review. See <a href="mini_review_topics.html">Mini-Review</a> 
+page for details.</p>
+<h3><a name="Other-changes-since-formal-review">Other changes since formal 
+review</a></h3>
+<ul>
+  <li>Header <code>boost/endian/endian.hpp</code> has been renamed to <code>
+  boost/endian/arithmetic.hpp</code>. Headers 
+  <code>boost/endian/conversion.hpp</code> and <code>boost/endian/buffers.hpp</code> have been 
+  added. 
+  Infrastructure file names were changed accordingly.</li>
+  <li>The endian arithmetic type aliases have been renamed, 
+  using a naming pattern that is consistent for both integer and floating point, 
+  and a consistent set of aliases supplied for the endian buffer types.</li>
+  <li>The unaligned-type alias names still have the <code>_t</code> suffix, but 
+  the aligned-type alias names now have an <code>_at</code> suffix..</li>
+  <li><code>endian_reverse()</code> overloads for <code>int8_t</code> and <code>
+  uint8_t</code> have been added for improved generality. (Pierre Talbot)</li>
+  <li>Overloads of <code>endian_reverse_inplace()</code> have been replaced with a single <code>
+  endian_reverse_inplace()</code> template. (Pierre Talbot)</li>
+  <li>For X86 and X64 architectures, which permit unaligned loads and stores, 
+  unaligned little endian buffer and arithmetic types use regular loads and 
+  stores when the size is exact. This makes unaligned little endian buffer and 
+  arithmetic types significantly more efficient on these architectures. (Jeremy 
+  Maitin-Shepard)</li>
+  <li>C++11 features affecting interfaces, such as <code>noexcept</code>, are now used. 
+  C++03 compilers are still 
+  supported.</li>
+  <li>Acknowledgements have been updated.</li>
+</ul>
+
+<h2><a name="Compatibility">Compatibility</a> with interim releases</h2>
+
+<p>Prior to the official Boost release, class template <code>
+endian_arithmetic</code> has been used for a decade or more with the same 
+functionality but under the name <code>endian</code>. Other names also changed 
+in the official release. If the macro <code>BOOST_ENDIAN_DEPRECATED_NAMES</code> 
+is defined, those old now deprecated names are still supported. However, the 
+class template <code>endian</code> name is only provided for compilers 
+supporting C++11 template aliases. For C++03 compilers, the name will have to be 
+changed to <code>endian_arithmetic</code>.</p>
+
+<p>To support backward header compatibility, deprecated header <code>boost/endian/endian.hpp</code> 
+forwards to <code>boost/endian/arithmetic.hpp</code>. It requires <code>
+BOOST_ENDIAN_DEPRECATED_NAMES</code> be defined. It should only be used while 
+transitioning to the official Boost release of the library as it will be removed 
+in some future release.</p>
+
+<h2><a name="C++03-support">C++03 support</a> for C++11 features</h2>
+
+<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
+  <tr>
+    <td><b>C++11 Feature</b></td>
+    <td><b>Action with C++03 Compilers </b></td>
+  </tr>
+  <tr>
+    <td>Scoped enums </td>
+    <td>Uses header <code class="computeroutput">
+    <a href="http://www.boost.org/libs/core/doc/html/core/scoped_enum.html">
+    <span class="identifier">boost</span><span class="special">/</span><span class="identifier">core</span><span class="special">/</span><span class="identifier">scoped_enum</span><span class="special">.</span><span class="identifier">hpp</span></a></code><span class="identifier"> 
+    to emulate C++11 scoped enums.</span></td>
+  </tr>
+  <tr>
+    <td><code>noexcept</code></td>
+    <td><span class="identifier">Uses BOOST_NOEXCEPT macro, which is defined as 
+    null for compilers not supporting this C++11 feature.</span></td>
+  </tr>
+  <tr>
+    <td>C++11 PODs (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">N2342</a>)</td>
+    <td><span class="identifier">Takes advantage of C++03 compilers that 
+    relax C++03 POD rules, but see Limitations
+    <a href="buffers.html#Limitations">here</a> and
+    <a href="arithmetic.html#Limitations">here</a>. Also see macros for explicit 
+    POD control <a href="buffers.html#Compilation">here</a> and
+    <a href="arithmetic.html#Compilation">here</a>.</span></td>
+  </tr>
+</table>
+
+<h2><a name="Future-directions">Future directions</a></h2>
+
+<p><b>Standardization.</b> The plan is to submit Boost.Endian to the C++ 
+standards committee for possible inclusion in a Technical Specification or the 
+C++ standard itself.</p>
+
+<p><b>Specializations for <code>numeric_limits</code>.</b> Roger Leigh 
+requested that all <code>boost::endian</code> types provide <code>numeric_limits</code> 
+specializations. See <a href="https://github.com/boostorg/endian/issues/4">
+GitHub issue 4</a>.</p>
+
+<p><b>Character buffer support.</b> Peter Dimov pointed out during the 
+mini-review that getting and setting basic arithmetic types (or <code>&lt;cstdint&gt;</code> 
+equivalents) from/to an offset into an array of unsigned char is a common need. 
+See <a href="http://lists.boost.org/Archives/boost/2015/01/219574.php">
+Boost.Endian mini-review posting</a>.</p>
+
+<p><b>Out-of-range detection.</b> Peter Dimov pointed suggested during the 
+mini-review that throwing an exception on buffer values being out-of-range might 
+be desirable. See the end of
+<a href="http://lists.boost.org/Archives/boost/2015/01/219659.php">this posting</a> 
+and subsequent replies.</p>
+
+<h2><a name="Acknowledgements">Acknowledgements</a></h2>
+<p>Comments and suggestions were received from Adder, Benaka Moorthi, 
+Christopher Kohlhoff, Cliff Green, Daniel James, Gennaro Proto, Giovanni Piero 
+Deretta, Gordon Woodhull, dizzy, Hartmut Kaiser, Jason Newton, Jeff Flinn, Jeremy Maitin-Shepard, John Filo, John 
+Maddock, Kim Barrett, Marsh Ray, Martin Bonner, Mathias Gaunard, Matias 
+Capeletto, Neil Mayhew, Nevin Liber, 
+Olaf van der Spek, Paul Bristow, Peter Dimov, Pierre Talbot, Phil Endecott, 
+Philip Bennefall, Pyry Jahkola, 
+Rene Rivera, Robert Stewart, Roger Leigh, Roland Schwarz, Scott McMurray, Sebastian Redl, Tim 
+Blechmann, Tim Moore, tymofey, Tomas Puverle, Vincente Botet, Yuval Ronen and 
+Vitaly Budovsk. Apologies if anyone has been missed.</p>
+<hr>
+<p>Last revised:
+<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->25 March, 2015<!--webbot bot="Timestamp" endspan i-checksum="28920" --></p>
+<p> Copyright Beman Dawes, 2011, 2013</p>
+<p>Distributed under the Boost Software License, Version 1.0. See
+<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/mini_review_topics.html b/libs/endian/doc/mini_review_topics.html
new file mode 100644
index 0000000..d7a7f3c
--- /dev/null
+++ b/libs/endian/doc/mini_review_topics.html
@@ -0,0 +1,150 @@
+<html>
+
+<head>
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>Endian Mini-Review</title>
+</head>
+<link href="styles.css" rel="stylesheet">
+<body>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
+  <tr>
+    <td width="339">
+<a href="../../../index.html">
+<img src="../../../boost.png" alt="Boost logo" align="middle" border="0" width="277" height="86"></a></td>
+    <td align="middle" width="1253">
+    <b>
+    <font size="6">Endian </font></b><font size="6"><b>Mini-Review</b></font></td>
+  </tr>
+</table>
+
+<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
+  bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
+  <tr>
+    <td><b>
+    <a href="index.html">Endian Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="conversion.html">Conversion Functions</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="arithmetic.html">Arithmetic Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="buffers.html">Buffer Types</a>&nbsp;&nbsp;&nbsp;&nbsp;
+    <a href="choosing_approach.html">Choosing Approach</a></b></td>
+  </tr>
+</table>
+<p></p>
+
+<p>The results of the Boost.Endian formal review included a list of issues to be 
+resolved before a mini-review.</p>
+
+<p>The issues are shown in <b>bold</b> below, with the resolution indicated.</p>
+
+  <p><b>1. Common use case scenarios should be developed.</b></p>
+  <blockquote>
+
+  <p>Done. The documentation have been refactored. A page is now devoted to
+  <a href="choosing_approach.html">Choosing the Approach</a> to endianness. See
+  <a href="choosing_approach.html#Use-cases">Use cases</a> for use case 
+  scenarios.</p>
+  </blockquote>
+  <p><b>2. Example programs should be developed for the common use case scenarios.</b></p>
+  <blockquote>
+  <p>Done. See <a href="choosing_approach.html">Choosing the Approach</a>. 
+  Example code has been added throughout.</p>
+  </blockquote>
+  <p><b>3. Documentation should illuminate the differences between endian 
+integer/float type and endian conversion approaches to the common use 
+case scenarios, and provide guidelines for choosing the most appropriate 
+approach in user's applications.</b></p>
+  <blockquote>
+  <p>Done. See <a href="choosing_approach.html">Choosing the Approach</a>.</p>
+  </blockquote>
+  <p><b>4 .Conversion functions supplying results via return should be provided.</b></p>
+  <blockquote>
+  <p>Done. See <a href="conversion.html">ConversionFunctions</a>.</p>
+  </blockquote>
+  <p><b>5. Platform specific performance enhancements such as use of compiler intrinsics or relaxed alignment requirements should be supported.</b></p>
+  <blockquote>
+  <p>Done. Compiler (Clang, GCC, VisualC++, etc.) intrinsics and built-in 
+  functions are used in the implementation where appropriate, as requested. See
+  <a href="index.html#Intrinsic">Built-in support for Intrinsics</a>. See
+  <a href="index.html#Timings">Timings for Example 2</a> to gauge the impact of 
+  intrinsics.</p>
+  </blockquote>
+  <p><b>6. Endian integer (and floating) types should be implemented via the 
+conversion functions. If that can't be done efficiently, consideration 
+should be given to expanding the conversion function signatures to 
+resolve the inefficiencies.</b></p>
+  <blockquote>
+  <p>Done. For the endian types, the implementation uses the endian conversion 
+  functions, and thus the intrinsics, as requested.</p>
+  </blockquote>
+  <p><b>7. Benchmarks that measure performance should be provided. It should be 
+possible to compare platform specific performance enhancements against 
+portable base implementations, and to compare endian integer approaches 
+against endian conversion approaches for the common use case scenarios.</b></p>
+  <blockquote>
+  <p>Done. See <a href="index.html#Timings">Timings for Example 2</a>. The <code>endian/test</code> directory 
+  also contains several additional benchmark and speed test programs.</p>
+  </blockquote>
+  <p><b>8. Float (32-bits) and double (64-bits) should be supported. IEEE 754 is 
+the primary use case.</b></p>
+  <blockquote>
+  <p>Done. The <a href="buffers.html">endian buffer types</a>,&nbsp;
+  <a href="arithmetic.html">endian arithmetic types</a> and
+  <a href="conversion.html">endian conversion functions</a> now support 32-bit (<code>float)</code> 
+  and 64-bit <code>(double)</code> floating point, as requested.</p>
+  </blockquote>
+  <p><b>9. Support for user defined types (UDTs) is desirable, and should be 
+provided where there would be no conflict with the other concerns.</b></p>
+  <blockquote>
+  <p>Done. See <a href="conversion.html#Customization-points">Customization 
+  points for user-defined types (UDTs)</a>.</p>
+  </blockquote>
+  <p><b>10. There is some concern that endian integer/float arithmetic operations 
+might used inadvertently or inappropriately. The impact of adding an endian_buffer 
+  class without arithmetic operations should be investigated.</b></p>
+  <blockquote>
+  <p>Done. The endian types have been decomposed into class template <code>
+  <a href="buffers.html">endian_buffer</a></code> and class template <code>
+  <a href="arithmetic.html">endian_arithmetic</a></code>. Class
+  <code>endian_buffer</code> is a public base class for <code>endian_arithmetic</code>, 
+  and can also be used by users as a stand-alone class.</p>
+  </blockquote>
+  <p><b>11. Stream insertion and extraction of the endian integer/float types should 
+  be documented and included in the test coverage.</b></p>
+  <blockquote>
+  <p>Done. See <a href="buffers.html#Stream-inserter">Stream inserter</a> and
+  <a href="buffers.html#Stream-extractor">Stream extractor</a>.</p>
+  </blockquote>
+  <p><b>12. Binary I/O support that was investigated during development of the Endian 
+  library should be put up for mini-review for inclusion in the Boost I/O 
+  library.</b></p>
+  
+<blockquote>
+  <p>Not done yet. Will be handled as a separate min-review soon after the 
+  Endian mini-review.</p>
+  
+</blockquote>
+  <p><b>13. Other requested changes.</b></p>
+  
+<blockquote>
+  <ul>
+    <li>In addition to the named-endianness conversion functions, functions that perform 
+    compile-time (via template) and run-time (via function argument) dispatch 
+    are now provided.</li>
+    <li><code>order::native</code> is now a synonym for <code>order::big</code> 
+  or <code>order::little</code> according to the endianness of the platform. This reduces the number of template specializations required.</li>
+    <li>Headers have been reorganized to make them easier to read, 
+  with a synopsis at the front and implementation following.</li>
+  </ul>
+</blockquote>
+<hr>
+<p>Last revised:
+<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->19 January, 2015<!--webbot bot="Timestamp" endspan i-checksum="38903" --></p>
+<p> Copyright Beman Dawes, 2014</p>
+<p>Distributed under the Boost Software License, Version 1.0. See
+<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></p>
+  
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/doc/msvc_readme.txt b/libs/endian/doc/msvc_readme.txt
new file mode 100644
index 0000000..88ea31c
--- /dev/null
+++ b/libs/endian/doc/msvc_readme.txt
@@ -0,0 +1,31 @@
+Windows
+-------
+
+Prerequisites
+
+Boost libraries available in boost-root\stage\lib. Example:
+ 
+  cd boost-root
+  .\bootstrap
+  .\b2 --with-system --with-chrono --with-timer link=shared stage
+
+The provided Visual Studio solution (endian/test/msvc/endian.sln) has a property page
+(endian/test/msvc/common.prop) with these Common Properties set (do not include the
+double quotes):
+
+    VC++ Directores|Executable Directories: prefix default value with "..\..\..\..\..\stage\lib;"
+    (Click "Inherit from parent or project defaults" if not checked)
+
+    C/C++|General|Additional Include Directories: prefix default value with "..\..\..\..\..\stage\lib;"
+ 
+    Linker|General|Additional Library Directories: prefix default value with "..\..\..\..\..\stage\lib;"
+
+    C/C++|Preprocessor: prefix default value with "BOOST_ALL_DYN_LINK;"
+
+IMPORTANT: If Preprocessor macros are supplied via a common property page,
+<inherit from parent or project defaults> must be set for each project!
+
+------------------------------------------------------------------------------------------
+Copyright Beman Dawes, 2013
+Distributed under the Boost Software License, Version 1.0.
+See http://www.boost.org/LICENSE_1_0.txt
diff --git a/libs/endian/doc/publish.bat b/libs/endian/doc/publish.bat
new file mode 100644
index 0000000..a8fdb91
--- /dev/null
+++ b/libs/endian/doc/publish.bat
@@ -0,0 +1,8 @@
+copy /y c:\boost\develop\libs\endian\doc\* d:\boost\endian-gh-pages
+pushd d:\boost\endian-gh-pages
+git commit -a -m "copy from develop"
+git push
+popd
+rem Copyright Beman Dawes, 2014
+rem Distributed under the Boost Software License, Version 1.0.
+rem See www.boost.org/LICENSE_1_0.txt
\ No newline at end of file
diff --git a/libs/endian/doc/styles.css b/libs/endian/doc/styles.css
new file mode 100644
index 0000000..2018ec0
--- /dev/null
+++ b/libs/endian/doc/styles.css
@@ -0,0 +1,20 @@
+
+body
+{
+  font-family: arial, sans-serif;
+  max-width: 6.5in;
+  margin: 0px auto;
+  font-size: 85%;
+}
+ ins  {background-color: #CCFFCC;}
+ del  {background-color: #FFCACA;}
+ pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
+ code {font-size: 110%; font-family: "courier new", courier, serif;}
+ table {font-size: 100%;}
+ 
+ /*
+  Copyright Beman Dawes, 2014
+ Distributed under the Boost Software License, Version 1.0.
+ See www.boost.org/LICENSE_1_0.txt
+ */
+ 
\ No newline at end of file
diff --git a/libs/endian/doc/todo_list.html b/libs/endian/doc/todo_list.html
new file mode 100644
index 0000000..fed67d3
--- /dev/null
+++ b/libs/endian/doc/todo_list.html
@@ -0,0 +1,106 @@
+<html>
+
+<head>
+<meta http-equiv="Content-Language" content="en-us">
+<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>Endian Library Do List</title>
+</head>
+
+<body>
+
+<h1>Endian Library TODO List</h1>
+
+<h2>To Do</h2>
+<h2>Format Review Comments</h2>
+<h3 dir="ltr">Interesting</h3>
+<ul>
+  <li dir="ltr">
+  <p dir="ltr">John Filo - &quot;Absolutely. I'd like to see support for float and 
+  double, but<br>
+  even without those additions, I still vote yes.&quot; &quot;For those who deal with 
+  non-native endian data, this library is<br>
+  extremely useful. It automatically eliminates a whole class of common<br>
+  programming errors when dealing with such data.&quot;<br>
+&nbsp;</li>
+  <li dir="ltr">
+  <p dir="ltr">Hartmut Kaiser - &quot;Even if this is not a full review, I would like 
+  to vote YES to include this <br>
+  library into Boost. 
+  <p>Boost.Spirit is using (and shipping) with an older version of this library
+  <br>
+  for several years now and we never had any problems with its usage in <br>
+  Spirit. It is used as the underlying framework for the binary parsers and <br>
+  generators and it is functioning as advertised.</p>
+  <p>As a quick test I replaced the internal (older) version of Boost.Endian in
+  <br>
+  Spirit with the reviewed version. All of Spirits regression tests still <br>
+  pass. &quot;<br>
+&nbsp;</li>
+</ul>
+<h3>Executive summary</h3>
+<ul>
+  <li>Common use case scenarios should be developed.</li>
+  <li>Example programs should be developed for the common use case scenarios.</li>
+  <li>Documentation should illuminate the differences between endian 
+  integer/float type and endian conversion approaches to the common use case 
+  scenarios, and provide guidelines for choosing the most appropriate approach 
+  for user's applications.</li>
+  <li>Conversion functions supplying results via <code>return</code> should be 
+  provided.</li>
+  <li>Platform specific performance enhancements such as use of compiler 
+  intrinsics or relaxed alignment requirements should be supported.</li>
+  <li>Endian integer (and floating) types should be implemented via the 
+  conversion functions. If that can't be done efficiently, consideration should 
+  be given to expanding the conversion function signatures to resolve the 
+  inefficiencies.</li>
+  <li>Benchmarks that measure performance should be provided. It should be 
+  possible to compare platform specific performance enhancements against 
+  portable base implementations, and to compare endian integer approaches 
+  against endian conversion approaches for the common use case scenarios.</li>
+  <li>Float (32-bits) and double (64-bits) should be supported. IEEE 754 is the 
+  primary use case.</li>
+  <li>Support for user defined types (UDTs) is desirable, and should be 
+  supported where there would be no conflict with the other concerns.</li>
+  <li>There is some concern that endian integer/float arithmetic operations 
+  might used 
+  inadvertently or inappropriately. The impact of adding an endian_buffer class without arithmetic 
+  operations should be investigated.</li>
+  <li>Stream insertion and extraction of the endian integer/float types should 
+  be documented and included in the test coverage.</li>
+  <li>Binary I/O support that was investigated during development of the Endian 
+  library should be put up for min-review for inclusion in the Boost I/O 
+  library.</li>
+</ul>
+<h3>Docs</h3>
+<ul>
+  <li>one other point ... the help file seems to directly link to the c++ 
+  headers.<br>
+  this should be changed:<br>
+  <br>
+  * some browsers (at least chromium) will not display the header when clicking<br>
+  &nbsp;the link, but will save them on disk.<br>
+  <br>
+  * providing a direct link to the source code from the docs implies that the<br>
+  &nbsp;user will get some information that are necessary to use the library by<br>
+  &nbsp;reading the sources. imo, this is not the case for using boost.endian.<br>
+  <br>
+  * if a user opens integer.hpp, the first 60 lines just contain copyright, some<br>
+  &nbsp;historical notes, compiler-specific stuff, includes and ifdefs. imo, this is<br>
+  &nbsp;the implementation part, which should not be exposed to a user.<br>
+  <br>
+  so i'd suggest to completely remove the links to the c++ headers.<br>
+&nbsp;</li>
+</ul>
+<hr>
+<p>Last revised:
+<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->17 January, 2015<!--webbot bot="Timestamp" endspan i-checksum="38899" --></p>
+<p> Copyright Beman Dawes, 2012</p>
+<p>Distributed under the Boost Software License, Version 1.0. See
+<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
+<p>&nbsp;</p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/libs/endian/example/conversion_use_case.cpp b/libs/endian/example/conversion_use_case.cpp
new file mode 100644
index 0000000..76329bb
--- /dev/null
+++ b/libs/endian/example/conversion_use_case.cpp
@@ -0,0 +1,51 @@
+//  endian/example/conversion_use_case.cpp 
+
+//  Copyright Beman Dawes 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  This program reads a binary file of fixed length records, with a format defined
+//  in a header file supplied by a third-party. The records inserted into a vector,
+//  and the vector is sorted. The sorted records are then written to an output file.
+
+//  Full I/O error testing omitted for brevity, So don't try this at home.
+
+#include "third_party_format.hpp"
+#include <boost/endian/conversion.hpp>
+#include <vector>
+#include <fstream>
+#include <algorithm>
+#include <iostream>
+
+using third_party::record;
+
+int main()
+{
+  std::ifstream in("data.bin", std::ios::binary);
+  if (!in) { std::cout << "Could not open data.bin\n"; return 1; }
+
+  std::ofstream out("sorted-data.bin", std::ios::binary);
+  if (!out) { std::cout << "Could not open sorted-data.bin\n"; return 1; }
+
+  record rec;
+  std::vector<record> recs;
+
+  while (!in.eof())  // read each record
+  {
+    in.read((char*)&rec, sizeof(rec));
+    rec.balance = boost::endian::big_to_native(rec.balance);  // reverse if needed
+    recs.push_back(rec);
+  }
+
+  std::sort(recs.begin(), recs.end(),  // decending sort by balance
+    [](const record& lhs, const record& rhs) -> bool
+      { return lhs.balance > rhs.balance; });
+
+  for (auto &out_rec : recs)  // write each record
+  {
+    out_rec.balance = boost::endian::native_to_big(rec.balance);  // reverse if needed
+    out.write((const char*)&out_rec, sizeof(out_rec));
+  }
+    
+}
diff --git a/libs/endian/example/endian_example.cpp b/libs/endian/example/endian_example.cpp
new file mode 100644
index 0000000..b9e17ec
--- /dev/null
+++ b/libs/endian/example/endian_example.cpp
@@ -0,0 +1,75 @@
+// endian_example.cpp  -------------------------------------------------------//
+
+//  Copyright Beman Dawes, 2006
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//----------------------------------------------------------------------------//
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include <iostream>
+#include <cstdio>
+#include <boost/endian/buffers.hpp>
+#include <boost/static_assert.hpp>
+
+using namespace boost::endian;
+
+namespace 
+{
+  //  This is an extract from a very widely used GIS file format. Why the designer
+  //  decided to mix big and little endians in the same file is not known. But
+  //  this is a real-world format and users wishing to write low level code
+  //  manipulating these files have to deal with the mixed endianness.
+
+  struct header
+  {
+    big_int32_buf_at     file_code;
+    big_int32_buf_at     file_length;
+    little_int32_buf_at  version;
+    little_int32_buf_at  shape_type;
+  };
+
+  const char* filename = "test.dat";
+}
+
+int main(int, char* [])
+{
+  header h;
+  
+  BOOST_STATIC_ASSERT(sizeof(h) == 16U);  // reality check
+
+  h.file_code   = 0x01020304;
+  h.file_length = sizeof(header);
+  h.version     = 1;
+  h.shape_type  = 0x01020304;
+
+  //  Low-level I/O such as POSIX read/write or <cstdio> fread/fwrite is sometimes
+  //  used for binary file operations when ultimate efficiency is important.
+  //  Such I/O is often performed in some C++ wrapper class, but to drive home the
+  //  point that endian integers are often used in fairly low-level code that
+  //  does bulk I/O operations, <cstdio> fopen/fwrite is used for I/O in this example.
+
+  std::FILE* fi = std::fopen(filename, "wb");  // MUST BE BINARY
+  
+  if (!fi)
+  {
+    std::cout << "could not open " << filename << '\n';
+    return 1;
+  }
+
+  if (std::fwrite(&h, sizeof(header), 1, fi)!= 1)
+  {
+    std::cout << "write failure for " << filename << '\n';
+    return 1;
+  }
+
+  std::fclose(fi);
+
+  std::cout << "created file " << filename << '\n';
+
+  return 0;
+}
diff --git a/libs/endian/example/third_party_format.hpp b/libs/endian/example/third_party_format.hpp
new file mode 100644
index 0000000..d647283
--- /dev/null
+++ b/libs/endian/example/third_party_format.hpp
@@ -0,0 +1,19 @@
+//  endian/example/third_party_format.hpp
+
+//  Copyright Beman Dawes 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+#include <cstdint>
+
+namespace third_party
+{
+    struct record
+    {
+      uint32_t   id;       // big endian
+      int32_t    balance;  // big endian
+
+      // ...  data members whose endianness is not a concern
+    };
+}
diff --git a/libs/endian/example/udt_conversion_example.cpp b/libs/endian/example/udt_conversion_example.cpp
new file mode 100644
index 0000000..b0a6d08
--- /dev/null
+++ b/libs/endian/example/udt_conversion_example.cpp
@@ -0,0 +1,79 @@
+//  udt_conversion_example.cpp  --------------------------------------------------------//
+
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include <boost/endian/conversion.hpp>
+#include <iostream>
+#include <cstring>
+
+using namespace boost::endian;
+using std::cout;
+using std::endl;
+using boost::int32_t;
+using boost::int64_t;
+
+namespace user
+{
+  class UDT
+  {
+  public:
+    UDT() : id_(0), value_(0) {desc_[0] = '\0';}
+    UDT(int32_t id, int64_t value, const char* desc) : id_(id), value_(value)
+    {
+      std::strncpy(desc_, desc, sizeof(desc_)-1);
+      desc_[sizeof(desc_)-1] = '\0';
+    }
+    int32_t     id() const          {return id_;}
+    int64_t     value() const       {return value_;}
+    const char* desc() const        {return desc_;}
+    void        id(int32_t x)       {id_ = x;}
+    void        value(int64_t v)    {value_ = v;}
+    void        desc(const char* s)
+    {
+      std::strncpy(desc_, s, sizeof(desc_)-1);
+      desc_[sizeof(desc_-1)] = '\0';
+    }
+
+    friend void endian_reverse_inplace(UDT&);
+
+  private:
+    int32_t id_;
+    int64_t value_;
+    char    desc_[56];  // '/0'
+  };
+
+  void endian_reverse_inplace(UDT& x)
+  {
+    boost::endian::endian_reverse_inplace(x.id_);
+    boost::endian::endian_reverse_inplace(x.value_);
+  }
+}
+
+int main(int, char* [])
+{
+  user::UDT x(1, 123456789012345LL, "Bingo!");
+
+  //cout << std::hex;
+  cout << "(1) " << x.id() << ' ' << x.value() << ' ' << x.desc() << endl;
+
+  user::endian_reverse_inplace(x);
+  cout << "(2) " << x.id() << ' ' << x.value() << ' ' << x.desc() << endl;
+
+  endian_reverse_inplace(x);
+  cout << "(3) " << x.id() << ' ' << x.value() << ' ' << x.desc() << endl;
+
+  conditional_reverse_inplace<order::little, order::big>(x);
+  cout << "(4) " << x.id() << ' ' << x.value() << ' ' << x.desc() << endl;
+
+  conditional_reverse_inplace(x, order::big, order::little);
+  cout << "(5) " << x.id() << ' ' << x.value() << ' ' << x.desc() << endl;
+}
+
+#include <boost/endian/detail/disable_warnings_pop.hpp>
diff --git a/libs/endian/example/use_cases.cpp b/libs/endian/example/use_cases.cpp
new file mode 100644
index 0000000..471c633
--- /dev/null
+++ b/libs/endian/example/use_cases.cpp
@@ -0,0 +1,152 @@
+//  endian/example/uses_cases.cpp  -----------------------------------------------------//
+
+//  Copyright Beman Dawes 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+#ifndef _SCL_SECURE_NO_WARNINGS
+# define _SCL_SECURE_NO_WARNINGS
+#endif
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+# define _CRT_SECURE_NO_WARNINGS
+#endif
+
+
+#include <boost/endian/conversion.hpp>
+#include <boost/endian/buffers.hpp>
+#include <boost/endian/arithmetic.hpp>
+#include <iostream>
+
+using namespace boost::endian;
+
+using std::cout;
+using std::endl;
+
+
+
+
+  { // Use case 2 - Endian buffer types
+
+    struct Record
+    {
+      big_ubuf32_t count;  // big endian
+      big_buf32_t  value;  // big endian
+    };
+
+    Record rec;
+
+    read(&rec, sizeof(Record));
+
+    uint32_t count = rec.count.value();
+    int32_t value = rec.value.value();
+
+    ++count;
+    value += fee;
+
+    rec.count = count;
+    rec.value = value;
+
+    write(&rec, sizeof(Record));
+  }
+
+  { // Use case 3a - Endian arithmetic types
+
+    struct Record
+    {
+      big_uint32_t count;  // big endian
+      big_int32_t  value;  // big endian
+    };
+
+    Record rec;
+
+    read(&rec, sizeof(Record));
+
+    ++rec.count;
+    rec.value += fee;
+
+    write(&rec, sizeof(Record));
+  }
+
+  { // Use case 3b - Endian arithmetic types
+
+    struct Record
+    {
+      big_uint32_t count;  // big endian
+      big_int32_t  value;  // big endian
+    };
+
+    Record rec;
+
+    read(&rec, sizeof(Record));
+
+    uint32_t count = rec.count;
+    int32_t value = rec.value;
+
+    ++count;
+    value += fee;
+
+    rec.count = count;
+    rec.value = value;
+
+    write(&rec, sizeof(Record));
+  }
+
+  //  Recommended approach when conversion time is not a concern
+  //
+  //  Conversion time is not a concert with this application because the minimum
+  //  possible number of conversions is performed and because I/O time will be
+  //  much greater than conversion time.
+
+  {
+    struct Record
+    {
+      big_uint32_t count;  // big endian
+      big_int32_t  value;  // big endian
+    };
+
+    Record rec;
+
+    read(&rec, sizeof(Record));
+
+    ++rec.count;
+    rec.value += fee;
+
+    write(&rec, sizeof(Record));
+  }
+
+//  Recommended approach when conversion time is a concern
+  //
+  //  Conversion time is a concert with this application because (1) any conversions
+  //  performed in the loop will consume a great deal of time and because (2) 
+  //  computation time will be much greater than I/O time.
+
+  {
+    struct Record
+    {
+      big_uint32_t count;  // big endian
+      big_int32_t  value;  // big endian
+    };
+
+    Record rec;
+
+    read(&rec, sizeof(Record));
+
+    uint32_t count = rec.count;
+    int32_t value = rec.value;
+
+    for (long long i = 0; i < several_gazillion; ++i)  // (1)
+    {
+      ... immensely complex computation using rec variables many times // (2)
+    }
+
+    rec.count = count;
+    rec.value = value;
+
+    write(&rec, sizeof(Record));
+  }
+
+}
diff --git a/libs/endian/index.html b/libs/endian/index.html
new file mode 100644
index 0000000..3ebbb5a
--- /dev/null
+++ b/libs/endian/index.html
@@ -0,0 +1,14 @@
+<html>
+<head>
+<meta http-equiv="refresh" content="0; URL=doc/index.html">
+</head>
+<body>
+Automatic redirection failed, please go to
+<a href="doc/index.html">doc/index.html</a>.&nbsp;<hr>
+<p><font size="2"> Copyright Beman Dawes, 2001</font></p>
+<p><font size="2">Distributed under the Boost Software License, Version 1.0. 
+(See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a>)
+</font>
+</p>
+</body>
+</html>
\ No newline at end of file
diff --git a/libs/endian/meta/libraries.json b/libs/endian/meta/libraries.json
new file mode 100644
index 0000000..d4f444b
--- /dev/null
+++ b/libs/endian/meta/libraries.json
@@ -0,0 +1,16 @@
+{
+    "key": "endian",
+    "name": "Endian",
+    "authors": [
+        "Beman Dawes"
+    ],
+    "maintainers": [
+        "Beman Dawes <bdawes -at- acm.org>"
+    ],
+    "description": "Types and conversion functions for correct byte ordering and more regardless of processor endianness.",
+    "category": [
+        "IO",
+        "Math",
+        "Miscellaneous"
+    ]
+}
diff --git a/libs/endian/test/Jamfile.v2 b/libs/endian/test/Jamfile.v2
new file mode 100644
index 0000000..16d796a
--- /dev/null
+++ b/libs/endian/test/Jamfile.v2
@@ -0,0 +1,28 @@
+# Boost Endian Library test Jamfile
+
+# Copyright Beman Dawes 2006, 2013
+
+# Distributed under the Boost Software License, Version 1.0.
+# See http://www.boost.org/LICENSE_1_0.txt
+
+# See library home page at http://www.boost.org/libs/endian
+
+project
+    : requirements
+      <toolset>msvc:<asynch-exceptions>on
+    ;
+   
+   test-suite "endian"
+       :
+         [ run buffer_test.cpp # sources
+           : # command line
+           : # input files
+           : # requirements
+           : # target name
+         ]
+         [ run endian_test.cpp ]
+         [ run endian_operations_test.cpp ]
+         [ run endian_in_union_test.cpp ]
+         [ run conversion_test.cpp ]
+#         [ run floating_point_test.cpp : : : <test-info>always_show_run_output ]
+       ;
diff --git a/libs/endian/test/benchmark.cpp b/libs/endian/test/benchmark.cpp
new file mode 100644
index 0000000..d3389cd
--- /dev/null
+++ b/libs/endian/test/benchmark.cpp
@@ -0,0 +1,233 @@
+//  benchmark.cpp  ---------------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2011
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+#ifndef _SCL_SECURE_NO_WARNINGS
+# define _SCL_SECURE_NO_WARNINGS
+#endif
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+# define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#include <cstdlib>
+#include <boost/endian/conversion.hpp>
+#include <boost/random.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/timer/timer.hpp>
+#include <iostream>
+#include <string>
+
+using namespace boost;
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::vector;
+
+namespace
+{
+  std::string command_args;
+  long long n_cases;
+  int places = 2;
+  bool verbose (false);
+
+#ifndef BOOST_TWO_ARG
+  typedef int32_t (*timee_func)(int32_t);
+#else
+  typedef void (*timee_func)(int32_t, int32_t&);
+#endif
+
+  typedef  boost::timer::nanosecond_type nanosecond_t;
+ 
+//--------------------------------------------------------------------------------------//
+
+  nanosecond_t benchmark(timee_func timee, const char* msg,
+    nanosecond_t overhead = 0)
+  //  Returns: total cpu time (i.e. system time + user time)
+  {                                               
+    if (verbose)                                  
+      cout << "\nRunning benchmark..." << endl;   
+    int64_t sum = 0;                              
+    boost::timer::cpu_times times;
+    nanosecond_t cpu_time;
+    boost::timer::auto_cpu_timer t(places);                  
+                                                
+    for (long long i = n_cases; i; --i)                 
+    {                                             
+#   ifndef BOOST_TWO_ARG
+      sum += timee(static_cast<int32_t>(i)) ;                              
+#   else
+      int32_t y;
+      timee(static_cast<int32_t>(i), y);
+      sum += y;
+#   endif
+    }
+    t.stop();
+    times = t.elapsed();
+    cpu_time = (times.system + times.user) - overhead;
+    const long double sec = 1000000000.0L;
+    cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
+    cout.precision(places);
+    cout << msg << " " << cpu_time / sec << endl;                                 
+                                                
+    if (verbose)                                  
+    { 
+      t.report();
+      cout << "  Benchmark complete\n"            
+              "    sum is " << sum << endl;       
+    }
+    return cpu_time;
+  }
+
+  void process_command_line(int argc, char * argv[])
+  {
+    for (int a = 0; a < argc; ++a)
+    {
+      command_args += argv[a];
+      if (a != argc-1)
+        command_args += ' ';
+    }
+
+    cout << command_args << '\n';;
+
+    if (argc >=2)
+#ifndef _MSC_VER
+      n_cases = std::atoll(argv[1]);
+#else
+      n_cases = _atoi64(argv[1]);
+#endif
+
+    for (; argc > 2; ++argv, --argc) 
+    {
+      if ( *(argv[2]+1) == 'p' )
+        places = atoi( argv[2]+2 );
+      else if ( *(argv[2]+1) == 'v' )
+        verbose = true;
+      else
+      {
+        cout << "Error - unknown option: " << argv[2] << "\n\n";
+        argc = -1;
+        break;
+      }
+    }
+
+    if (argc < 2) 
+    {
+      cout << "Usage: benchmark n [Options]\n"
+              "  The argument n specifies the number of test cases to run\n"
+              "  Options:\n"
+              "   -v       Verbose messages\n"
+              "   -p#      Decimal places for times; default -p" << places << "\n";
+      return std::exit(1);
+    }
+  }
+
+  inline void inplace(int32_t& x)
+  {
+    x =  (static_cast<uint32_t>(x) << 24)
+      | ((static_cast<uint32_t>(x) << 8) & 0x00ff0000)
+      | ((static_cast<uint32_t>(x) >> 8) & 0x0000ff00)
+      | (static_cast<uint32_t>(x) >> 24);
+  }
+
+  inline int32_t by_return(int32_t x)
+  {
+    return (static_cast<uint32_t>(x) << 24)
+      | ((static_cast<uint32_t>(x) << 8) & 0x00ff0000)
+      | ((static_cast<uint32_t>(x) >> 8) & 0x0000ff00)
+      | (static_cast<uint32_t>(x) >> 24);
+  }
+
+  inline int32_t by_return_intrinsic(int32_t x)
+  {
+    return BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(static_cast<uint32_t>(x));
+  }
+
+  inline int32_t by_return_pyry(int32_t x)
+  {
+    uint32_t step16;
+    step16 = static_cast<uint32_t>(x) << 16 | static_cast<uint32_t>(x) >> 16;
+    return
+        ((static_cast<uint32_t>(step16) << 8) & 0xff00ff00)
+      | ((static_cast<uint32_t>(step16) >> 8) & 0x00ff00ff);
+  }
+
+  inline int32_t two_operand(int32_t x, int32_t& y)
+  {
+    return y = ((x << 24) & 0xff000000) | ((x << 8) & 0x00ff0000) | ((x >> 24) & 0x000000ff)
+      | ((x >> 8) & 0x0000ff00);
+  }
+
+  inline int32_t modify_noop(int32_t x)
+  {
+    int32_t v(x);
+    return v;
+  }
+
+  inline int32_t modify_inplace(int32_t x)
+  {
+    int32_t v(x);
+    inplace(v);
+    return v;
+  }
+
+  inline int32_t modify_by_return(int32_t x)
+  {
+    int32_t v(x);
+    return by_return(v);
+  }
+
+  inline int32_t modify_by_return_pyry(int32_t x)
+  {
+    int32_t v(x);
+    return by_return_pyry(v);
+  }
+
+  inline int32_t modify_by_return_intrinsic(int32_t x)
+  {
+    int32_t v(x);
+    return by_return_intrinsic(v);
+  }
+
+  inline void non_modify_assign(int32_t x, int32_t& y)
+  {
+    y = x;
+  }
+
+  inline void non_modify_two_operand(int32_t x, int32_t& y)
+  {
+    two_operand(x, y);
+  }
+
+  inline void non_modify_by_return(int32_t x, int32_t& y)
+  {
+    y = by_return(x);
+  }
+
+} // unnamed namespace
+
+//-------------------------------------- main()  ---------------------------------------//
+
+int main(int argc, char * argv[]) 
+{
+  process_command_line(argc, argv);
+
+  nanosecond_t overhead;
+
+#ifndef BOOST_TWO_ARG
+  overhead = benchmark(modify_noop, "modify no-op");
+  benchmark(modify_inplace, "modify in place"/*, overhead*/);
+  benchmark(modify_by_return, "modify by return"/*, overhead*/);
+  benchmark(modify_by_return_pyry, "modify by return_pyry"/*, overhead*/);
+  benchmark(modify_by_return_intrinsic, "modify by return_intrinsic"/*, overhead*/);
+#else
+  overhead = benchmark(non_modify_assign, "non_modify_assign     ");
+  benchmark(non_modify_two_operand,       "non_modify_two_operand", overhead);
+  benchmark(non_modify_by_return,         "non_modify_by_return  ", overhead);
+#endif
+
+  return 0;
+}
diff --git a/libs/endian/test/buffer_test.cpp b/libs/endian/test/buffer_test.cpp
new file mode 100644
index 0000000..a04396e
--- /dev/null
+++ b/libs/endian/test/buffer_test.cpp
@@ -0,0 +1,183 @@
+//  buffer_test.cpp  -------------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2014
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//--------------------------------------------------------------------------------------//
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+//#define BOOST_ENDIAN_LOG
+#include <boost/endian/buffers.hpp>
+#include <boost/detail/lightweight_main.hpp>
+#include <boost/core/lightweight_test.hpp>
+#include <boost/cstdint.hpp>
+#include <iostream>
+#include <sstream>
+
+using namespace boost::endian;
+using std::cout;
+using std::endl;
+
+namespace
+{
+
+  //  check_size  ------------------------------------------------------------//
+
+  void check_size()
+  {
+
+    BOOST_TEST_EQ(sizeof(big_int8_buf_t), 1u);
+    BOOST_TEST_EQ(sizeof(big_int16_buf_t), 2u);
+    BOOST_TEST_EQ(sizeof(big_int24_buf_t), 3u);
+    BOOST_TEST_EQ(sizeof(big_int32_buf_t), 4u);
+    BOOST_TEST_EQ(sizeof(big_int40_buf_t), 5u);
+    BOOST_TEST_EQ(sizeof(big_int48_buf_t), 6u);
+    BOOST_TEST_EQ(sizeof(big_int56_buf_t), 7u);
+    BOOST_TEST_EQ(sizeof(big_int64_buf_t), 8u);
+
+    BOOST_TEST_EQ(sizeof(big_uint8_buf_t), 1u);
+    BOOST_TEST_EQ(sizeof(big_uint16_buf_t), 2u);
+    BOOST_TEST_EQ(sizeof(big_uint24_buf_t), 3u);
+    BOOST_TEST_EQ(sizeof(big_uint32_buf_t), 4u);
+    BOOST_TEST_EQ(sizeof(big_uint40_buf_t), 5u);
+    BOOST_TEST_EQ(sizeof(big_uint48_buf_t), 6u);
+    BOOST_TEST_EQ(sizeof(big_uint56_buf_t), 7u);
+    BOOST_TEST_EQ(sizeof(big_uint64_buf_t), 8u);
+
+    BOOST_TEST_EQ(sizeof(little_int8_buf_t), 1u);
+    BOOST_TEST_EQ(sizeof(little_int16_buf_t), 2u);
+    BOOST_TEST_EQ(sizeof(little_int24_buf_t), 3u);
+    BOOST_TEST_EQ(sizeof(little_int32_buf_t), 4u);
+    BOOST_TEST_EQ(sizeof(little_int40_buf_t), 5u);
+    BOOST_TEST_EQ(sizeof(little_int48_buf_t), 6u);
+    BOOST_TEST_EQ(sizeof(little_int56_buf_t), 7u);
+    BOOST_TEST_EQ(sizeof(little_int64_buf_t), 8u);
+
+    BOOST_TEST_EQ(sizeof(little_uint8_buf_t), 1u);
+    BOOST_TEST_EQ(sizeof(little_uint16_buf_t), 2u);
+    BOOST_TEST_EQ(sizeof(little_uint24_buf_t), 3u);
+    BOOST_TEST_EQ(sizeof(little_uint32_buf_t), 4u);
+    BOOST_TEST_EQ(sizeof(little_uint40_buf_t), 5u);
+    BOOST_TEST_EQ(sizeof(little_uint48_buf_t), 6u);
+    BOOST_TEST_EQ(sizeof(little_uint56_buf_t), 7u);
+    BOOST_TEST_EQ(sizeof(little_uint64_buf_t), 8u);
+
+    BOOST_TEST_EQ(sizeof(native_int8_buf_t), 1u);
+    BOOST_TEST_EQ(sizeof(native_int16_buf_t), 2u);
+    BOOST_TEST_EQ(sizeof(native_int24_buf_t), 3u);
+    BOOST_TEST_EQ(sizeof(native_int32_buf_t), 4u);
+    BOOST_TEST_EQ(sizeof(native_int40_buf_t), 5u);
+    BOOST_TEST_EQ(sizeof(native_int48_buf_t), 6u);
+    BOOST_TEST_EQ(sizeof(native_int56_buf_t), 7u);
+    BOOST_TEST_EQ(sizeof(native_int64_buf_t), 8u);
+
+    BOOST_TEST_EQ(sizeof(native_uint8_buf_t), 1u);
+    BOOST_TEST_EQ(sizeof(native_uint16_buf_t), 2u);
+    BOOST_TEST_EQ(sizeof(native_uint24_buf_t), 3u);
+    BOOST_TEST_EQ(sizeof(native_uint32_buf_t), 4u);
+    BOOST_TEST_EQ(sizeof(native_uint40_buf_t), 5u);
+    BOOST_TEST_EQ(sizeof(native_uint48_buf_t), 6u);
+    BOOST_TEST_EQ(sizeof(native_uint56_buf_t), 7u);
+    BOOST_TEST_EQ(sizeof(native_uint64_buf_t), 8u);
+
+    BOOST_TEST_EQ(sizeof(big_int8_buf_at), 1u);
+    BOOST_TEST_EQ(sizeof(big_int16_buf_at), 2u);
+    BOOST_TEST_EQ(sizeof(big_int32_buf_at), 4u);
+    BOOST_TEST_EQ(sizeof(big_int64_buf_at), 8u);
+
+    BOOST_TEST_EQ(sizeof(big_uint8_buf_at), 1u);
+    BOOST_TEST_EQ(sizeof(big_uint16_buf_at), 2u);
+    BOOST_TEST_EQ(sizeof(big_uint32_buf_at), 4u);
+    BOOST_TEST_EQ(sizeof(big_uint64_buf_at), 8u);
+
+    BOOST_TEST_EQ(sizeof(little_int8_buf_at), 1u);
+    BOOST_TEST_EQ(sizeof(little_int16_buf_at), 2u);
+    BOOST_TEST_EQ(sizeof(little_int32_buf_at), 4u);
+    BOOST_TEST_EQ(sizeof(little_int64_buf_at), 8u);
+
+    BOOST_TEST_EQ(sizeof(little_uint8_buf_at), 1u);
+    BOOST_TEST_EQ(sizeof(little_uint16_buf_at), 2u);
+    BOOST_TEST_EQ(sizeof(little_uint32_buf_at), 4u);
+    BOOST_TEST_EQ(sizeof(little_uint64_buf_at), 8u);
+  } // check_size
+
+  //  test_inserter_and_extractor  -----------------------------------------------------//
+
+  void test_inserter_and_extractor()
+  {
+    std::cout << "test inserter and extractor..." << std::endl;
+
+    big_uint64_buf_t bu64(0x010203040506070ULL);
+    little_uint64_buf_t lu64(0x010203040506070ULL);
+
+    boost::uint64_t x;
+
+    std::stringstream ss;
+
+    ss << bu64;
+    ss >> x;
+    BOOST_TEST_EQ(x, 0x010203040506070ULL);
+
+    ss.clear();
+    ss << lu64;
+    ss >> x;
+    BOOST_TEST_EQ(x, 0x010203040506070ULL);
+
+    ss.clear();
+    ss << 0x010203040506070ULL;
+    big_uint64_buf_t bu64z(0);
+    ss >> bu64z;
+    BOOST_TEST_EQ(bu64z.value(), bu64.value());
+
+    ss.clear();
+    ss << 0x010203040506070ULL;
+    little_uint64_buf_t lu64z(0);
+    ss >> lu64z;
+    BOOST_TEST_EQ(lu64z.value(), lu64.value());
+
+    std::cout << "test inserter and extractor complete" << std::endl;
+
+  }
+
+}  // unnamed namespace
+
+//--------------------------------------------------------------------------------------//
+
+int cpp_main(int, char *[])
+{
+  cout << "byte swap intrinsics: " BOOST_ENDIAN_INTRINSIC_MSG << endl;
+
+  cout << "  construct big endian aligned" << endl;
+  big_int32_buf_at x(1122334455);
+
+  cout << "  assign to buffer from built-in integer" << endl;
+  x = 1234567890;
+
+  cout << "  operator==(buffer.value(), built-in)" << endl;
+  bool b1(x.value() == 1234567890);
+  BOOST_TEST(b1);
+
+  cout << "  construct little endian unaligned" << endl;
+  little_int32_buf_t x2(1122334455);
+
+  cout << "  assign to buffer from built-in integer" << endl;
+  x2 = 1234567890;
+
+  cout << "  operator==(buffer.value(), built-in)" << endl;
+  bool b2(x2.value() == 1234567890);
+  BOOST_TEST(b2);
+
+  check_size();
+  test_inserter_and_extractor();
+
+  cout << "  done" << endl;
+
+  return ::boost::report_errors();
+}
+
+#include <boost/endian/detail/disable_warnings_pop.hpp>
diff --git a/libs/endian/test/conversion_test.cpp b/libs/endian/test/conversion_test.cpp
new file mode 100644
index 0000000..632bc79
--- /dev/null
+++ b/libs/endian/test/conversion_test.cpp
@@ -0,0 +1,371 @@
+//  conversion_test.cpp  ---------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2010
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include <boost/endian/conversion.hpp>
+#include <boost/detail/lightweight_main.hpp>
+#include <boost/core/lightweight_test.hpp>
+#include <iostream>
+#include <cstring>
+
+namespace be = boost::endian;
+using std::cout;
+using std::endl;
+using boost::int8_t;
+using boost::uint8_t;
+using boost::int16_t;
+using boost::uint16_t;
+using boost::int32_t;
+using boost::uint32_t;
+using boost::int64_t;
+using boost::uint64_t;
+
+namespace
+{
+
+  //  values for tests
+
+  void native_value(int8_t& x) {x = static_cast<int8_t>(0xF0U);}
+  void native_value(uint8_t& x) {x = static_cast<uint8_t>(0xF0U);}
+# ifdef BOOST_BIG_ENDIAN
+  void big_value(int8_t& x) {x = static_cast<int8_t>(0xF0U);}
+  void big_value(uint8_t& x) {x = static_cast<uint8_t>(0xF0U);}
+  void little_value(int8_t& x) {x = static_cast<int8_t>(0xF0U);}
+  void little_value(uint8_t& x) {x = static_cast<uint8_t>(0xF0U);}
+# else
+  void big_value(int8_t& x) {x = static_cast<int8_t>(0xF0U);}
+  void big_value(uint8_t& x) {x = static_cast<uint8_t>(0xF0U);}
+  void little_value(int8_t& x) {x = static_cast<int8_t>(0xF0U);}
+  void little_value(uint8_t& x) {x = static_cast<uint8_t>(0xF0U);}
+# endif
+
+  void native_value(int16_t& x) {x = static_cast<int16_t>(0xF102U);}
+  void native_value(uint16_t& x) {x = static_cast<uint16_t>(0xF102U);}
+# ifdef BOOST_BIG_ENDIAN
+  void big_value(int16_t& x) {x = static_cast<int16_t>(0xF102U);}
+  void big_value(uint16_t& x) {x = static_cast<uint16_t>(0xF102U);}
+  void little_value(int16_t& x) {x = static_cast<int16_t>(0x02F1U);}
+  void little_value(uint16_t& x) {x = static_cast<uint16_t>(0x02F1U);}
+# else
+  void big_value(int16_t& x) {x = static_cast<int16_t>(0x02F1U);}
+  void big_value(uint16_t& x) {x = static_cast<uint16_t>(0x02F1U);}
+  void little_value(int16_t& x) {x = static_cast<int16_t>(0xF102U);}
+  void little_value(uint16_t& x) {x = static_cast<uint16_t>(0xF102U);}
+# endif
+
+  void native_value(int32_t& x) {x = static_cast<int32_t>(0xF1E21304UL);}
+  void native_value(uint32_t& x) {x = static_cast<uint32_t>(0xF1E21304UL);}
+# ifdef BOOST_BIG_ENDIAN
+  void big_value(int32_t& x) {x = static_cast<int32_t>(0xF1E21304UL);}
+  void big_value(uint32_t& x) {x = static_cast<uint32_t>(0xF1E21304UL);}
+  void little_value(int32_t& x) {x = static_cast<int32_t>(0x0413E2F1UL);}
+  void little_value(uint32_t& x) {x = static_cast<uint32_t>(0x0413E2F1UL);}
+# else
+  void big_value(int32_t& x) {x = static_cast<int32_t>(0x0413E2F1UL);}
+  void big_value(uint32_t& x) {x = static_cast<uint32_t>(0x0413E2F1UL);}
+  void little_value(int32_t& x) {x = static_cast<int32_t>(0xF1E21304UL);}
+  void little_value(uint32_t& x) {x = static_cast<uint32_t>(0xF1E21304UL);}
+# endif
+
+  void native_value(int64_t& x) {x = static_cast<int64_t>(0xF1E2D3C444231201ULL);}
+  void native_value(uint64_t& x) {x = static_cast<uint64_t>(0xF1E2D3C444231201ULL);}
+# ifdef BOOST_BIG_ENDIAN
+  void big_value(int64_t& x) {x = static_cast<int64_t>(0xF1E2D3C444231201ULL);}
+  void big_value(uint64_t& x) {x = static_cast<uint64_t>(0xF1E2D3C444231201ULL);}
+  void little_value(int64_t& x) {x = static_cast<int64_t>(0x01122344C4D3E2F1ULL);}
+  void little_value(uint64_t& x) {x = static_cast<uint64_t>(0x01122344C4D3E2F1ULL);}
+# else
+  void big_value(int64_t& x) {x = static_cast<int64_t>(0x01122344C4D3E2F1ULL);}
+  void big_value(uint64_t& x) {x = static_cast<uint64_t>(0x01122344C4D3E2F1ULL);}
+  void little_value(int64_t& x) {x = static_cast<int64_t>(0xF1E2D3C444231201ULL);}
+  void little_value(uint64_t& x) {x = static_cast<uint64_t>(0xF1E2D3C444231201ULL);}
+# endif
+
+  template <class T>
+  void test()
+  {
+    T native;
+    T big;
+    T little;
+    native_value(native);
+    big_value(big);
+    little_value(little);
+
+    //  validate the values used by the tests below
+
+# ifdef BOOST_BIG_ENDIAN
+    BOOST_TEST_EQ(native, big);
+    BOOST_TEST_EQ(be::detail::std_endian_reverse(native), little);
+# else
+    BOOST_TEST_EQ(be::detail::std_endian_reverse(native), big);
+    BOOST_TEST_EQ(native, little);
+# endif
+
+    //  value-by-value tests
+
+    //  unconditional reverse
+    BOOST_TEST_EQ(be::endian_reverse(big), little);
+    BOOST_TEST_EQ(be::endian_reverse(little), big);
+
+    //  conditional reverse
+    BOOST_TEST_EQ(be::native_to_big(native), big);
+    BOOST_TEST_EQ(be::native_to_little(native), little);
+    BOOST_TEST_EQ(be::big_to_native(big), native);
+    BOOST_TEST_EQ(be::little_to_native(little), native);
+
+    //  generic conditional reverse
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::big, be::order::big>(big)), big);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::little,
+      be::order::little>(little)), little);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::native,
+      be::order::native>(native)), native);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::big,
+      be::order::little>(big)), little);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::big,
+      be::order::native>(big)), native);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::little,
+      be::order::big>(little)), big);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::little,
+      be::order::native>(little)), native);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::native,
+      be::order::big>(native)), big);
+    BOOST_TEST_EQ((be::conditional_reverse<be::order::native,
+      be::order::little>(native)), little);
+
+    //  runtime conditional reverse
+    BOOST_TEST_EQ((be::conditional_reverse(big, be::order::big, be::order::big)),
+      big);
+    BOOST_TEST_EQ((be::conditional_reverse(little, be::order::little,
+      be::order::little)), little);
+    BOOST_TEST_EQ((be::conditional_reverse(native, be::order::native,
+      be::order::native)), native);
+    BOOST_TEST_EQ((be::conditional_reverse(big, be::order::big,
+      be::order::little)), little);
+    BOOST_TEST_EQ((be::conditional_reverse(big, be::order::big,
+      be::order::native)), native);
+    BOOST_TEST_EQ((be::conditional_reverse(little, be::order::little,
+      be::order::big)), big);
+    BOOST_TEST_EQ((be::conditional_reverse(little, be::order::little,
+      be::order::native)), native);
+    BOOST_TEST_EQ((be::conditional_reverse(native, be::order::native,
+      be::order::big)), big);
+    BOOST_TEST_EQ((be::conditional_reverse(native, be::order::native,
+      be::order::little)), little);
+
+    //  modify-in-place tests
+
+    T x;
+
+    //  unconditional reverse
+    x = big; be::endian_reverse_inplace(x); BOOST_TEST_EQ(x, little);
+    x = little; be::endian_reverse_inplace(x); BOOST_TEST_EQ(x, big);
+
+    //  conditional reverse
+    x = native; be::native_to_big_inplace(x); BOOST_TEST_EQ(x, big);
+    x = native; be::native_to_little_inplace(x);  BOOST_TEST_EQ(x, little);
+    x = big; be::big_to_native_inplace(x);  BOOST_TEST_EQ(x, native);
+    x = little; be::little_to_native_inplace(x); BOOST_TEST_EQ(x, native);
+
+    //  generic conditional reverse
+    x = big; be::conditional_reverse_inplace<be::order::big, be::order::big>(x);
+      BOOST_TEST_EQ(x, big);
+    x = little; be::conditional_reverse_inplace<be::order::little, be::order::little>(x);
+      BOOST_TEST_EQ(x, little);
+    x = native; be::conditional_reverse_inplace<be::order::native, be::order::native>(x);
+      BOOST_TEST_EQ(x, native);
+    x = big; be::conditional_reverse_inplace<be::order::big, be::order::little>(x);
+      BOOST_TEST_EQ(x, little);
+    x = big; be::conditional_reverse_inplace<be::order::big, be::order::native>(x);
+      BOOST_TEST_EQ(x, native);
+    x = little; be::conditional_reverse_inplace<be::order::little, be::order::big>(x);
+      BOOST_TEST_EQ(x, big);
+    x = little; be::conditional_reverse_inplace<be::order::little, be::order::native>(x);
+      BOOST_TEST_EQ(x, native);
+      x = native; be::conditional_reverse_inplace<be::order::native, be::order::big>(x);
+      BOOST_TEST_EQ(x, big);
+    x = native; be::conditional_reverse_inplace<be::order::native, be::order::little>(x);
+      BOOST_TEST_EQ(x, little);
+
+    //  runtime conditional reverse
+    x = big;
+      be::conditional_reverse_inplace(x, be::order::big, be::order::big);
+      BOOST_TEST_EQ(x, big);
+    x = little;
+      be::conditional_reverse_inplace(x, be::order::little, be::order::little);
+      BOOST_TEST_EQ(x, little);
+    x = native;
+      be::conditional_reverse_inplace(x, be::order::native, be::order::native);
+      BOOST_TEST_EQ(x, native);
+    x = big;
+      be::conditional_reverse_inplace(x, be::order::big, be::order::little);
+      BOOST_TEST_EQ(x, little);
+    x = big;
+      be::conditional_reverse_inplace(x, be::order::big, be::order::native);
+      BOOST_TEST_EQ(x, native);
+    x = little;
+      be::conditional_reverse_inplace(x, be::order::little, be::order::big); 
+      BOOST_TEST_EQ(x, big);
+    x = little;
+      be::conditional_reverse_inplace(x, be::order::little, be::order::native); 
+      BOOST_TEST_EQ(x, native);
+    x = native;
+      be::conditional_reverse_inplace(x, be::order::native, be::order::big); 
+      BOOST_TEST_EQ(x, big);
+    x = native;
+      be::conditional_reverse_inplace(x, be::order::native, be::order::little); 
+      BOOST_TEST_EQ(x, little);
+
+  }
+
+//--------------------------------------------------------------------------------------//
+
+  template <class UDT>
+  void udt_test()
+  {
+    UDT udt, tmp;
+    int64_t big;
+    int64_t little;
+    int64_t native;
+    big_value(big);
+    little_value(little);
+    native_value(native);
+
+    udt.member1 = big;
+    udt.member2 = little;
+    udt.member3 = native;
+
+    tmp = be::conditional_reverse<be::order::big, be::order::little>(udt);
+    BOOST_TEST_EQ(tmp.member1, be::endian_reverse(big));
+    BOOST_TEST_EQ(tmp.member2, be::endian_reverse(little));
+    BOOST_TEST_EQ(tmp.member3, be::endian_reverse(native));
+
+    be::conditional_reverse_inplace<be::order::big, be::order::little>(udt);
+    BOOST_TEST_EQ(udt.member1, be::endian_reverse(big));
+    BOOST_TEST_EQ(udt.member2, be::endian_reverse(little));
+    BOOST_TEST_EQ(udt.member3, be::endian_reverse(native));
+
+    udt.member1 = big;
+    udt.member2 = little;
+    udt.member3 = native;
+    tmp.member1 = tmp.member2 = tmp.member3 = 0;
+
+    tmp = be::conditional_reverse<be::order::big, be::order::big>(udt);
+    BOOST_TEST_EQ(tmp.member1, big);
+    BOOST_TEST_EQ(tmp.member2, little);
+    BOOST_TEST_EQ(tmp.member3, native);
+
+    be::conditional_reverse_inplace<be::order::big, be::order::big>(udt);
+    BOOST_TEST_EQ(udt.member1, big);
+    BOOST_TEST_EQ(udt.member2, little);
+    BOOST_TEST_EQ(udt.member3, native);
+  }
+}  // unnamed namespace
+
+//--------------------------------------------------------------------------------------//
+
+  //  User-defined types 
+  
+  namespace user
+  {
+    //  UDT1 supplies both endian_reverse and endian_reverse_inplace
+    struct UDT1
+    {
+      int64_t member1;
+      int64_t member2;
+      int64_t member3;
+    };
+
+    UDT1 endian_reverse(const UDT1& udt) BOOST_NOEXCEPT
+    {
+      UDT1 tmp;
+      tmp.member1 = boost::endian::endian_reverse(udt.member1);
+      tmp.member2 = boost::endian::endian_reverse(udt.member2);
+      tmp.member3 = boost::endian::endian_reverse(udt.member3);
+      return tmp;
+    }
+
+    void endian_reverse_inplace(UDT1& udt) BOOST_NOEXCEPT
+    {
+      boost::endian::endian_reverse_inplace(udt.member1);
+      boost::endian::endian_reverse_inplace(udt.member2);
+      boost::endian::endian_reverse_inplace(udt.member3);
+    }
+
+    //  UDT2 supplies only endian_reverse
+    struct UDT2
+    {
+      int64_t member1;
+      int64_t member2;
+      int64_t member3;
+    };
+
+    UDT2 endian_reverse(const UDT2& udt) BOOST_NOEXCEPT
+    {
+      UDT2 tmp;
+      tmp.member1 = boost::endian::endian_reverse(udt.member1);
+      tmp.member2 = boost::endian::endian_reverse(udt.member2);
+      tmp.member3 = boost::endian::endian_reverse(udt.member3);
+      return tmp;
+    }
+
+    //  UDT3 supplies neither endian_reverse nor endian_reverse_inplace,
+    //  so udt_test<UDT3>() should fail to compile
+    struct UDT3
+    {
+      int64_t member1;
+      int64_t member2;
+      int64_t member3;
+    };
+
+  }  // namespace user
+
+//--------------------------------------------------------------------------------------//
+
+int cpp_main(int, char * [])
+{
+  cout << "byte swap intrinsics: " BOOST_ENDIAN_INTRINSIC_MSG << endl;
+  
+  //std::cerr << std::hex;
+
+  cout << "int8_t" << endl;
+  test<int8_t>();
+  cout << "uint8_t" << endl;
+  test<uint8_t>();
+
+  cout << "int16_t" << endl;
+  test<int16_t>();
+  cout << "uint16_t" << endl;
+  test<uint16_t>();
+
+  cout << "int32_t" << endl;
+  test<int32_t>();
+  cout << "uint32_t" << endl;
+  test<uint32_t>();
+
+  cout << "int64_t" << endl;
+  test<int64_t>();
+  cout << "uint64_t" << endl;
+  test<uint64_t>();
+
+  cout << "UDT 1" << endl;
+  udt_test<user::UDT1>();
+
+  cout << "UDT 2" << endl;
+  udt_test<user::UDT2>();
+
+#ifdef BOOST_ENDIAN_COMPILE_FAIL
+  cout << "UDT 3" << endl;
+  udt_test<user::UDT3>();    // should fail to compile since has not endian_reverse()
+#endif
+
+  return ::boost::report_errors();
+}
+
+#include <boost/endian/detail/disable_warnings_pop.hpp>
diff --git a/libs/endian/test/deprecated_test.cpp b/libs/endian/test/deprecated_test.cpp
new file mode 100644
index 0000000..e4417f6
--- /dev/null
+++ b/libs/endian/test/deprecated_test.cpp
@@ -0,0 +1,183 @@
+//  deprecated_test.cpp  ---------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2014, 2015
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//--------------------------------------------------------------------------------------//
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#define BOOST_ENDIAN_DEPRECATED_NAMES
+#include <boost/endian/endian.hpp>
+#include <boost/detail/lightweight_main.hpp>
+#include <boost/core/lightweight_test.hpp>
+#include <iostream>
+#include <sstream>
+
+using namespace boost::endian;
+using std::cout;
+using std::endl;
+
+namespace
+{
+
+  //  check_size  ----------------------------------------------------------------------//
+
+  void check_size()
+  {
+    BOOST_TEST_EQ(sizeof(big8_t), 1);
+    BOOST_TEST_EQ(sizeof(big16_t), 2);
+    BOOST_TEST_EQ(sizeof(big24_t), 3);
+    BOOST_TEST_EQ(sizeof(big32_t), 4);
+    BOOST_TEST_EQ(sizeof(big40_t), 5);
+    BOOST_TEST_EQ(sizeof(big48_t), 6);
+    BOOST_TEST_EQ(sizeof(big56_t), 7);
+    BOOST_TEST_EQ(sizeof(big64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(ubig8_t), 1);
+    BOOST_TEST_EQ(sizeof(ubig16_t), 2);
+    BOOST_TEST_EQ(sizeof(ubig24_t), 3);
+    BOOST_TEST_EQ(sizeof(ubig32_t), 4);
+    BOOST_TEST_EQ(sizeof(ubig40_t), 5);
+    BOOST_TEST_EQ(sizeof(ubig48_t), 6);
+    BOOST_TEST_EQ(sizeof(ubig56_t), 7);
+    BOOST_TEST_EQ(sizeof(ubig64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(little8_t), 1);
+    BOOST_TEST_EQ(sizeof(little16_t), 2);
+    BOOST_TEST_EQ(sizeof(little24_t), 3);
+    BOOST_TEST_EQ(sizeof(little32_t), 4);
+    BOOST_TEST_EQ(sizeof(little40_t), 5);
+    BOOST_TEST_EQ(sizeof(little48_t), 6);
+    BOOST_TEST_EQ(sizeof(little56_t), 7);
+    BOOST_TEST_EQ(sizeof(little64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(ulittle8_t), 1);
+    BOOST_TEST_EQ(sizeof(ulittle16_t), 2);
+    BOOST_TEST_EQ(sizeof(ulittle24_t), 3);
+    BOOST_TEST_EQ(sizeof(ulittle32_t), 4);
+    BOOST_TEST_EQ(sizeof(ulittle40_t), 5);
+    BOOST_TEST_EQ(sizeof(ulittle48_t), 6);
+    BOOST_TEST_EQ(sizeof(ulittle56_t), 7);
+    BOOST_TEST_EQ(sizeof(ulittle64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(native8_t), 1);
+    BOOST_TEST_EQ(sizeof(native16_t), 2);
+    BOOST_TEST_EQ(sizeof(native24_t), 3);
+    BOOST_TEST_EQ(sizeof(native32_t), 4);
+    BOOST_TEST_EQ(sizeof(native40_t), 5);
+    BOOST_TEST_EQ(sizeof(native48_t), 6);
+    BOOST_TEST_EQ(sizeof(native56_t), 7);
+    BOOST_TEST_EQ(sizeof(native64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(unative8_t), 1);
+    BOOST_TEST_EQ(sizeof(unative16_t), 2);
+    BOOST_TEST_EQ(sizeof(unative24_t), 3);
+    BOOST_TEST_EQ(sizeof(unative32_t), 4);
+    BOOST_TEST_EQ(sizeof(unative40_t), 5);
+    BOOST_TEST_EQ(sizeof(unative48_t), 6);
+    BOOST_TEST_EQ(sizeof(unative56_t), 7);
+    BOOST_TEST_EQ(sizeof(unative64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(aligned_big16_t), 2);
+    BOOST_TEST_EQ(sizeof(aligned_big32_t), 4);
+    BOOST_TEST_EQ(sizeof(aligned_big64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(aligned_ubig16_t), 2);
+    BOOST_TEST_EQ(sizeof(aligned_ubig32_t), 4);
+    BOOST_TEST_EQ(sizeof(aligned_ubig64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(aligned_little16_t), 2);
+    BOOST_TEST_EQ(sizeof(aligned_little32_t), 4);
+    BOOST_TEST_EQ(sizeof(aligned_little64_t), 8);
+
+    BOOST_TEST_EQ(sizeof(aligned_ulittle16_t), 2);
+    BOOST_TEST_EQ(sizeof(aligned_ulittle32_t), 4);
+    BOOST_TEST_EQ(sizeof(aligned_ulittle64_t), 8);
+
+# ifndef BOOST_NO_CXX11_TEMPLATE_ALIASES
+    BOOST_TEST_EQ(sizeof(endian<endianness::big, int_least16_t, 16>), 2);
+    BOOST_TEST_EQ(sizeof(endian<endianness::big,
+      int_least16_t, 16, alignment::unaligned>), 2);
+# endif
+  } // check_size
+
+  //  test_inserter_and_extractor  -----------------------------------------------------//
+
+  void test_inserter_and_extractor()
+  {
+    std::cout << "test inserter and extractor..." << std::endl;
+
+    ubig64_t bu64(0x010203040506070ULL);
+    ulittle64_t lu64(0x010203040506070ULL);
+
+    uint64_t x;
+
+    std::stringstream ss;
+
+    ss << bu64;
+    ss >> x;
+    BOOST_TEST_EQ(x, 0x010203040506070ULL);
+
+    ss.clear();
+    ss << lu64;
+    ss >> x;
+    BOOST_TEST_EQ(x, 0x010203040506070ULL);
+
+    ss.clear();
+    ss << 0x010203040506070ULL;
+    ubig64_t bu64z(0);
+    ss >> bu64z;
+    BOOST_TEST_EQ(bu64z, bu64);
+
+    ss.clear();
+    ss << 0x010203040506070ULL;
+    ulittle64_t lu64z(0);
+    ss >> lu64z;
+    BOOST_TEST_EQ(lu64z, lu64);
+
+    std::cout << "test inserter and extractor complete" << std::endl;
+
+  }
+
+}  // unnamed namespace
+
+   //--------------------------------------------------------------------------------------//
+
+int cpp_main(int, char *[])
+{
+  cout << "byte swap intrinsics: " BOOST_ENDIAN_INTRINSIC_MSG << endl;
+
+  cout << "  construct big endian aligned" << endl;
+  big32_t x(1122334455);
+
+  cout << "  assign to buffer from built-in integer" << endl;
+  x = 1234567890;
+
+  cout << "  operator==(buffer.value(), built-in)" << endl;
+  bool b1(x == 1234567890);
+  BOOST_TEST(b1);
+
+  cout << "  construct little endian unaligned" << endl;
+  little32_t x2(1122334455);
+
+  cout << "  assign to buffer from built-in integer" << endl;
+  x2 = 1234567890;
+
+  cout << "  operator==(buffer.value(), built-in)" << endl;
+  bool b2(x2 == 1234567890);
+  BOOST_TEST(b2);
+
+  check_size();
+  test_inserter_and_extractor();
+
+  cout << "  done" << endl;
+
+  return ::boost::report_errors();
+}
+
+#include <boost/endian/detail/disable_warnings_pop.hpp>
diff --git a/libs/endian/test/endian_in_union_test.cpp b/libs/endian/test/endian_in_union_test.cpp
new file mode 100644
index 0000000..d82bb3f
--- /dev/null
+++ b/libs/endian/test/endian_in_union_test.cpp
@@ -0,0 +1,86 @@
+//  endian_in_union_test.cpp  -------------------------------------------------//
+
+//  Copyright Beman Dawes 2008
+
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//----------------------------------------------------------------------------//
+
+#define BOOST_ENDIAN_FORCE_PODNESS
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include <boost/endian/arithmetic.hpp>
+#include <boost/detail/lightweight_main.hpp>
+#include <cassert>
+
+using namespace boost::endian;
+
+union U
+{
+  big_int8_t           big_8;
+  big_int16_t          big_16;
+  big_int24_t          big_24;
+  big_int32_t          big_32;
+  big_int40_t          big_40;
+  big_int48_t          big_48;
+  big_int56_t          big_56;
+  big_int64_t          big_64;
+                   
+  big_uint8_t          big_u8;
+  big_uint16_t         big_u16;
+  big_uint24_t         big_u24;
+  big_uint32_t         big_u32;
+  big_uint40_t         big_u40;
+  big_uint48_t         big_u48;
+  big_uint56_t         big_u56;
+  big_uint64_t         big_u64;
+                   
+  little_int8_t        little_8;
+  little_int16_t       little_16;
+  little_int24_t       little_24;
+  little_int32_t       little_32;
+  little_int40_t       little_40;
+  little_int48_t       little_48;
+  little_int56_t       little_56;
+  little_int64_t       little_64;
+                   
+  little_uint8_t       little_u8;
+  little_uint16_t      little_u16;
+  little_uint24_t      little_u24;
+  little_uint32_t      little_u32;
+  little_uint40_t      little_u40;
+  little_uint48_t      little_u48;
+  little_uint56_t      little_u56;
+  little_uint64_t      little_u64;
+                   
+  native_int8_t        native_8;
+  native_int16_t       native_16;
+  native_int24_t       native_24;
+  native_int32_t       native_32;
+  native_int40_t       native_40;
+  native_int48_t       native_48;
+  native_int56_t       native_56;
+  native_int64_t       native_64;
+                   
+  native_uint8_t       native_u8;
+  native_uint16_t      native_u16;
+  native_uint24_t      native_u24;
+  native_uint32_t      native_u32;
+  native_uint40_t      native_u40;
+  native_uint48_t      native_u48;
+  native_uint56_t      native_u56;
+  native_uint64_t      native_u64;
+};
+
+U foo;
+
+int cpp_main(int, char * [])
+{
+
+  return 0;
+}
+
diff --git a/libs/endian/test/endian_operations_test.cpp b/libs/endian/test/endian_operations_test.cpp
new file mode 100644
index 0000000..3c3c53d
--- /dev/null
+++ b/libs/endian/test/endian_operations_test.cpp
@@ -0,0 +1,504 @@
+//  endian_operations_test.cpp  --------------------------------------------------------//
+
+//  Copyright Beman Dawes 2008
+
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//--------------------------------------------------------------------------------------//
+
+//  This test probes operator overloading, including interaction between
+//  operand types.
+
+//  See endian_test for tests of endianess correctness, size, and value.
+
+#define BOOST_ENDIAN_LOG
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#ifdef _MSC_VER
+#  pragma warning( disable : 4242 )  // conversion ..., possible loss of data
+#  pragma warning( disable : 4244 )  // conversion ..., possible loss of data
+#  pragma warning( disable : 4018 )  // signed/unsigned mismatch
+#  pragma warning( disable : 4365 )  // signed/unsigned mismatch
+#  pragma warning( disable : 4389 )  // signed/unsigned mismatch
+#elif defined(__GNUC__)
+#  pragma GCC diagnostic ignored "-Wconversion"
+#endif
+
+#define BOOST_ENDIAN_LOG
+
+#include <boost/endian/arithmetic.hpp>
+#include <boost/type_traits/is_signed.hpp>
+#include <boost/core/lightweight_test.hpp>
+#include <boost/detail/lightweight_main.hpp>
+#include <boost/cstdint.hpp>
+#include <cassert>
+#include <iostream>
+#include <sstream>
+
+namespace be = boost::endian;
+
+template <class T>
+struct value_type
+{
+  typedef typename T::value_type type;
+};
+
+template<> struct value_type<char>  { typedef char type; };
+template<> struct value_type<unsigned char>  { typedef unsigned char type; };
+template<> struct value_type<signed char>  { typedef signed char type; };
+template<> struct value_type<short>  { typedef short type; };
+template<> struct value_type<unsigned short>  { typedef unsigned short type; };
+template<> struct value_type<int>  { typedef int type; };
+template<> struct value_type<unsigned int>  { typedef unsigned int type; };
+template<> struct value_type<long>  { typedef long type; };
+template<> struct value_type<unsigned long>  { typedef unsigned long type; };
+template<> struct value_type<long long>  { typedef long long type; };
+template<> struct value_type<unsigned long long>  { typedef unsigned long long type; };
+
+template <class T1,  class T2>
+struct default_construct
+{
+  static void test()
+  {
+    T1 o1;
+    o1 = 1;         // quiet warnings
+    if (o1) return; // quiet warnings
+  }
+};
+
+template <class T1,  class T2>
+struct construct
+{
+  static void test()
+  {
+    T2 o2(1);
+    T1 o1(static_cast<T1>(o2));
+    ++o1;  // quiet gcc unused variable warning
+  }
+};
+
+template <class T1,  class T2>
+struct initialize
+{
+  static void test()
+  {
+    T1 o2(2);
+    T1 o1 = o2;
+    ++o1;  // quiet gcc unused variable warning
+  }
+};
+
+template <class T1,  class T2>
+struct assign
+{
+  static void test()
+  {
+    T2 o2;
+    o2 = 1;
+    T1 o1;
+    o1 = o2;
+    if (o1) return; // quiet warnings
+  }
+};
+
+template <class T1,  class T2, bool SameSignedness>
+struct do_relational
+{
+  static void test()
+  {
+    T1 o1(1);
+    T2 o2(2);
+    BOOST_TEST( !(o1 == o2) );
+    BOOST_TEST( o1 != o2 );
+    BOOST_TEST( o1 < o2 );
+    BOOST_TEST( o1 <= o2 );
+    BOOST_TEST( !(o1 > o2) );
+    BOOST_TEST( !(o1 >= o2 ) );
+  }
+};
+
+template <class T1,  class T2>
+struct do_relational<T1, T2, false>
+{
+  static void test()
+  {
+  }
+};
+
+template <class T1,  class T2>
+struct relational
+{
+  static void test()
+  {
+    do_relational<T1, T2,
+      boost::is_signed<typename value_type<T1>::type>::value
+        == boost::is_signed<typename value_type<T2>::type>::value
+                 >::test();
+ //   do_relational<T1, T2, true>::test();
+  }
+};
+
+template <class T1,  class T2>
+struct op_plus
+{
+  static void test()
+  {
+    T1 o1(1);
+    T2 o2(2);
+    T1 o3;
+
+    o3 = +o1;
+
+    o3 = o1 + o2;
+
+    o1 += o2;
+
+    if (o3) return; // quiet warnings
+  }
+};
+
+template <class T1,  class T2>
+struct op_star
+{
+  static void test()
+  {
+    T1 o1(1);
+    T2 o2(2);
+    T1 o3;
+
+    o3 = o1 * o2;
+
+    o1 *= o2;
+
+    if (o3) return; // quiet warnings
+  }
+};
+
+template <template<class,  class> class Test,  class T1>
+void op_test_aux()
+{
+  Test<T1, char>::test();
+  Test<T1, unsigned char>::test();
+  Test<T1, signed char>::test();
+  Test<T1, short>::test();
+  Test<T1, unsigned short>::test();
+  Test<T1, int>::test();
+  Test<T1, unsigned int>::test();
+  Test<T1, long>::test();
+  Test<T1, unsigned long>::test();
+  Test<T1, long long>::test();
+  Test<T1, unsigned long long>::test();
+  Test<T1, be::big_int16_at>::test();
+  Test<T1, be::big_int32_at>::test();
+  Test<T1, be::big_int64_at>::test();
+  Test<T1, be::big_uint16_at>::test();
+  Test<T1, be::big_uint32_at>::test();
+  Test<T1, be::big_uint64_at>::test();
+  Test<T1, be::little_int16_at>::test();
+  Test<T1, be::little_int32_at>::test();
+  Test<T1, be::little_int64_at>::test();
+  Test<T1, be::little_uint16_at>::test();
+  Test<T1, be::little_uint32_at>::test();
+  Test<T1, be::little_uint64_at>::test();
+  Test<T1, be::big_int8_t>::test();
+  Test<T1, be::big_int16_t>::test();
+  Test<T1, be::big_int24_t>::test();
+  Test<T1, be::big_int32_t>::test();
+  Test<T1, be::big_int40_t>::test();
+  Test<T1, be::big_int48_t>::test();
+  Test<T1, be::big_int56_t>::test();
+  Test<T1, be::big_int64_t>::test();
+  Test<T1, be::big_uint8_t>::test();
+  Test<T1, be::big_uint16_t>::test();
+  Test<T1, be::big_uint24_t>::test();
+  Test<T1, be::big_uint32_t>::test();
+  Test<T1, be::big_uint40_t>::test();
+  Test<T1, be::big_uint64_t>::test();
+  Test<T1, be::little_int16_t>::test();
+  Test<T1, be::little_int24_t>::test();
+  Test<T1, be::little_int32_t>::test();
+  Test<T1, be::little_int64_t>::test();
+  Test<T1, be::little_uint16_t>::test();
+  Test<T1, be::little_uint32_t>::test();
+  Test<T1, be::little_uint56_t>::test();
+  Test<T1, be::little_uint64_t>::test();
+  Test<T1, be::native_int16_t>::test();
+  Test<T1, be::native_int24_t>::test();
+  Test<T1, be::native_int32_t>::test();
+  Test<T1, be::native_int64_t>::test();
+#ifdef BOOST_LONG_ENDIAN_TEST
+  Test<T1, be::native_uint16_t>::test();
+  Test<T1, be::native_uint24_t>::test();
+  Test<T1, be::native_uint32_t>::test();
+  Test<T1, be::native_uint48_t>::test();
+  Test<T1, be::native_uint64_t>::test();
+  Test<T1, be::big_uint48_t>::test();
+  Test<T1, be::big_uint56_t>::test();
+  Test<T1, be::little_int8_t>::test();
+  Test<T1, be::little_int56_t>::test();
+  Test<T1, be::little_int40_t>::test();
+  Test<T1, be::little_int48_t>::test();
+  Test<T1, be::little_uint8_t>::test();
+  Test<T1, be::little_uint24_t>::test();
+  Test<T1, be::little_uint40_t>::test();
+  Test<T1, be::little_uint48_t>::test();
+  Test<T1, be::native_int8_t>::test();
+  Test<T1, be::native_int40_t>::test();
+  Test<T1, be::native_int48_t>::test();
+  Test<T1, be::native_int56_t>::test();
+  Test<T1, be::native_uint8_t>::test();
+  Test<T1, be::native_uint40_t>::test();
+  Test<T1, be::native_uint56_t>::test();
+#endif
+}
+
+template <template<class,  class> class Test>
+void op_test()
+{
+  op_test_aux<Test, char>();
+  op_test_aux<Test, unsigned char>();
+  op_test_aux<Test, signed char>();
+  op_test_aux<Test, short>();
+  op_test_aux<Test, unsigned short>();
+  op_test_aux<Test, int>();
+  op_test_aux<Test, unsigned int>();
+  op_test_aux<Test, long>();
+  op_test_aux<Test, unsigned long>();
+  op_test_aux<Test, long long>();
+  op_test_aux<Test, unsigned long long>();
+  op_test_aux<Test, be::big_int16_at>();
+  op_test_aux<Test, be::big_int32_at>();
+  op_test_aux<Test, be::big_int64_at>();
+  op_test_aux<Test, be::little_int16_at>();
+  op_test_aux<Test, be::little_int32_at>();
+  op_test_aux<Test, be::little_int64_at>();
+#ifdef BOOST_LONG_ENDIAN_TEST
+  op_test_aux<Test, be::big_int8_t>();
+  op_test_aux<Test, be::big_int16_t>();
+  op_test_aux<Test, be::big_int24_t>();
+  op_test_aux<Test, be::big_int32_t>();
+  op_test_aux<Test, be::big_int40_t>();
+  op_test_aux<Test, be::big_int48_t>();
+  op_test_aux<Test, be::big_int56_t>();
+  op_test_aux<Test, be::big_int64_t>();
+  op_test_aux<Test, be::big_uint8_t>();
+  op_test_aux<Test, be::big_uint16_t>();
+  op_test_aux<Test, be::big_uint24_t>();
+  op_test_aux<Test, be::big_uint32_t>();
+  op_test_aux<Test, be::big_uint40_t>();
+  op_test_aux<Test, be::big_uint48_t>();
+  op_test_aux<Test, be::big_uint56_t>();
+  op_test_aux<Test, be::big_uint64_t>();
+  op_test_aux<Test, be::little_int8_t>();
+  op_test_aux<Test, be::little_int16_t>();
+  op_test_aux<Test, be::little_int24_t>();
+  op_test_aux<Test, be::little_int32_t>();
+  op_test_aux<Test, be::little_int40_t>();
+  op_test_aux<Test, be::little_int48_t>();
+  op_test_aux<Test, be::little_int56_t>();
+  op_test_aux<Test, be::little_int64_t>();
+  op_test_aux<Test, be::little_uint8_t>();
+  op_test_aux<Test, be::little_uint16_t>();
+  op_test_aux<Test, be::little_uint24_t>();
+  op_test_aux<Test, be::little_uint32_t>();
+  op_test_aux<Test, be::little_uint40_t>();
+  op_test_aux<Test, be::little_uint48_t>();
+  op_test_aux<Test, be::little_uint56_t>();
+  op_test_aux<Test, be::little_uint64_t>();
+  op_test_aux<Test, be::native_int8_t>();
+  op_test_aux<Test, be::native_int16_t>();
+  op_test_aux<Test, be::native_int24_t>();
+  op_test_aux<Test, be::native_int32_t>();
+  op_test_aux<Test, be::native_int40_t>();
+  op_test_aux<Test, be::native_int48_t>();
+  op_test_aux<Test, be::native_int56_t>();
+  op_test_aux<Test, be::native_int64_t>();
+  op_test_aux<Test, be::native_uint8_t>();
+  op_test_aux<Test, be::native_uint16_t>();
+  op_test_aux<Test, be::native_uint24_t>();
+  op_test_aux<Test, be::native_uint32_t>();
+  op_test_aux<Test, be::native_uint40_t>();
+  op_test_aux<Test, be::native_uint48_t>();
+  op_test_aux<Test, be::native_uint56_t>();
+  op_test_aux<Test, be::native_uint64_t>();
+#endif
+}
+
+//  test_inserter_and_extractor  -----------------------------------------------------//
+
+void test_inserter_and_extractor()
+{
+  std::cout << "test inserter and extractor..." << std::endl;
+
+  be::big_uint64_t bu64(0x010203040506070ULL);
+  be::little_uint64_t lu64(0x010203040506070ULL);
+
+  boost::uint64_t x;
+
+  std::stringstream ss;
+
+  ss << bu64;
+  ss >> x;
+  BOOST_TEST_EQ(x, 0x010203040506070ULL);
+
+  ss.clear();
+  ss << lu64;
+  ss >> x;
+  BOOST_TEST_EQ(x, 0x010203040506070ULL);
+
+  ss.clear();
+  ss << 0x010203040506070ULL;
+  be::big_uint64_t bu64z(0);
+  ss >> bu64z;
+  BOOST_TEST_EQ(bu64z, bu64);
+
+  ss.clear();
+  ss << 0x010203040506070ULL;
+  be::little_uint64_t lu64z(0);
+  ss >> lu64z;
+  BOOST_TEST_EQ(lu64z, lu64);
+
+  std::cout << "test inserter and extractor complete" << std::endl;
+
+}
+
+void f_big_int32_ut(be::big_int32_t) {}
+
+//  main  ------------------------------------------------------------------------------//
+
+int cpp_main(int, char * [])
+{
+  be::endian_log = false;
+
+  //  make sure some simple things work
+
+  be::big_int32_t o1(1);
+  be::big_int32_t o2(2L);
+  be::big_int32_t o3(3LL);
+  be::big_int64_t o4(1);
+
+  //  use cases; if BOOST_ENDIAN_LOG is defined, will output to clog info on
+  //  what overloads and conversions are actually being performed.
+
+  be::endian_log = true;
+
+  std::clog << "set up test values\n";
+  be::big_int32_t      big(12345);
+  be::little_uint16_t  little_u(10);
+  be::big_int64_t      result;
+
+  // this is the use case that is so irritating that it caused the endian
+  // constructors to be made non-explicit
+  std::clog << "\nf(1234) where f(big_int32_t)\n";
+  f_big_int32_ut(1234);
+
+  std::clog << "\nresult = big\n";
+  result = big;
+
+  std::clog << "\nresult = +big\n";
+  result = +big;
+
+  std::clog << "\nresult = -big\n";
+  result = -big;
+
+  std::clog << "\n++big\n";
+  ++big;
+
+  std::clog << "\nresult = big++\n";
+  result = big++;
+
+  std::clog << "\n--big\n";
+  --big;
+
+  std::clog << "\nbig--\n";
+  big--;
+
+  std::clog << "\nresult = big * big\n";
+  result = big * big;
+
+  std::clog << "\nresult = big * big\n";
+  result = big * big;
+
+  std::clog << "\nresult = big * little_u\n";
+  result = big * little_u;
+
+  std::clog << "\nbig *= little_u\n";
+  big *= little_u;
+
+  std::clog << "\nresult = little_u * big\n";
+  result = little_u * big;
+
+  std::clog << "\nresult = big * 5\n";
+  result = big * 5;
+
+  std::clog << "\nbig *= 5\n";
+  big *= 5;
+
+  std::clog << "\nresult = 5 * big\n";
+  result = 5 * big;
+
+  std::clog << "\nresult = little_u * 5\n";
+  result = little_u * 5;
+
+  std::clog << "\nresult = 5 * little_u\n";
+  result = 5 * little_u;
+
+  std::clog << "\nresult = 5 * 10\n";
+  result = 5 * 10;
+  std::clog << "\n";
+
+  //  test from Roland Schwarz that detected ambiguities; these ambiguities
+  //  were eliminated by BOOST_ENDIAN_MINIMAL_COVER_OPERATORS
+  unsigned u;
+  be::little_uint32_t u1;
+  be::little_uint32_t u2;
+
+  u = 9;
+  u1 = 1;
+  std::clog << "\nu2 = u1 + u\n";
+  u2 = u1 + u;
+  std::clog << "\n";
+
+  // variations to detect ambiguities
+
+  be::little_uint32_t u3 = u1 + 5;
+  u3 = u1 + 5u;
+
+  if (u1 == 5)
+    {}
+  if (u1 == 5u)
+    {}
+
+  u1 += 5;
+  u1 += 5u;
+
+  u2 = u1 + 5;
+  u2 = u1 + 5u;
+
+  //  one more wrinkle
+  be::little_uint16_t u4(3);
+  u4 = 3;
+  std::clog << "\nu2 = u1 + u4\n";
+  u2 = u1 + u4;
+  std::clog << "\n";
+
+  be::endian_log = false;
+
+  test_inserter_and_extractor();
+    
+  //  perform the indicated test on ~60*60 operand types
+
+  op_test<default_construct>();
+  op_test<construct>();  // includes copy construction
+  op_test<initialize>();
+  op_test<assign>();
+  op_test<relational>();
+  op_test<op_plus>();
+  op_test<op_star>();
+
+  return boost::report_errors();
+}
diff --git a/libs/endian/test/endian_test.cpp b/libs/endian/test/endian_test.cpp
new file mode 100644
index 0000000..82f2092
--- /dev/null
+++ b/libs/endian/test/endian_test.cpp
@@ -0,0 +1,812 @@
+//  endian_test.cpp  ---------------------------------------------------------//
+
+//  Copyright Beman Dawes 1999-2008
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See library home page at http://www.boost.org/libs/endian
+
+//----------------------------------------------------------------------------//
+
+//  This test probes for correct endianess, size, and value.
+
+//  See endian_operations_test for tests of operator correctness and interaction
+//  between operand types.
+
+//----------------------------------------------------------------------------//
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include <boost/endian/arithmetic.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/detail/lightweight_main.hpp>
+
+#include <iostream>
+#include <limits>
+#include <climits>
+#include <cstdlib>    // for atoi(), exit()
+#include <cstring>    // for memcmp()
+
+using namespace std;             // Not the best programming practice, but I
+using namespace boost;           //   want to verify this combination of using
+using namespace boost::endian;   //   namespaces works. See endian_operations_test
+//                               //   for tests that don't do "using namespace".
+
+#define VERIFY(predicate) verify( predicate, __LINE__ )
+#define VERIFY_SIZE(actual, expected) verify_size( actual, expected, __LINE__ )
+#define VERIFY_VALUE_AND_OPS(endian_t,expected_t,expected) verify_value_and_ops<endian_t, expected_t>( expected, __LINE__ )
+#define VERIFY_BIG_REPRESENTATION(t) verify_representation<t>( true, __LINE__ )
+#define VERIFY_LITTLE_REPRESENTATION(t) verify_representation<t>( false, __LINE__ )
+#define VERIFY_NATIVE_REPRESENTATION(t) verify_native_representation<t>( __LINE__ )
+
+namespace
+{
+  int err_count;
+
+  void verify( bool x, int line )
+  {
+    if ( x ) return;
+    ++err_count;
+    cout << "Error: verify failed on line " << line << endl;
+  }
+
+  void verify_size( size_t actual, size_t expected, int line )
+  {
+    if ( actual == expected ) return;
+    ++err_count;
+    cout << "Error: verify size failed on line " << line << endl;
+    cout << " A structure with an expected sizeof() " << expected
+         << " had an actual sizeof() " << actual
+         << "\n This will cause uses of endian types to fail\n";
+  } 
+
+  template <class Endian, class Base>
+  void verify_value_and_ops( const Base & expected, int line )
+  {
+    Endian v( expected );
+    verify( v == expected, line );
+
+    Endian v2;
+    v2.operator=( expected );
+    verify( v2 == expected, line );
+
+    ++v; // verify integer_cover_operators being applied to this type -
+         // will fail to compile if no endian<> specialization is present
+
+    Endian x(static_cast<typename Endian::value_type>(v+v));
+    if ( x == x ) // silence warning
+      return;
+  }
+
+  const char * big_rep    = "\x12\x34\x56\x78\x9A\xBC\xDE\xF0";
+  const char * little_rep = "\xF0\xDE\xBC\x9A\x78\x56\x34\x12";
+
+  template <class Endian>
+  void verify_representation( bool is_big, int line )
+  {
+    int silence = 0;
+    Endian x ( static_cast<typename Endian::value_type>
+      (0x123456789abcdef0LL + silence) ); // will truncate
+
+    if ( is_big )
+      verify( memcmp( &x,
+        reinterpret_cast<const char*>(big_rep)+8-sizeof(Endian),
+          sizeof(Endian) ) == 0, line );
+    else
+      verify( memcmp( &x, little_rep, sizeof(Endian) ) == 0, line );
+  }
+
+  template <class Endian>
+  inline void verify_native_representation( int line )
+  {
+#   ifdef BOOST_BIG_ENDIAN
+      verify_representation<Endian>( true, line );
+#   else
+      verify_representation<Endian>( false, line );
+#   endif
+  }
+
+  //  detect_order  -----------------------------------------------------//
+
+  void detect_order()
+  {
+    union View
+    { 
+      long long i;
+      unsigned char c[8];
+    };
+
+    View v = { 0x0102030405060708LL };  // initialize v.i
+    
+    if ( memcmp( v.c, "\x8\7\6\5\4\3\2\1", 8) == 0 )
+    {
+      cout << "This machine is little-endian.\n";
+  #   ifndef BOOST_LITTLE_ENDIAN
+        cout << "yet boost/detail/endian.hpp does not define BOOST_LITTLE_ENDIAN.\n"
+          "The Boost Endian library must be revised to work correctly on this system.\n"
+          "Please report this problem to the Boost mailing list.\n";
+        exit(1);
+  #   endif
+    } 
+    else if ( memcmp( v.c, "\1\2\3\4\5\6\7\x8", 8) == 0 )
+    {
+      cout << "This machine is big-endian.\n";
+  #   ifndef BOOST_BIG_ENDIAN
+        cout << "yet boost/detail/endian.hpp does not define BOOST_BIG_ENDIAN.\n"
+          "The Boost Endian library must be revised to work correctly on this system.\n"
+          "Please report this problem to the Boost mailing list.\n";
+        exit(1);
+  #   endif
+    }
+    else
+    { 
+      cout << "This machine is neither strict big-endian nor strict little-endian\n"
+        "The Boost Endian library must be revised to work correctly on this system.\n"
+          "Please report this problem to the Boost mailing list.\n";
+      exit(1);
+    }
+    cout << "That should not matter and is presented for your information only.\n";
+  } // detect_order
+
+  //  check_data  ------------------------------------------------------------//
+
+  void check_data()
+  {
+    big_int8_t big_8;
+    big_int16_t big_16;
+    big_int24_t big_24;
+    big_int32_t big_32;
+    big_int40_t big_40;
+    big_int48_t big_48;
+    big_int56_t big_56;
+    big_int64_t big_64;
+
+    big_uint8_t big_u8;
+    big_uint16_t big_u16;
+    big_uint24_t big_u24;
+    big_uint32_t big_u32;
+    big_uint40_t big_u40;
+    big_uint48_t big_u48;
+    big_uint56_t big_u56;
+    big_uint64_t big_u64;
+
+    little_int8_t little_8;
+    little_int16_t little_16;
+    little_int24_t little_24;
+    little_int32_t little_32;
+    little_int40_t little_40;
+    little_int48_t little_48;
+    little_int56_t little_56;
+    little_int64_t little_64;
+
+    little_uint8_t little_u8;
+    little_uint16_t little_u16;
+    little_uint24_t little_u24;
+    little_uint32_t little_u32;
+    little_uint40_t little_u40;
+    little_uint48_t little_u48;
+    little_uint56_t little_u56;
+    little_uint64_t little_u64;
+
+    native_int8_t native_8;
+    native_int16_t native_16;
+    native_int24_t native_24;
+    native_int32_t native_32;
+    native_int40_t native_40;
+    native_int48_t native_48;
+    native_int56_t native_56;
+    native_int64_t native_64;
+
+    native_uint8_t native_u8;
+    native_uint16_t native_u16;
+    native_uint24_t native_u24;
+    native_uint32_t native_u32;
+    native_uint40_t native_u40;
+    native_uint48_t native_u48;
+    native_uint56_t native_u56;
+    native_uint64_t native_u64;
+
+    big_int16_at  big_align_int16;
+    big_int32_at  big_align_int32;
+    big_int64_at  big_align_int64;
+
+    big_uint16_at big_align_uint16;
+    big_uint32_at big_align_uint32;
+    big_uint64_at big_align_uint64;
+
+    little_int16_at  little_align_int16;
+    little_int32_at  little_align_int32;
+    little_int64_at  little_align_int64;
+
+    little_uint16_at little_align_uint16;
+    little_uint32_at little_align_uint32;
+    little_uint64_at little_align_uint64;
+
+    VERIFY(big_8.data() == reinterpret_cast<const char *>(&big_8));
+    VERIFY(big_16.data() == reinterpret_cast<const char *>(&big_16));
+    VERIFY(big_24.data() == reinterpret_cast<const char *>(&big_24));
+    VERIFY(big_32.data() == reinterpret_cast<const char *>(&big_32));
+    VERIFY(big_40.data() == reinterpret_cast<const char *>(&big_40));
+    VERIFY(big_48.data() == reinterpret_cast<const char *>(&big_48));
+    VERIFY(big_56.data() == reinterpret_cast<const char *>(&big_56));
+    VERIFY(big_64.data() == reinterpret_cast<const char *>(&big_64));
+
+    VERIFY(big_u8.data() == reinterpret_cast<const char *>(&big_u8));
+    VERIFY(big_u16.data() == reinterpret_cast<const char *>(&big_u16));
+    VERIFY(big_u24.data() == reinterpret_cast<const char *>(&big_u24));
+    VERIFY(big_u32.data() == reinterpret_cast<const char *>(&big_u32));
+    VERIFY(big_u40.data() == reinterpret_cast<const char *>(&big_u40));
+    VERIFY(big_u48.data() == reinterpret_cast<const char *>(&big_u48));
+    VERIFY(big_u56.data() == reinterpret_cast<const char *>(&big_u56));
+    VERIFY(big_u64.data() == reinterpret_cast<const char *>(&big_u64));
+
+    VERIFY(little_8.data() == reinterpret_cast<const char *>(&little_8));
+    VERIFY(little_16.data() == reinterpret_cast<const char *>(&little_16));
+    VERIFY(little_24.data() == reinterpret_cast<const char *>(&little_24));
+    VERIFY(little_32.data() == reinterpret_cast<const char *>(&little_32));
+    VERIFY(little_40.data() == reinterpret_cast<const char *>(&little_40));
+    VERIFY(little_48.data() == reinterpret_cast<const char *>(&little_48));
+    VERIFY(little_56.data() == reinterpret_cast<const char *>(&little_56));
+    VERIFY(little_64.data() == reinterpret_cast<const char *>(&little_64));
+
+    VERIFY(little_u8.data() == reinterpret_cast<const char *>(&little_u8));
+    VERIFY(little_u16.data() == reinterpret_cast<const char *>(&little_u16));
+    VERIFY(little_u24.data() == reinterpret_cast<const char *>(&little_u24));
+    VERIFY(little_u32.data() == reinterpret_cast<const char *>(&little_u32));
+    VERIFY(little_u40.data() == reinterpret_cast<const char *>(&little_u40));
+    VERIFY(little_u48.data() == reinterpret_cast<const char *>(&little_u48));
+    VERIFY(little_u56.data() == reinterpret_cast<const char *>(&little_u56));
+    VERIFY(little_u64.data() == reinterpret_cast<const char *>(&little_u64));
+
+    VERIFY(native_8.data() == reinterpret_cast<const char *>(&native_8));
+    VERIFY(native_16.data() == reinterpret_cast<const char *>(&native_16));
+    VERIFY(native_24.data() == reinterpret_cast<const char *>(&native_24));
+    VERIFY(native_32.data() == reinterpret_cast<const char *>(&native_32));
+    VERIFY(native_40.data() == reinterpret_cast<const char *>(&native_40));
+    VERIFY(native_48.data() == reinterpret_cast<const char *>(&native_48));
+    VERIFY(native_56.data() == reinterpret_cast<const char *>(&native_56));
+    VERIFY(native_64.data() == reinterpret_cast<const char *>(&native_64));
+
+    VERIFY(native_u8.data() == reinterpret_cast<const char *>(&native_u8));
+    VERIFY(native_u16.data() == reinterpret_cast<const char *>(&native_u16));
+    VERIFY(native_u24.data() == reinterpret_cast<const char *>(&native_u24));
+    VERIFY(native_u32.data() == reinterpret_cast<const char *>(&native_u32));
+    VERIFY(native_u40.data() == reinterpret_cast<const char *>(&native_u40));
+    VERIFY(native_u48.data() == reinterpret_cast<const char *>(&native_u48));
+    VERIFY(native_u56.data() == reinterpret_cast<const char *>(&native_u56));
+    VERIFY(native_u64.data() == reinterpret_cast<const char *>(&native_u64));
+
+    VERIFY(big_align_int16.data() == reinterpret_cast<const char *>(&big_align_int16));
+    VERIFY(big_align_int32.data() == reinterpret_cast<const char *>(&big_align_int32));
+    VERIFY(big_align_int64.data() == reinterpret_cast<const char *>(&big_align_int64));
+
+    VERIFY(big_align_uint16.data() == reinterpret_cast<const char *>(&big_align_uint16));
+    VERIFY(big_align_uint32.data() == reinterpret_cast<const char *>(&big_align_uint32));
+    VERIFY(big_align_uint64.data() == reinterpret_cast<const char *>(&big_align_uint64));
+
+    VERIFY(little_align_int16.data() == reinterpret_cast<const char *>(&little_align_int16));
+    VERIFY(little_align_int32.data() == reinterpret_cast<const char *>(&little_align_int32));
+    VERIFY(little_align_int64.data() == reinterpret_cast<const char *>(&little_align_int64));
+
+    VERIFY(little_align_uint16.data() == reinterpret_cast<const char *>(&little_align_uint16));
+    VERIFY(little_align_uint32.data() == reinterpret_cast<const char *>(&little_align_uint32));
+    VERIFY(little_align_uint64.data() == reinterpret_cast<const char *>(&little_align_uint64));
+ 
+  }
+
+  //  check_size  ------------------------------------------------------------//
+
+  void check_size()
+  {
+    VERIFY( numeric_limits<signed char>::digits == 7 );
+    VERIFY( numeric_limits<unsigned char>::digits == 8 );
+
+    VERIFY_SIZE( sizeof( big_int8_t ), 1 );
+    VERIFY_SIZE( sizeof( big_int16_t ), 2 );
+    VERIFY_SIZE( sizeof( big_int24_t ), 3 );
+    VERIFY_SIZE( sizeof( big_int32_t ), 4 );
+    VERIFY_SIZE( sizeof( big_int40_t ), 5 );
+    VERIFY_SIZE( sizeof( big_int48_t ), 6 );
+    VERIFY_SIZE( sizeof( big_int56_t ), 7 );
+    VERIFY_SIZE( sizeof( big_int64_t ), 8 );
+
+    VERIFY_SIZE( sizeof( big_uint8_t ), 1 );
+    VERIFY_SIZE( sizeof( big_uint16_t ), 2 );
+    VERIFY_SIZE( sizeof( big_uint24_t ), 3 );
+    VERIFY_SIZE( sizeof( big_uint32_t ), 4 );
+    VERIFY_SIZE( sizeof( big_uint40_t ), 5 );
+    VERIFY_SIZE( sizeof( big_uint48_t ), 6 );
+    VERIFY_SIZE( sizeof( big_uint56_t ), 7 );
+    VERIFY_SIZE( sizeof( big_uint64_t ), 8 );
+
+    VERIFY_SIZE( sizeof( little_int8_t ), 1 );
+    VERIFY_SIZE( sizeof( little_int16_t ), 2 );
+    VERIFY_SIZE( sizeof( little_int24_t ), 3 );
+    VERIFY_SIZE( sizeof( little_int32_t ), 4 );
+    VERIFY_SIZE( sizeof( little_int40_t ), 5 );
+    VERIFY_SIZE( sizeof( little_int48_t ), 6 );
+    VERIFY_SIZE( sizeof( little_int56_t ), 7 );
+    VERIFY_SIZE( sizeof( little_int64_t ), 8 );
+
+    VERIFY_SIZE( sizeof( little_uint8_t ), 1 );
+    VERIFY_SIZE( sizeof( little_uint16_t ), 2 );
+    VERIFY_SIZE( sizeof( little_uint24_t ), 3 );
+    VERIFY_SIZE( sizeof( little_uint32_t ), 4 );
+    VERIFY_SIZE( sizeof( little_uint40_t ), 5 );
+    VERIFY_SIZE( sizeof( little_uint48_t ), 6 );
+    VERIFY_SIZE( sizeof( little_uint56_t ), 7 );
+    VERIFY_SIZE( sizeof( little_uint64_t ), 8 );
+
+    VERIFY_SIZE( sizeof( native_int8_t ), 1 );
+    VERIFY_SIZE( sizeof( native_int16_t ), 2 );
+    VERIFY_SIZE( sizeof( native_int24_t ), 3 );
+    VERIFY_SIZE( sizeof( native_int32_t ), 4 );
+    VERIFY_SIZE( sizeof( native_int40_t ), 5 );
+    VERIFY_SIZE( sizeof( native_int48_t ), 6 );
+    VERIFY_SIZE( sizeof( native_int56_t ), 7 );
+    VERIFY_SIZE( sizeof( native_int64_t ), 8 );
+
+    VERIFY_SIZE( sizeof( native_uint8_t ), 1 );
+    VERIFY_SIZE( sizeof( native_uint16_t ), 2 );
+    VERIFY_SIZE( sizeof( native_uint24_t ), 3 );
+    VERIFY_SIZE( sizeof( native_uint32_t ), 4 );
+    VERIFY_SIZE( sizeof( native_uint40_t ), 5 );
+    VERIFY_SIZE( sizeof( native_uint48_t ), 6 );
+    VERIFY_SIZE( sizeof( native_uint56_t ), 7 );
+    VERIFY_SIZE( sizeof( native_uint64_t ), 8 );
+
+    VERIFY_SIZE(sizeof(big_int8_at), 1);
+    VERIFY_SIZE(sizeof(big_int16_at), 2);
+    VERIFY_SIZE( sizeof( big_int32_at ), 4 );
+    VERIFY_SIZE( sizeof( big_int64_at ), 8 );
+
+    VERIFY_SIZE(sizeof(big_uint8_at), 1);
+    VERIFY_SIZE(sizeof(big_uint16_at), 2);
+    VERIFY_SIZE( sizeof( big_uint32_at ), 4 );
+    VERIFY_SIZE( sizeof( big_uint64_at ), 8 );
+
+    VERIFY_SIZE(sizeof(little_int8_at), 1);
+    VERIFY_SIZE(sizeof(little_int16_at), 2);
+    VERIFY_SIZE( sizeof( little_int32_at ), 4 );
+    VERIFY_SIZE( sizeof( little_int64_at ), 8 );
+
+    VERIFY_SIZE(sizeof(little_uint8_at), 1);
+    VERIFY_SIZE(sizeof(little_uint16_at), 2);
+    VERIFY_SIZE( sizeof( little_uint32_at ), 4 );
+    VERIFY_SIZE( sizeof( little_uint64_at ), 8 );
+  } // check_size
+
+  //  check_alignment  -------------------------------------------------------//
+
+  void check_alignment()
+  {
+    // structs with offsets % 2 == 1 for type of size > 1 to ensure no alignment
+    // bytes added for any size > 1
+
+    struct big_struct
+    {
+      big_int8_t    v0;
+      big_int16_t    v1;
+      big_int24_t    v3;
+      char      v6;
+      big_int32_t    v7;
+      big_int40_t    v11;
+      char      v16;
+      big_int48_t    v17;
+      big_int56_t    v23;
+      char      v30;
+      big_int64_t    v31;
+    };
+
+    struct big_u_struct
+    {
+      big_uint8_t    v0;
+      big_uint16_t    v1;
+      big_uint24_t    v3;
+      char       v6;
+      big_uint32_t    v7;
+      big_uint40_t    v11;
+      char       v16;
+      big_uint48_t    v17;
+      big_uint56_t    v23;
+      char       v30;
+      big_uint64_t    v31;
+    };
+
+    struct little_struct
+    {
+      little_int8_t    v0;
+      little_int16_t    v1;
+      little_int24_t    v3;
+      char         v6;
+      little_int32_t    v7;
+      little_int40_t    v11;
+      char         v16;
+      little_int48_t    v17;
+      little_int56_t    v23;
+      char         v30;
+      little_int64_t    v31;
+    };
+
+    struct little_u_struct
+    {
+      little_uint8_t    v0;
+      little_uint16_t    v1;
+      little_uint24_t    v3;
+      char          v6;
+      little_uint32_t    v7;
+      little_uint40_t    v11;
+      char          v16;
+      little_uint48_t    v17;
+      little_uint56_t    v23;
+      char          v30;
+      little_uint64_t    v31;
+    };
+
+    struct native_struct
+    {
+      native_int8_t    v0;
+      native_int16_t    v1;
+      native_int24_t    v3;
+      char         v6;
+      native_int32_t    v7;
+      native_int40_t    v11;
+      char         v16;
+      native_int48_t    v17;
+      native_int56_t    v23;
+      char         v30;
+      native_int64_t    v31;
+    };
+
+    struct native_u_struct
+    {
+      native_uint8_t    v0;
+      native_uint16_t    v1;
+      native_uint24_t    v3;
+      char          v6;
+      native_uint32_t    v7;
+      native_uint40_t    v11;
+      char          v16;
+      native_uint48_t    v17;
+      native_uint56_t    v23;
+      char          v30;
+      native_uint64_t    v31;
+    };
+
+    //  aligned test cases
+  
+    struct big_aligned_struct
+    {
+      big_int16_at    v0;
+      big_int32_at    v1;
+      char          v3;
+      // on a 32-bit system, the padding here may be 3 rather than 7 bytes
+      big_int64_at    v4;
+    };
+  
+    struct little_aligned_struct
+    {
+      little_int16_at    v0;
+      little_int32_at    v1;
+      char          v3;
+      // on a 32-bit system, the padding here may be 3 rather than 7 bytes
+      little_int64_at    v4;
+    };
+
+    int saved_err_count = err_count;
+
+    VERIFY_SIZE( sizeof(big_struct), 39 );
+    VERIFY_SIZE( sizeof(big_u_struct), 39 );
+    VERIFY_SIZE( sizeof(little_struct), 39 );
+    VERIFY_SIZE( sizeof(little_u_struct), 39 );
+    VERIFY_SIZE( sizeof(native_struct), 39 );
+    VERIFY_SIZE( sizeof(native_u_struct), 39 );
+    VERIFY( sizeof(big_aligned_struct) <= 24 );
+    VERIFY( sizeof(little_aligned_struct) <= 24 );
+
+    if ( saved_err_count == err_count )
+    { 
+      cout <<
+        "Size and alignment for structures of endian types are as expected.\n";
+    }
+  } // check_alignment
+
+  //  check_representation_and_range_and_ops  --------------------------------//
+
+  void check_representation_and_range_and_ops()
+  {
+    // unaligned integer types
+    VERIFY_BIG_REPRESENTATION( big_int8_t );
+    VERIFY_VALUE_AND_OPS( big_int8_t, int_least8_t,  0x7f );
+    VERIFY_VALUE_AND_OPS( big_int8_t, int_least8_t, -0x80 );
+
+    VERIFY_BIG_REPRESENTATION( big_int16_t );
+    VERIFY_VALUE_AND_OPS( big_int16_t, int_least16_t,  0x7fff );
+    VERIFY_VALUE_AND_OPS( big_int16_t, int_least16_t, -0x8000 );
+
+    VERIFY_BIG_REPRESENTATION( big_int24_t );
+    VERIFY_VALUE_AND_OPS( big_int24_t, int_least32_t,  0x7fffff );
+    VERIFY_VALUE_AND_OPS( big_int24_t, int_least32_t, -0x800000 );
+
+    VERIFY_BIG_REPRESENTATION( big_int32_t );
+    VERIFY_VALUE_AND_OPS( big_int32_t, int_least32_t,  0x7fffffff );
+    VERIFY_VALUE_AND_OPS( big_int32_t, int_least32_t, -0x7fffffff-1 );
+
+    VERIFY_BIG_REPRESENTATION( big_int40_t );
+    VERIFY_VALUE_AND_OPS( big_int40_t, int_least64_t,  0x7fffffffffLL );
+    VERIFY_VALUE_AND_OPS( big_int40_t, int_least64_t, -0x8000000000LL );
+
+    VERIFY_BIG_REPRESENTATION( big_int48_t );
+    VERIFY_VALUE_AND_OPS( big_int48_t, int_least64_t,  0x7fffffffffffLL );
+    VERIFY_VALUE_AND_OPS( big_int48_t, int_least64_t, -0x800000000000LL );
+
+    VERIFY_BIG_REPRESENTATION( big_int56_t );
+    VERIFY_VALUE_AND_OPS( big_int56_t, int_least64_t,  0x7fffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( big_int56_t, int_least64_t, -0x80000000000000LL );
+
+    VERIFY_BIG_REPRESENTATION( big_int64_t );
+    VERIFY_VALUE_AND_OPS( big_int64_t, int_least64_t,  0x7fffffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( big_int64_t, int_least64_t, -0x7fffffffffffffffLL-1 );
+
+    VERIFY_BIG_REPRESENTATION( big_uint8_t );
+    VERIFY_VALUE_AND_OPS( big_uint8_t, uint_least8_t,  0xff );
+
+    VERIFY_BIG_REPRESENTATION( big_uint16_t );
+    VERIFY_VALUE_AND_OPS( big_uint16_t, uint_least16_t, 0xffff );
+
+    VERIFY_BIG_REPRESENTATION( big_uint24_t );
+    VERIFY_VALUE_AND_OPS( big_uint24_t, uint_least32_t, 0xffffff );
+
+    VERIFY_BIG_REPRESENTATION( big_uint32_t );
+    VERIFY_VALUE_AND_OPS( big_uint32_t, uint_least32_t, 0xffffffff );
+
+    VERIFY_BIG_REPRESENTATION( big_uint40_t );
+    VERIFY_VALUE_AND_OPS( big_uint40_t, uint_least64_t, 0xffffffffffLL );
+
+    VERIFY_BIG_REPRESENTATION( big_uint48_t );
+    VERIFY_VALUE_AND_OPS( big_uint48_t, uint_least64_t, 0xffffffffffffLL );
+
+    VERIFY_BIG_REPRESENTATION( big_uint56_t );
+    VERIFY_VALUE_AND_OPS( big_uint56_t, uint_least64_t, 0xffffffffffffffLL );
+
+    VERIFY_BIG_REPRESENTATION( big_uint64_t );
+    VERIFY_VALUE_AND_OPS( big_uint64_t, uint_least64_t, 0xffffffffffffffffULL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int8_t );
+    VERIFY_VALUE_AND_OPS( little_int8_t, int_least8_t,   0x7f );
+    VERIFY_VALUE_AND_OPS( little_int8_t, int_least8_t,  -0x80 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int16_t );
+    VERIFY_VALUE_AND_OPS( little_int16_t, int_least16_t,  0x7fff );
+    VERIFY_VALUE_AND_OPS( little_int16_t, int_least16_t, -0x8000 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int24_t );
+    VERIFY_VALUE_AND_OPS( little_int24_t, int_least32_t,  0x7fffff );
+    VERIFY_VALUE_AND_OPS( little_int24_t, int_least32_t, -0x800000 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int32_t );
+    VERIFY_VALUE_AND_OPS( little_int32_t, int_least32_t,  0x7fffffff );
+    VERIFY_VALUE_AND_OPS( little_int32_t, int_least32_t, -0x7fffffff-1 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int40_t );
+    VERIFY_VALUE_AND_OPS( little_int40_t, int_least64_t,  0x7fffffffffLL );
+    VERIFY_VALUE_AND_OPS( little_int40_t, int_least64_t, -0x8000000000LL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int48_t );
+    VERIFY_VALUE_AND_OPS( little_int48_t, int_least64_t,  0x7fffffffffffLL );
+    VERIFY_VALUE_AND_OPS( little_int48_t, int_least64_t, -0x800000000000LL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int56_t );
+    VERIFY_VALUE_AND_OPS( little_int56_t, int_least64_t,  0x7fffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( little_int56_t, int_least64_t, -0x80000000000000LL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int64_t );
+    VERIFY_VALUE_AND_OPS( little_int64_t, int_least64_t,  0x7fffffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( little_int64_t, int_least64_t, -0x7fffffffffffffffLL-1 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint8_t );
+    VERIFY_VALUE_AND_OPS( little_uint8_t, uint_least8_t, 0xff );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint16_t );
+    VERIFY_VALUE_AND_OPS( little_uint16_t, uint_least16_t, 0xffff );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint24_t );
+    VERIFY_VALUE_AND_OPS( little_uint24_t, uint_least32_t, 0xffffff );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint32_t );
+    VERIFY_VALUE_AND_OPS( little_uint32_t, uint_least32_t, 0xffffffff );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint40_t );
+    VERIFY_VALUE_AND_OPS( little_uint40_t, uint_least64_t, 0xffffffffffLL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint48_t );
+    VERIFY_VALUE_AND_OPS( little_uint48_t, uint_least64_t, 0xffffffffffffLL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint56_t );
+    VERIFY_VALUE_AND_OPS( little_uint56_t, uint_least64_t, 0xffffffffffffffLL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint64_t );
+    VERIFY_VALUE_AND_OPS( little_uint64_t, uint_least64_t, 0xffffffffffffffffULL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int8_t );
+    VERIFY_VALUE_AND_OPS( native_int8_t, int_least8_t,   0x7f );
+    VERIFY_VALUE_AND_OPS( native_int8_t, int_least8_t,  -0x80 );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int16_t );
+    VERIFY_VALUE_AND_OPS( native_int16_t, int_least16_t,  0x7fff );
+    VERIFY_VALUE_AND_OPS( native_int16_t, int_least16_t, -0x8000 );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int24_t );
+    VERIFY_VALUE_AND_OPS( native_int24_t, int_least32_t,  0x7fffff );
+    VERIFY_VALUE_AND_OPS( native_int24_t, int_least32_t, -0x800000 );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int32_t );
+    VERIFY_VALUE_AND_OPS( native_int32_t, int_least32_t,  0x7fffffff );
+    VERIFY_VALUE_AND_OPS( native_int32_t, int_least32_t, -0x7fffffff-1 );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int40_t );
+    VERIFY_VALUE_AND_OPS( native_int40_t, int_least64_t,  0x7fffffffffLL );
+    VERIFY_VALUE_AND_OPS( native_int40_t, int_least64_t, -0x8000000000LL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int48_t );
+    VERIFY_VALUE_AND_OPS( native_int48_t, int_least64_t,  0x7fffffffffffLL );
+    VERIFY_VALUE_AND_OPS( native_int48_t, int_least64_t, -0x800000000000LL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int56_t );
+    VERIFY_VALUE_AND_OPS( native_int56_t, int_least64_t,  0x7fffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( native_int56_t, int_least64_t, -0x80000000000000LL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_int64_t );
+    VERIFY_VALUE_AND_OPS( native_int64_t, int_least64_t,  0x7fffffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( native_int64_t, int_least64_t, -0x7fffffffffffffffLL-1 );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint8_t );
+    VERIFY_VALUE_AND_OPS( native_uint8_t, uint_least8_t, 0xff );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint16_t );
+    VERIFY_VALUE_AND_OPS( native_uint16_t, uint_least16_t, 0xffff );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint24_t );
+    VERIFY_VALUE_AND_OPS( native_uint24_t, uint_least32_t, 0xffffff );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint32_t );
+    VERIFY_VALUE_AND_OPS( native_uint32_t, uint_least32_t, 0xffffffff );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint40_t );
+    VERIFY_VALUE_AND_OPS( native_uint40_t, uint_least64_t, 0xffffffffffLL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint48_t );
+    VERIFY_VALUE_AND_OPS( native_uint48_t, uint_least64_t, 0xffffffffffffLL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint56_t );
+    VERIFY_VALUE_AND_OPS( native_uint56_t, uint_least64_t, 0xffffffffffffffLL );
+
+    VERIFY_NATIVE_REPRESENTATION( native_uint64_t );
+    VERIFY_VALUE_AND_OPS( native_uint64_t, uint_least64_t, 0xffffffffffffffffULL );
+
+    // aligned integer types
+    VERIFY_BIG_REPRESENTATION( big_int16_at );
+    VERIFY_VALUE_AND_OPS( big_int16_at, int_least16_t,  0x7fff );
+    VERIFY_VALUE_AND_OPS( big_int16_at, int_least16_t, -0x8000 );
+
+    VERIFY_BIG_REPRESENTATION( big_int32_at );
+    VERIFY_VALUE_AND_OPS( big_int32_at, int_least32_t,  0x7fffffff );
+    VERIFY_VALUE_AND_OPS( big_int32_at, int_least32_t, -0x7fffffff-1 );
+
+    VERIFY_BIG_REPRESENTATION( big_int64_at );
+    VERIFY_VALUE_AND_OPS( big_int64_at, int_least64_t,  0x7fffffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( big_int64_at, int_least64_t, -0x7fffffffffffffffLL-1 );
+
+    VERIFY_BIG_REPRESENTATION( big_uint16_at );
+    VERIFY_VALUE_AND_OPS( big_uint16_at, uint_least16_t, 0xffff );
+
+    VERIFY_BIG_REPRESENTATION( big_uint32_at );
+    VERIFY_VALUE_AND_OPS( big_uint32_at, uint_least32_t, 0xffffffff );
+
+    VERIFY_BIG_REPRESENTATION( big_uint64_at );
+    VERIFY_VALUE_AND_OPS( big_uint64_at, uint_least64_t, 0xffffffffffffffffULL );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int16_at );
+    VERIFY_VALUE_AND_OPS( little_int16_at, int_least16_t,  0x7fff );
+    VERIFY_VALUE_AND_OPS( little_int16_at, int_least16_t, -0x8000 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int32_at );
+    VERIFY_VALUE_AND_OPS( little_int32_at, int_least32_t,  0x7fffffff );
+    VERIFY_VALUE_AND_OPS( little_int32_at, int_least32_t, -0x7fffffff-1 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_int64_at );
+    VERIFY_VALUE_AND_OPS( little_int64_at, int_least64_t,  0x7fffffffffffffffLL );
+    VERIFY_VALUE_AND_OPS( little_int64_at, int_least64_t, -0x7fffffffffffffffLL-1 );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint16_at );
+    VERIFY_VALUE_AND_OPS( little_uint16_at, uint_least16_t, 0xffff );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint32_at );
+    VERIFY_VALUE_AND_OPS( little_uint32_at, uint_least32_t, 0xffffffff );
+
+    VERIFY_LITTLE_REPRESENTATION( little_uint64_at );
+    VERIFY_VALUE_AND_OPS( little_uint64_at, uint_least64_t, 0xffffffffffffffffULL );
+
+  } // check_representation_and_range
+
+  class MyInt
+  {
+    int32_t mx;
+  public:
+    MyInt(int32_t x) : mx(x) {}
+    operator int32_t() const {return mx;}
+
+    //friend int32_t operator+(const MyInt& x) {return x;}
+  };
+
+  void check_udt()
+  {
+    typedef boost::endian::endian_arithmetic< order::big, MyInt, 32 >  mybig_int32_ut;
+
+    mybig_int32_ut v(10);
+    cout << "+v is " << +v << endl;
+    v += 1;
+    cout << "v is " << +v << endl;
+    v -= 2;
+    cout << "v is " << +v << endl;
+    v *= 2;
+    cout << "v is " << +v << endl;
+    ++v;
+    cout << "v is " << +v << endl;
+    --v;
+    cout << "v is " << +v << endl;
+//    cout << "v+v is " << +(v+v) << endl;
+  }
+
+  long iterations = 10000;
+  
+  template< class Endian >
+  Endian timing_test( const char * s)
+  {
+    cout << s << " timing test, " << iterations << " iterations: ";
+//    progress_timer t;
+
+    Endian v = 1;
+    for ( long i = 0; i < iterations; ++i )
+    {
+      v += 1;
+      v *= 3;
+      ++v;
+      v *= i;
+      if ( i == 0 ) VERIFY_VALUE_AND_OPS( Endian, typename Endian::value_type, 21 );
+    }
+    return v;
+  }
+
+} // unnamed namespace
+
+//  main  ------------------------------------------------------------------------------//
+
+int cpp_main( int argc, char * argv[] )
+{
+  cout << "Usage: "
+       << argv[0] << " [#],\n where # specifies iteration count\n"
+          " default iteration count is " << iterations << endl;
+
+  if ( argc > 1 )
+    iterations = atol( argv[1] );
+  if ( iterations < 1 ) iterations = 1;
+
+  detect_order();
+  check_size();
+  check_alignment();
+  check_representation_and_range_and_ops();
+  check_data();
+  check_udt();
+
+  //timing_test<big_int32_t> ( "big_int32_t" );
+  //timing_test<big_int32_at>( "big_int32_at" );
+  //timing_test<little_int32_t> ( "little_int32_t" );
+  //timing_test<little_int32_at>( "little_int32_at" );
+
+  cout << "\n" << err_count << " errors detected\nTest "
+       << (err_count==0 ? "passed\n\n" : "failed\n\n");
+
+  return err_count ? 1 : 0;
+} // main
diff --git a/libs/endian/test/intrinsic_test.cpp b/libs/endian/test/intrinsic_test.cpp
new file mode 100644
index 0000000..4042106
--- /dev/null
+++ b/libs/endian/test/intrinsic_test.cpp
@@ -0,0 +1,27 @@
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+#include "test.hpp"
+#include <iostream>
+#include <boost/assert.hpp>
+
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+
+int main()
+{
+  std::cout << "BOOST_ENDIAN_INTRINSIC_MSG: " BOOST_ENDIAN_INTRINSIC_MSG << std::endl;
+
+#ifndef BOOST_ENDIAN_NO_INTRINSICS
+  uint16_t x2 = 0x1122U;
+  BOOST_ASSERT(BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_2(x2) == 0x2211U);
+  uint32_t x4 = 0x11223344UL;
+  BOOST_ASSERT(BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_4(x4) == 0x44332211UL);
+  uint64_t x8 = 0x1122334455667788U;
+  BOOST_ASSERT(BOOST_ENDIAN_INTRINSIC_BYTE_SWAP_8(x8) == 0x8877665544332211ULL);
+#endif
+  return 0;
+}
diff --git a/libs/endian/test/loop_time_test.cpp b/libs/endian/test/loop_time_test.cpp
new file mode 100644
index 0000000..f9c3ddf
--- /dev/null
+++ b/libs/endian/test/loop_time_test.cpp
@@ -0,0 +1,316 @@
+//  loop_time_test.cpp  ----------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+//#define BOOST_ENDIAN_NO_INTRINSICS
+//#define BOOST_ENDIAN_LOG
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include <boost/endian/conversion.hpp>
+#include <boost/endian/arithmetic.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/timer/timer.hpp>
+#include <iostream>
+#include <cstdlib>
+#include <string>
+#include <boost/detail/lightweight_main.hpp>
+
+#ifdef _MSC_VER
+#  pragma warning (push)
+#  pragma warning (disable : 4459)
+#endif
+#include <boost/lexical_cast.hpp>
+#ifdef _MSC_VER
+#  pragma warning (pop)
+#endif
+
+using namespace boost;
+using namespace boost::endian;
+
+using std::cout;
+using std::endl;
+
+namespace
+{
+  typedef  boost::timer::nanosecond_type nanosecond_t;
+  std::string command_args;
+  uint64_t n;                 // number of test cases to run
+  int places = 2;             // decimal places for times
+  bool verbose (false);
+  bool time_aligned (true);
+  bool time_unaligned (true);
+  bool time_16(true);
+  bool time_32(true);
+  bool time_64(true);
+
+  void process_command_line(int argc, char * argv[])
+  {
+    for (int a = 0; a < argc; ++a)
+    {
+      command_args += argv[a];
+      if (a != argc-1)
+        command_args += ' ';
+    }
+
+ //   cout << command_args << '\n';;
+
+    if (argc >=2)
+#ifndef _MSC_VER
+      n = atoll(argv[1]);
+#else
+      n = _atoi64(argv[1]);
+#endif
+
+    for (; argc > 2; ++argv, --argc) 
+    {
+      if ( *(argv[2]+1) == 'p' )
+        places = atoi( argv[2]+2 );
+      else if (*(argv[2] + 1) == 'v')
+        verbose = true;
+      else if (*(argv[2] + 1) == 'a')
+        time_unaligned = false;
+      else if (*(argv[2] + 1) == 'u')
+        time_aligned = false;
+      else if (*(argv[2] + 1) == '1')
+        time_32 = time_64 = false;
+      else if (*(argv[2] + 1) == '3')
+        time_16 = time_64 = false;
+      else if (*(argv[2] + 1) == '6')
+        time_16 = time_32 = false;
+      else
+      {
+        cout << "Error - unknown option: " << argv[2] << "\n\n";
+        argc = -1;
+        break;
+      }
+    }
+
+    if (argc < 2) 
+    {
+      cout << "Usage: loop_time_test n [Options]\n"
+              "  The argument n specifies the number of test cases to run\n"
+              "  Options:\n"
+              "   -v       Verbose messages\n"
+              "   -p#      Decimal places for times; default -p" << places << "\n"
+              "   -a       Aligned tests only\n"
+              "   -u       Unaligned tests only\n"
+              "   -16      16-bit tests only\n"
+              "   -32      32-bit tests only\n"
+              "   -64      64-bit tests only\n"
+              ;
+      return std::exit(1);
+    }
+  }
+
+  std::string with_digit_separator(int64_t x)
+  {
+    std::string s = boost::lexical_cast<std::string>(x);
+    std::string s2;
+
+    for (std::string::size_type i = 0; i < s.size(); ++i)
+    {
+      if (i && ((s.size()-i) % 3) == 0)
+        s2 += '\'';
+      s2 += s[i];
+    }
+    return s2;
+  }
+
+//--------------------------------------------------------------------------------------//
+
+  template <class T, class EndianT>
+  void time()
+  {
+    T total = 0;
+    { 
+ //     cout << "*************Endian integer approach...\n";
+      EndianT x(0);
+      boost::timer::cpu_timer t;
+      for (uint64_t i = 0; i < n; ++i)
+      {
+        x += static_cast<T>(i);
+      }
+      t.stop();
+      total += x;
+      cout << "<td align=\"right\">" << t.format(places, "%t") << " s</td>";
+    }
+    { 
+//      cout << "***************Endian conversion approach...\n";
+      T x(0);
+      boost::timer::cpu_timer t;
+      native_to_big_inplace(x);
+      for (uint64_t i = 0; i < n; ++i)
+      {
+        x += static_cast<T>(i);
+      }
+      big_to_native_inplace(x);
+      t.stop();
+      native_to_big_inplace(x);
+      if (x != total)
+        throw std::logic_error("integer approach total != conversion approach total");
+      cout << "<td align=\"right\">" << t.format(places, "%t") << " s</td>";
+    }
+  }
+
+ 
+  void test_big_align_int16()
+  {
+    cout << "<tr><td>16-bit aligned big endian</td>";
+    time<int16_t, big_int16_at>();
+    cout << "</tr>\n";
+  }
+
+  void test_little_align_int16()
+  {
+    cout << "<tr><td>16-bit aligned little endian</td>";
+    time<int16_t, little_int16_at>();
+    cout << "</tr>\n";
+  }
+
+  void test_big_int16()
+  {
+    cout << "<tr><td>16-bit unaligned big endian</td>";
+    time<int16_t, big_int16_t>();
+    cout << "</tr>\n";
+  }
+
+  void test_little_int16()
+  {
+    cout << "<tr><td>16-bit unaligned little endian</td>";
+    time<int16_t, little_int16_t>();
+    cout << "</tr>\n";
+  }
+ 
+  void test_big_align_int32()
+  {
+    cout << "<tr><td>32-bit aligned big endian</td>";
+    time<int32_t, big_int32_at>();
+    cout << "</tr>\n";
+  }
+
+  void test_little_align_int32()
+  {
+    cout << "<tr><td>32-bit aligned little endian</td>";
+    time<int32_t, little_int32_at>();
+    cout << "</tr>\n";
+  }
+
+  void test_big_int32()
+  {
+    cout << "<tr><td>32-bit unaligned big endian</td>";
+    time<int32_t, big_int32_t>();
+    cout << "</tr>\n";
+  }
+
+  void test_little_int32()
+  {
+    cout << "<tr><td>32-bit unaligned little endian</td>";
+    time<int32_t, little_int32_t>();
+    cout << "</tr>\n";
+  }
+ 
+  void test_big_align_int64()
+  {
+    cout << "<tr><td>64-bit aligned big endian</td>";
+    time<int64_t, big_int64_at>();
+    cout << "</tr>\n";
+  }
+
+  void test_little_align_int64()
+  {
+    cout << "<tr><td>64-bit aligned little endian</td>";
+    time<int64_t, little_int64_at>();
+    cout << "</tr>\n";
+  }
+
+  void test_big_int64()
+  {
+    cout << "<tr><td>64-bit unaligned big endian</td>";
+    time<int64_t, big_int64_t>();
+    cout << "</tr>\n";
+  }
+
+  void test_little_int64()
+  {
+    cout << "<tr><td>64-bit unaligned little endian</td>";
+    time<int64_t, little_int64_t>();
+    cout << "</tr>\n";
+  }
+
+}  // unnamed namespace
+
+//--------------------------------------------------------------------------------------//
+
+int cpp_main(int argc, char* argv[])
+{
+  process_command_line(argc, argv);
+  
+  cout
+    << "<html>\n<head>\n<title>Endian Loop Time Test</title>\n</head>\n<body>\n"
+    << "<!-- boost-no-inspect -->\n" 
+    << "<div align=\"center\"> <center>\n"
+    << "<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\""
+    << "style=\"border-collapse: collapse\" bordercolor=\"#111111\">\n"
+    << "<tr><td colspan=\"6\" align=\"center\"><b>"
+    << BOOST_COMPILER << "</b></td></tr>\n"
+    << "<tr><td colspan=\"6\" align=\"center\"><b>"
+    << " Iterations: " << with_digit_separator(n)
+    << ", Intrinsics: " BOOST_ENDIAN_INTRINSIC_MSG
+    << "</b></td></tr>\n"
+    << "<tr><td><b>Test Case</b></td>\n"
+    "<td align=\"center\"><b>Endian<br>arithmetic<br>type</b></td>\n"
+       "<td align=\"center\"><b>Endian<br>conversion<br>function</b></td>\n"
+       "</tr>\n"
+    ;
+  
+  if (time_aligned)
+  {
+    if (time_16)
+    {
+      test_big_align_int16();
+      test_little_align_int16();
+    }
+    if (time_32)
+    {
+      test_big_align_int32();
+      test_little_align_int32();
+    }
+    if (time_64)
+    {
+      test_big_align_int64();
+      test_little_align_int64();
+    }
+  }
+
+  if (time_unaligned)
+  {
+    if (time_16)
+    {
+      test_big_int16();
+      test_little_int16();
+    }
+    if (time_32)
+    {
+      test_big_int32();
+      test_little_int32();
+    }
+    if (time_64)
+    {
+      test_big_int64();
+      test_little_int64();
+    }
+  }
+
+  cout << "\n</div> </center>\n"
+       << "\n</table>\n</body>\n</html>\n";
+
+  return 0;
+}
+
+#include <boost/endian/detail/disable_warnings_pop.hpp>
diff --git a/libs/endian/test/msvc/associated-files/associated-files.vcxproj b/libs/endian/test/msvc/associated-files/associated-files.vcxproj
new file mode 100644
index 0000000..b93d787
--- /dev/null
+++ b/libs/endian/test/msvc/associated-files/associated-files.vcxproj
@@ -0,0 +1,137 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{D9C80FE0-20A6-4711-A3F4-676019BD5A06}</ProjectGuid>
+    <RootNamespace>associatedfiles</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup />
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\..\include\boost\endian\arithmetic.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\buffers.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\conversion.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\detail\config.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\detail\cover_operators.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\detail\disable_warnings.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\detail\disable_warnings_pop.hpp" />
+    <ClInclude Include="..\..\..\include\boost\endian\detail\intrinsic.hpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\..\..\doc\arithmetic.html" />
+    <None Include="..\..\..\doc\buffers.html" />
+    <None Include="..\..\..\doc\conversion.html" />
+    <None Include="..\..\..\doc\index.html" />
+    <None Include="..\..\..\doc\mini_review_topics.html" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/associated-files/associated-files.vcxproj.filters b/libs/endian/test/msvc/associated-files/associated-files.vcxproj.filters
new file mode 100644
index 0000000..6f7e8a4
--- /dev/null
+++ b/libs/endian/test/msvc/associated-files/associated-files.vcxproj.filters
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="HTML Files">
+      <UniqueIdentifier>{f0ee044b-7428-42ef-a455-a9b440bd64d3}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\..\include\boost\endian\arithmetic.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\buffers.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\conversion.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\detail\config.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\detail\cover_operators.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\detail\disable_warnings.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\detail\disable_warnings_pop.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\include\boost\endian\detail\intrinsic.hpp">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\..\..\doc\conversion.html">
+      <Filter>HTML Files</Filter>
+    </None>
+    <None Include="..\..\..\doc\buffers.html">
+      <Filter>HTML Files</Filter>
+    </None>
+    <None Include="..\..\..\doc\index.html">
+      <Filter>HTML Files</Filter>
+    </None>
+    <None Include="..\..\..\doc\mini_review_topics.html">
+      <Filter>HTML Files</Filter>
+    </None>
+    <None Include="..\..\..\doc\arithmetic.html">
+      <Filter>HTML Files</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/benchmark/benchmark.vcxproj b/libs/endian/test/msvc/benchmark/benchmark.vcxproj
new file mode 100644
index 0000000..ce4c26f
--- /dev/null
+++ b/libs/endian/test/msvc/benchmark/benchmark.vcxproj
@@ -0,0 +1,177 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{C9FEAE75-4DD9-44F5-B302-9910559A91BE}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>benchmark</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>BOOST_ALL_DYN_LINK;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 10 -v</Command>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>BOOST_ALL_DYN_LINK;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 10 -v</Command>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>BOOST_ALL_DYN_LINK;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 10000 -v</Command>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>BOOST_ALL_DYN_LINK;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 10000 -v</Command>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\benchmark.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/boost-no-inspect b/libs/endian/test/msvc/boost-no-inspect
new file mode 100644
index 0000000..e69de29
diff --git a/libs/endian/test/msvc/buffer_test/buffer_test.vcxproj b/libs/endian/test/msvc/buffer_test/buffer_test.vcxproj
new file mode 100644
index 0000000..2bb1bf2
--- /dev/null
+++ b/libs/endian/test/msvc/buffer_test/buffer_test.vcxproj
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>buffer_test</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\buffer_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/common.props b/libs/endian/test/msvc/common.props
new file mode 100644
index 0000000..8b8b2f0
--- /dev/null
+++ b/libs/endian/test/msvc/common.props
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir>$(SolutionName)\$(Configuration)\</OutDir>
+    <IntDir>$(SolutionName)\$(ProjectName)\$(Configuration)\</IntDir>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x86);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <AdditionalIncludeDirectories>..\..\..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <WarningLevel>EnableAllWarnings</WarningLevel>
+      <PreprocessorDefinitions>BOOST_LIGHTWEIGHT_TEST_OSTREAM=std::cout;BOOST_ALL_DYN_LINK;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <PostBuildEvent>
+      <Message>Executing test $(TargetName).exe...</Message>
+      <Command>"$(TargetDir)\$(TargetName).exe"</Command>
+    </PostBuildEvent>
+    <Link>
+      <AdditionalLibraryDirectories>../../../../..\stage\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/conversion_use_case/conversion_use_case.vcxproj b/libs/endian/test/msvc/conversion_use_case/conversion_use_case.vcxproj
new file mode 100644
index 0000000..8407ab8
--- /dev/null
+++ b/libs/endian/test/msvc/conversion_use_case/conversion_use_case.vcxproj
@@ -0,0 +1,157 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{1139E765-DE0F-497A-A7D9-EB2683521DF1}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>conversion_use_case</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\example\conversion_use_case.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/converter_test/converter_test.vcxproj b/libs/endian/test/msvc/converter_test/converter_test.vcxproj
new file mode 100644
index 0000000..3fa0723
--- /dev/null
+++ b/libs/endian/test/msvc/converter_test/converter_test.vcxproj
@@ -0,0 +1,169 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\conversion_test.cpp" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>converter_test</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Message>Executing test...</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/deprecated_test/deprecated_test.vcxproj b/libs/endian/test/msvc/deprecated_test/deprecated_test.vcxproj
new file mode 100644
index 0000000..7938d75
--- /dev/null
+++ b/libs/endian/test/msvc/deprecated_test/deprecated_test.vcxproj
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{DA4BC67F-9284-4D2C-81D5-407312C31BD7}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>deprecated_test</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\deprecated_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/endian.sln b/libs/endian/test/msvc/endian.sln
new file mode 100644
index 0000000..5ea8aec
--- /dev/null
+++ b/libs/endian/test/msvc/endian.sln
@@ -0,0 +1,160 @@
+
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.22609.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "endian_test", "endian_test\endian_test.vcxproj", "{74C201F3-8308-40BE-BC0F-24974DEAF405}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "endian_in_union_test", "endian_in_union_test\endian_in_union_test.vcxproj", "{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "endian_operations_test", "endian_operations_test\endian_operations_test.vcxproj", "{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "scoped_enum_emulation_test", "scoped_enum_emulation_test\scoped_enum_emulation_test.vcxproj", "{8420E151-B23B-4651-B526-6AB11EF1E278}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "endian_example", "endian_example\endian_example.vcxproj", "{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "benchmark", "benchmark\benchmark.vcxproj", "{C9FEAE75-4DD9-44F5-B302-9910559A91BE}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "converter_test", "converter_test\converter_test.vcxproj", "{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "udt_conversion_example", "udt_conversion_example\udt_conversion_example.vcxproj", "{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "speed_test", "speed_test\speed_test.vcxproj", "{5407AF29-59E9-4DE2-9939-F067576F7868}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "loop_time_test", "loop_time_test\loop_time_test.vcxproj", "{541A2D06-B34E-4592-BE47-F87DF47E73D8}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "buffer_test", "buffer_test\buffer_test.vcxproj", "{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "conversion_use_case", "conversion_use_case\conversion_use_case.vcxproj", "{1139E765-DE0F-497A-A7D9-EB2683521DF1}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "associated-files", "associated-files\associated-files.vcxproj", "{D9C80FE0-20A6-4711-A3F4-676019BD5A06}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "experiment", "experiment\experiment.vcxproj", "{CE9D8719-6E86-41D0-97CA-5BE5272594E9}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "deprecated_test", "deprecated_test\deprecated_test.vcxproj", "{DA4BC67F-9284-4D2C-81D5-407312C31BD7}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Debug|Win32.ActiveCfg = Debug|Win32
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Debug|Win32.Build.0 = Debug|Win32
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Debug|x64.ActiveCfg = Debug|x64
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Debug|x64.Build.0 = Debug|x64
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Release|Win32.ActiveCfg = Release|Win32
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Release|Win32.Build.0 = Release|Win32
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Release|x64.ActiveCfg = Release|x64
+		{74C201F3-8308-40BE-BC0F-24974DEAF405}.Release|x64.Build.0 = Release|x64
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Debug|Win32.ActiveCfg = Debug|Win32
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Debug|Win32.Build.0 = Debug|Win32
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Debug|x64.ActiveCfg = Debug|x64
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Debug|x64.Build.0 = Debug|x64
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Release|Win32.ActiveCfg = Release|Win32
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Release|Win32.Build.0 = Release|Win32
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Release|x64.ActiveCfg = Release|x64
+		{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}.Release|x64.Build.0 = Release|x64
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Debug|Win32.Build.0 = Debug|Win32
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Debug|x64.ActiveCfg = Debug|x64
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Debug|x64.Build.0 = Debug|x64
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Release|Win32.ActiveCfg = Release|Win32
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Release|Win32.Build.0 = Release|Win32
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Release|x64.ActiveCfg = Release|x64
+		{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}.Release|x64.Build.0 = Release|x64
+		{8420E151-B23B-4651-B526-6AB11EF1E278}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8420E151-B23B-4651-B526-6AB11EF1E278}.Debug|x64.ActiveCfg = Debug|x64
+		{8420E151-B23B-4651-B526-6AB11EF1E278}.Release|Win32.ActiveCfg = Release|Win32
+		{8420E151-B23B-4651-B526-6AB11EF1E278}.Release|x64.ActiveCfg = Release|x64
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Debug|Win32.Build.0 = Debug|Win32
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Debug|x64.ActiveCfg = Debug|x64
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Debug|x64.Build.0 = Debug|x64
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Release|Win32.ActiveCfg = Release|Win32
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Release|Win32.Build.0 = Release|Win32
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Release|x64.ActiveCfg = Release|x64
+		{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}.Release|x64.Build.0 = Release|x64
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Debug|Win32.ActiveCfg = Debug|Win32
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Debug|Win32.Build.0 = Debug|Win32
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Debug|x64.ActiveCfg = Debug|x64
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Debug|x64.Build.0 = Debug|x64
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Release|Win32.ActiveCfg = Release|Win32
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Release|Win32.Build.0 = Release|Win32
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Release|x64.ActiveCfg = Release|x64
+		{C9FEAE75-4DD9-44F5-B302-9910559A91BE}.Release|x64.Build.0 = Release|x64
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Debug|Win32.ActiveCfg = Debug|Win32
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Debug|Win32.Build.0 = Debug|Win32
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Debug|x64.ActiveCfg = Debug|x64
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Debug|x64.Build.0 = Debug|x64
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Release|Win32.ActiveCfg = Release|Win32
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Release|Win32.Build.0 = Release|Win32
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Release|x64.ActiveCfg = Release|x64
+		{EAE18F4D-AAF2-4C19-86FB-1144B5BD5993}.Release|x64.Build.0 = Release|x64
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Debug|Win32.ActiveCfg = Debug|Win32
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Debug|Win32.Build.0 = Debug|Win32
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Debug|x64.ActiveCfg = Debug|x64
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Debug|x64.Build.0 = Debug|x64
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Release|Win32.ActiveCfg = Release|Win32
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Release|Win32.Build.0 = Release|Win32
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Release|x64.ActiveCfg = Release|x64
+		{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}.Release|x64.Build.0 = Release|x64
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Debug|Win32.ActiveCfg = Debug|Win32
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Debug|Win32.Build.0 = Debug|Win32
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Debug|x64.ActiveCfg = Debug|x64
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Debug|x64.Build.0 = Debug|x64
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Release|Win32.ActiveCfg = Release|Win32
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Release|Win32.Build.0 = Release|Win32
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Release|x64.ActiveCfg = Release|x64
+		{5407AF29-59E9-4DE2-9939-F067576F7868}.Release|x64.Build.0 = Release|x64
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Debug|Win32.ActiveCfg = Debug|Win32
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Debug|Win32.Build.0 = Debug|Win32
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Debug|x64.ActiveCfg = Debug|x64
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Debug|x64.Build.0 = Debug|x64
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Release|Win32.ActiveCfg = Release|Win32
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Release|Win32.Build.0 = Release|Win32
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Release|x64.ActiveCfg = Release|x64
+		{541A2D06-B34E-4592-BE47-F87DF47E73D8}.Release|x64.Build.0 = Release|x64
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Debug|Win32.Build.0 = Debug|Win32
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Debug|x64.ActiveCfg = Debug|x64
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Debug|x64.Build.0 = Debug|x64
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Release|Win32.ActiveCfg = Release|Win32
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Release|Win32.Build.0 = Release|Win32
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Release|x64.ActiveCfg = Release|x64
+		{BFB68CF4-EB92-4E5C-9694-A939496C5CDE}.Release|x64.Build.0 = Release|x64
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Debug|Win32.ActiveCfg = Debug|Win32
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Debug|Win32.Build.0 = Debug|Win32
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Debug|x64.ActiveCfg = Debug|x64
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Debug|x64.Build.0 = Debug|x64
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Release|Win32.ActiveCfg = Release|Win32
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Release|Win32.Build.0 = Release|Win32
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Release|x64.ActiveCfg = Release|x64
+		{1139E765-DE0F-497A-A7D9-EB2683521DF1}.Release|x64.Build.0 = Release|x64
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Debug|Win32.Build.0 = Debug|Win32
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Debug|x64.ActiveCfg = Debug|x64
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Debug|x64.Build.0 = Debug|x64
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Release|Win32.ActiveCfg = Release|Win32
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Release|Win32.Build.0 = Release|Win32
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Release|x64.ActiveCfg = Release|x64
+		{D9C80FE0-20A6-4711-A3F4-676019BD5A06}.Release|x64.Build.0 = Release|x64
+		{CE9D8719-6E86-41D0-97CA-5BE5272594E9}.Debug|Win32.ActiveCfg = Debug|Win32
+		{CE9D8719-6E86-41D0-97CA-5BE5272594E9}.Debug|Win32.Build.0 = Debug|Win32
+		{CE9D8719-6E86-41D0-97CA-5BE5272594E9}.Debug|x64.ActiveCfg = Debug|Win32
+		{CE9D8719-6E86-41D0-97CA-5BE5272594E9}.Release|Win32.ActiveCfg = Release|Win32
+		{CE9D8719-6E86-41D0-97CA-5BE5272594E9}.Release|Win32.Build.0 = Release|Win32
+		{CE9D8719-6E86-41D0-97CA-5BE5272594E9}.Release|x64.ActiveCfg = Release|Win32
+		{DA4BC67F-9284-4D2C-81D5-407312C31BD7}.Debug|Win32.ActiveCfg = Debug|Win32
+		{DA4BC67F-9284-4D2C-81D5-407312C31BD7}.Debug|Win32.Build.0 = Debug|Win32
+		{DA4BC67F-9284-4D2C-81D5-407312C31BD7}.Debug|x64.ActiveCfg = Debug|Win32
+		{DA4BC67F-9284-4D2C-81D5-407312C31BD7}.Release|Win32.ActiveCfg = Release|Win32
+		{DA4BC67F-9284-4D2C-81D5-407312C31BD7}.Release|Win32.Build.0 = Release|Win32
+		{DA4BC67F-9284-4D2C-81D5-407312C31BD7}.Release|x64.ActiveCfg = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/libs/endian/test/msvc/endian_example/endian_example.vcxproj b/libs/endian/test/msvc/endian_example/endian_example.vcxproj
new file mode 100644
index 0000000..6227f65
--- /dev/null
+++ b/libs/endian/test/msvc/endian_example/endian_example.vcxproj
@@ -0,0 +1,165 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8638A3D8-D121-40BF-82E5-127F1B1B2CB2}</ProjectGuid>
+    <RootNamespace>endian_example</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\example\endian_example.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/endian_in_union_test/endian_in_union_test.vcxproj b/libs/endian/test/msvc/endian_in_union_test/endian_in_union_test.vcxproj
new file mode 100644
index 0000000..8a1fb42
--- /dev/null
+++ b/libs/endian/test/msvc/endian_in_union_test/endian_in_union_test.vcxproj
@@ -0,0 +1,169 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{3926C6DC-9D1E-4227-BEF5-81F5EC621A75}</ProjectGuid>
+    <RootNamespace>endian_in_union_test</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\endian_in_union_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/endian_operations_test/endian_operations_test.vcxproj b/libs/endian/test/msvc/endian_operations_test/endian_operations_test.vcxproj
new file mode 100644
index 0000000..b12158c
--- /dev/null
+++ b/libs/endian/test/msvc/endian_operations_test/endian_operations_test.vcxproj
@@ -0,0 +1,179 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{A0060A5B-673C-4AD8-BD08-A5C643B1A1CB}</ProjectGuid>
+    <RootNamespace>endian_operations_test</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessToFile>false</PreprocessToFile>
+      <PreprocessSuppressLineNumbers>false</PreprocessSuppressLineNumbers>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <DisableSpecificWarnings>4552;%(DisableSpecificWarnings)</DisableSpecificWarnings>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessToFile>false</PreprocessToFile>
+      <PreprocessSuppressLineNumbers>false</PreprocessSuppressLineNumbers>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <DisableSpecificWarnings>4552;%(DisableSpecificWarnings)</DisableSpecificWarnings>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\endian_operations_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/endian_test/endian_test.vcxproj b/libs/endian/test/msvc/endian_test/endian_test.vcxproj
new file mode 100644
index 0000000..c8e2975
--- /dev/null
+++ b/libs/endian/test/msvc/endian_test/endian_test.vcxproj
@@ -0,0 +1,171 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{74C201F3-8308-40BE-BC0F-24974DEAF405}</ProjectGuid>
+    <RootNamespace>endian_test</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\endian_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/loop_time_test/loop_time_test.vcxproj b/libs/endian/test/msvc/loop_time_test/loop_time_test.vcxproj
new file mode 100644
index 0000000..afcf071
--- /dev/null
+++ b/libs/endian/test/msvc/loop_time_test/loop_time_test.vcxproj
@@ -0,0 +1,167 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{541A2D06-B34E-4592-BE47-F87DF47E73D8}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>loop_time_test</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 1234</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 1</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 100000000</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+      <AssemblerListingLocation>c:/temp/</AssemblerListingLocation>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 1000000000</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\loop_time_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/scoped_enum_emulation_test/scoped_enum_emulation_test.vcxproj b/libs/endian/test/msvc/scoped_enum_emulation_test/scoped_enum_emulation_test.vcxproj
new file mode 100644
index 0000000..0c03ad5
--- /dev/null
+++ b/libs/endian/test/msvc/scoped_enum_emulation_test/scoped_enum_emulation_test.vcxproj
@@ -0,0 +1,165 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8420E151-B23B-4651-B526-6AB11EF1E278}</ProjectGuid>
+    <RootNamespace>scoped_enum_emulation_test</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\scoped_enum_emulation_test.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/speed_test/speed_test.vcxproj b/libs/endian/test/msvc/speed_test/speed_test.vcxproj
new file mode 100644
index 0000000..f46ee7b
--- /dev/null
+++ b/libs/endian/test/msvc/speed_test/speed_test.vcxproj
@@ -0,0 +1,166 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{5407AF29-59E9-4DE2-9939-F067576F7868}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>speed_test</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 1000000</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 1000000</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 100000000</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <PostBuildEvent>
+      <Command>"$(TargetDir)\$(TargetName).exe" 100000000</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\speed_test.cpp" />
+    <ClCompile Include="..\..\speed_test_functions.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/udt_conversion_example/udt_conversion_example.vcxproj b/libs/endian/test/msvc/udt_conversion_example/udt_conversion_example.vcxproj
new file mode 100644
index 0000000..5515abe
--- /dev/null
+++ b/libs/endian/test/msvc/udt_conversion_example/udt_conversion_example.vcxproj
@@ -0,0 +1,153 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{27A53564-D32B-4A32-8A6E-2F3BD252EEBA}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>udt_conversion_example</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\example\udt_conversion_example.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/msvc/uses_cases/uses_cases.vcxproj b/libs/endian/test/msvc/uses_cases/uses_cases.vcxproj
new file mode 100644
index 0000000..b775b12
--- /dev/null
+++ b/libs/endian/test/msvc/uses_cases/uses_cases.vcxproj
@@ -0,0 +1,157 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{36BF451A-EAEF-4140-92E4-6EA461A26107}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>uses_cases</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\common.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <ExecutablePath>..\..\..\..\..\stage\lib;$(VC_ExecutablePath_x64);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\example\use_cases.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/libs/endian/test/scoped_enum_emulation_test.cpp b/libs/endian/test/scoped_enum_emulation_test.cpp
new file mode 100644
index 0000000..e50ea70
--- /dev/null
+++ b/libs/endian/test/scoped_enum_emulation_test.cpp
@@ -0,0 +1,48 @@
+//  scoped_enum_emulation_test.cpp  ----------------------------------------------------//
+
+//  Copyright Beman Dawes, 2009
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+//  See documentation at http://www.boost.org/libs/utility/scoped_enum_emulation.html
+
+// #include <boost/detail/disable_warnings.hpp>
+// #include <boost/config/warning_disable.hpp>
+
+
+#include <boost/detail/scoped_enum_emulation.hpp>
+#include <boost/assert.hpp>
+
+BOOST_SCOPED_ENUM_START(traffic_light) { red=0, yellow, green }; BOOST_SCOPED_ENUM_END
+
+BOOST_SCOPED_ENUM_START(algae) { green=0, red, cyan }; BOOST_SCOPED_ENUM_END
+
+struct color
+{
+  BOOST_SCOPED_ENUM_START(value_t) { red, green, blue }; BOOST_SCOPED_ENUM_END
+  BOOST_SCOPED_ENUM(value_t) value;
+};
+
+void foo( BOOST_SCOPED_ENUM(algae) arg )
+{
+  BOOST_ASSERT( arg == algae::cyan );
+}
+
+int main()
+{
+  BOOST_SCOPED_ENUM(traffic_light) signal( traffic_light::red );
+  BOOST_SCOPED_ENUM(algae) sample( algae::red );
+
+  BOOST_ASSERT( signal == traffic_light::red );
+  BOOST_ASSERT( sample == algae::red );
+
+  foo( algae::cyan );
+
+  color tracker;
+  tracker.value = color::value_t::blue;
+
+  if (tracker.value  == color::value_t::blue) return 0; // quiet warnings
+
+  return 0;
+}
diff --git a/libs/endian/test/speed_test.cpp b/libs/endian/test/speed_test.cpp
new file mode 100644
index 0000000..70fc92b
--- /dev/null
+++ b/libs/endian/test/speed_test.cpp
@@ -0,0 +1,195 @@
+//  speed_test.cpp  --------------------------------------------------------------------//
+
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+//#define BOOST_ENDIAN_NO_INTRINSICS
+//#define BOOST_ENDIAN_LOG
+
+#include <boost/endian/detail/disable_warnings.hpp>
+
+#include "speed_test_functions.hpp"
+#include <boost/endian/conversion.hpp>
+#include <boost/endian/arithmetic.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/timer/timer.hpp>
+#include <iostream>
+#include <cstdlib>
+#include <boost/detail/lightweight_main.hpp>
+
+using namespace boost;
+using namespace boost::endian;
+
+using std::cout;
+using std::endl;
+
+namespace
+{
+  typedef  boost::timer::nanosecond_type nanosecond_t;
+  std::string command_args;
+  uint64_t n;                 // number of test cases to run
+  int places = 2;             // decimal places for times
+  bool verbose (false);
+
+  void process_command_line(int argc, char * argv[])
+  {
+    for (int a = 0; a < argc; ++a)
+    {
+      command_args += argv[a];
+      if (a != argc-1)
+        command_args += ' ';
+    }
+
+ //   cout << command_args << '\n';;
+
+    if (argc >=2)
+#ifndef _MSC_VER
+      n = atoll(argv[1]);
+#else
+      n = _atoi64(argv[1]);
+#endif
+
+    for (; argc > 2; ++argv, --argc) 
+    {
+      if ( *(argv[2]+1) == 'p' )
+        places = atoi( argv[2]+2 );
+      else if ( *(argv[2]+1) == 'v' )
+        verbose = true;
+      else
+      {
+        cout << "Error - unknown option: " << argv[2] << "\n\n";
+        argc = -1;
+        break;
+      }
+    }
+
+    if (argc < 2) 
+    {
+      cout << "Usage: speed_test n [Options]\n"
+              "  The argument n specifies the number of test cases to run\n"
+              "  Options:\n"
+              "   -v       Verbose messages\n"
+              "   -p#      Decimal places for times; default -p" << places << "\n";
+      return std::exit(1);
+    }
+  }
+
+//--------------------------------------------------------------------------------------//
+
+  template <class T, class EndianT, class Function>
+  void time(Function f)
+  {
+    T x(0);
+    EndianT y(0);
+    boost::timer::cpu_timer t;                  
+    for (uint64_t i = 0; i < n; ++i)
+    {
+      f(x, y);
+    }
+    t.stop();
+    cout << "<td align=\"right\">" << t.format(places, "%t") << " s</td>";
+  }
+
+  void test_big_int16()
+  {
+    cout << "<tr><td>16-bit aligned big endian</td>";
+    time<int16_t, big_int16_t>(user::return_x_big_int16);
+    time<int16_t, big_int16_t>(user::return_x_value_big_int16);
+    time<int16_t, big_int16_t>(user::return_x_inplace_big_int16);
+    time<int16_t, big_int16_t>(user::return_y_big_int16);
+    cout << "</tr>\n";
+  }
+
+  void test_little_int16()
+  {
+    cout << "<tr><td>16-bit aligned little endian</td>";
+    time<int16_t, little_int16_t>(user::return_x_little_int16);
+    time<int16_t, little_int16_t>(user::return_x_value_little_int16);
+    time<int16_t, little_int16_t>(user::return_x_inplace_little_int16);
+    time<int16_t, little_int16_t>(user::return_y_little_int16);
+    cout << "</tr>\n";
+  }
+
+  void test_big_int32()
+  {
+    cout << "<tr><td>32-bit aligned big endian</td>";
+    time<int32_t, big_int32_t>(user::return_x_big_int32);
+    time<int32_t, big_int32_t>(user::return_x_value_big_int32);
+    time<int32_t, big_int32_t>(user::return_x_inplace_big_int32);
+    time<int32_t, big_int32_t>(user::return_y_big_int32);
+    cout << "</tr>\n";
+  }
+
+  void test_little_int32()
+  {
+    cout << "<tr><td>32-bit aligned little endian</td>";
+    time<int32_t, little_int32_t>(user::return_x_little_int32);
+    time<int32_t, little_int32_t>(user::return_x_value_little_int32);
+    time<int32_t, little_int32_t>(user::return_x_inplace_little_int32);
+    time<int32_t, little_int32_t>(user::return_y_little_int32);
+    cout << "</tr>\n";
+  }
+
+  void test_big_int64()
+  {
+    cout << "<tr><td>64-bit aligned big endian</td>";
+    time<int64_t, big_int64_t>(user::return_x_big_int64);
+    time<int64_t, big_int64_t>(user::return_x_value_big_int64);
+    time<int64_t, big_int64_t>(user::return_x_inplace_big_int64);
+    time<int64_t, big_int64_t>(user::return_y_big_int64);
+    cout << "</tr>\n";
+  }
+
+  void test_little_int64()
+  {
+    cout << "<tr><td>64-bit aligned little endian</td>";
+    time<int64_t, little_int64_t>(user::return_x_little_int64);
+    time<int64_t, little_int64_t>(user::return_x_value_little_int64);
+    time<int64_t, little_int64_t>(user::return_x_inplace_little_int64);
+    time<int64_t, little_int64_t>(user::return_y_little_int64);
+    cout << "</tr>\n";
+  }
+
+}  // unnamed namespace
+
+//--------------------------------------------------------------------------------------//
+
+int cpp_main(int argc, char* argv[])
+{
+  process_command_line(argc, argv);
+  
+  cout
+    << "<html>\n<head>\n<title>Endian Speed Test</title>\n</head>\n<body>\n"
+    << "<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\""
+    << "style=\"border-collapse: collapse\" bordercolor=\"#111111\">\n"
+    << "<tr><td colspan=\"6\" align=\"center\"><b>"
+    << BOOST_COMPILER << "</b></td></tr>\n"
+    << "<tr><td colspan=\"6\" align=\"center\"><b>"
+    << " Iterations: " << n
+    << ", Intrinsics: " BOOST_ENDIAN_INTRINSIC_MSG
+    << "</b></td></tr>\n"
+    << "<tr><td><b>Test Case</b></td>\n"
+       "<td align=\"center\"><b>int<br>arg</b></td>\n"
+       "<td align=\"center\"><b>int<br>value(arg)</b></td>\n"
+       "<td align=\"center\"><b>int<br>in place(arg)</b></td>\n"
+       "<td align=\"center\"><b>Endian<br>arg</b></td>\n"
+       "</tr>\n"
+    ;
+
+  test_big_int16();
+  test_little_int16();
+  test_big_int32();
+  test_little_int32();
+  test_big_int64();
+  test_little_int64();
+
+  cout << "\n</table>\n</body>\n</html>\n";
+
+  return 0;
+}
+
+#include <boost/endian/detail/disable_warnings_pop.hpp>
diff --git a/libs/endian/test/speed_test_functions.cpp b/libs/endian/test/speed_test_functions.cpp
new file mode 100644
index 0000000..518962d
--- /dev/null
+++ b/libs/endian/test/speed_test_functions.cpp
@@ -0,0 +1,96 @@
+//  speed_test_functions.cpp  ----------------------------------------------------------//
+                                                      
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+//  These functions are in a separate compilation unit partially to defeat optimizers
+//  and partially to create a worst case scenario. They are in a user namespace for
+//  realism.
+
+//--------------------------------------------------------------------------------------//
+
+#ifndef _SCL_SECURE_NO_WARNINGS
+# define _SCL_SECURE_NO_WARNINGS
+#endif
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+# define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#include "speed_test_functions.hpp"
+
+namespace user
+{
+
+  int16_t return_x_big_int16(int16_t x, big_int16_t) BOOST_NOEXCEPT { return x; }
+  int16_t return_x_little_int16(int16_t x, little_int16_t) BOOST_NOEXCEPT { return x; }
+  int16_t return_x_value_big_int16(int16_t x, big_int16_t) BOOST_NOEXCEPT
+  {
+    return conditional_reverse<order::native, order::big>(x);
+  }
+  int16_t return_x_value_little_int16(int16_t x, little_int16_t) BOOST_NOEXCEPT
+  {
+    return conditional_reverse<order::native, order::little>(x);
+  }
+  int16_t return_x_inplace_big_int16(int16_t x, big_int16_t) BOOST_NOEXCEPT
+  {
+    conditional_reverse_inplace<order::native, order::big>(x); return x;
+  }
+  int16_t return_x_inplace_little_int16(int16_t x, little_int16_t) BOOST_NOEXCEPT
+  {
+    conditional_reverse_inplace<order::native, order::little>(x); return x;
+  }
+  int16_t return_y_big_int16(int16_t x, big_int16_t y) BOOST_NOEXCEPT { return y; }
+  int16_t return_y_little_int16(int16_t x, little_int16_t y) BOOST_NOEXCEPT { return y; }
+
+  //------------------------------------------------------------------------------------//
+
+  int32_t return_x_big_int32(int32_t x, big_int32_t) BOOST_NOEXCEPT { return x; }
+  int32_t return_x_little_int32(int32_t x, little_int32_t) BOOST_NOEXCEPT { return x; }
+  int32_t return_x_value_big_int32(int32_t x, big_int32_t) BOOST_NOEXCEPT
+  {
+    return conditional_reverse<order::native, order::big>(x);
+  }
+  int32_t return_x_value_little_int32(int32_t x, little_int32_t) BOOST_NOEXCEPT
+  {
+    return conditional_reverse<order::native, order::little>(x);
+  }
+  int32_t return_x_inplace_big_int32(int32_t x, big_int32_t) BOOST_NOEXCEPT
+  {
+    conditional_reverse_inplace<order::native, order::big>(x); return x;
+  }
+  int32_t return_x_inplace_little_int32(int32_t x, little_int32_t) BOOST_NOEXCEPT
+  {
+    conditional_reverse_inplace<order::native, order::little>(x); return x;
+  }
+  int32_t return_y_big_int32(int32_t x, big_int32_t y) BOOST_NOEXCEPT { return y; }
+  int32_t return_y_little_int32(int32_t x, little_int32_t y) BOOST_NOEXCEPT { return y; }
+
+  //------------------------------------------------------------------------------------//
+
+  int64_t return_x_big_int64(int64_t x, big_int64_t) BOOST_NOEXCEPT { return x; }
+  int64_t return_x_little_int64(int64_t x, little_int64_t) BOOST_NOEXCEPT { return x; }
+  int64_t return_x_value_big_int64(int64_t x, big_int64_t) BOOST_NOEXCEPT
+  {
+    return conditional_reverse<order::native, order::big>(x);
+  }
+  int64_t return_x_value_little_int64(int64_t x, little_int64_t) BOOST_NOEXCEPT
+  {
+    return conditional_reverse<order::native, order::little>(x);
+  }
+  int64_t return_x_inplace_big_int64(int64_t x, big_int64_t) BOOST_NOEXCEPT
+  {
+    conditional_reverse_inplace<order::native, order::big>(x); return x;
+  }
+  int64_t return_x_inplace_little_int64(int64_t x, little_int64_t) BOOST_NOEXCEPT
+  {
+    conditional_reverse_inplace<order::native, order::little>(x); return x;
+  }
+  int64_t return_y_big_int64(int64_t x, big_int64_t y) BOOST_NOEXCEPT { return y; }
+  int64_t return_y_little_int64(int64_t x, little_int64_t y) BOOST_NOEXCEPT { return y; }
+
+}
diff --git a/libs/endian/test/speed_test_functions.hpp b/libs/endian/test/speed_test_functions.hpp
new file mode 100644
index 0000000..df1634f
--- /dev/null
+++ b/libs/endian/test/speed_test_functions.hpp
@@ -0,0 +1,56 @@
+//  speed_test_functions.hpp  ----------------------------------------------------------//
+
+//  Copyright Beman Dawes 2013
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  http://www.boost.org/LICENSE_1_0.txt
+
+//--------------------------------------------------------------------------------------//
+
+//  These functions are separately compiled partially to defeat optimizers and
+//  partially to create a worst case scenario. They are in a user namespace for
+//  a bit of realism.
+
+//--------------------------------------------------------------------------------------//
+
+#ifndef BOOST_ENDIAN_SPEED_TEST_FUNCTIONS_HPP
+#define BOOST_ENDIAN_SPEED_TEST_FUNCTIONS_HPP
+
+#include <boost/cstdint.hpp>
+#include <boost/endian/arithmetic.hpp>
+
+namespace user
+{
+  using namespace boost;
+  using namespace boost::endian;
+
+  int16_t return_x_big_int16(int16_t x, big_int16_t y) BOOST_NOEXCEPT;
+  int16_t return_x_little_int16(int16_t x, little_int16_t y) BOOST_NOEXCEPT;
+  int16_t return_x_value_big_int16(int16_t x, big_int16_t) BOOST_NOEXCEPT;
+  int16_t return_x_value_little_int16(int16_t x, little_int16_t y) BOOST_NOEXCEPT;
+  int16_t return_x_inplace_big_int16(int16_t x, big_int16_t y) BOOST_NOEXCEPT;
+  int16_t return_x_inplace_little_int16(int16_t x, little_int16_t y) BOOST_NOEXCEPT;
+  int16_t return_y_big_int16(int16_t x, big_int16_t y) BOOST_NOEXCEPT;
+  int16_t return_y_little_int16(int16_t x, little_int16_t y) BOOST_NOEXCEPT;
+
+  int32_t return_x_big_int32(int32_t x, big_int32_t y) BOOST_NOEXCEPT;
+  int32_t return_x_little_int32(int32_t x, little_int32_t y) BOOST_NOEXCEPT;
+  int32_t return_x_value_big_int32(int32_t x, big_int32_t) BOOST_NOEXCEPT;
+  int32_t return_x_value_little_int32(int32_t x, little_int32_t y) BOOST_NOEXCEPT;
+  int32_t return_x_inplace_big_int32(int32_t x, big_int32_t y) BOOST_NOEXCEPT;
+  int32_t return_x_inplace_little_int32(int32_t x, little_int32_t y) BOOST_NOEXCEPT;
+  int32_t return_y_big_int32(int32_t x, big_int32_t y) BOOST_NOEXCEPT;
+  int32_t return_y_little_int32(int32_t x, little_int32_t y) BOOST_NOEXCEPT;
+
+  int64_t return_x_big_int64(int64_t x, big_int64_t y) BOOST_NOEXCEPT;
+  int64_t return_x_little_int64(int64_t x, little_int64_t y) BOOST_NOEXCEPT;
+  int64_t return_x_value_big_int64(int64_t x, big_int64_t) BOOST_NOEXCEPT;
+  int64_t return_x_value_little_int64(int64_t x, little_int64_t y) BOOST_NOEXCEPT;
+  int64_t return_x_inplace_big_int64(int64_t x, big_int64_t y) BOOST_NOEXCEPT;
+  int64_t return_x_inplace_little_int64(int64_t x, little_int64_t y) BOOST_NOEXCEPT;
+  int64_t return_y_big_int64(int64_t x, big_int64_t y) BOOST_NOEXCEPT;
+  int64_t return_y_little_int64(int64_t x, little_int64_t y) BOOST_NOEXCEPT;
+
+}
+
+#endif
-- 
2.7.0.rc3

